Disassembly Listing for WellInterface
Generated From:
/Users/jhiesey/Desktop/SensorNet/WellInterface/WellInterface/dist/default/debug/WellInterface.debug.elf
May 9, 2012 3:45:35 AM

---  /Users/jhiesey/Desktop/SensorNet/WellInterface/source/main.c  --------------------------------------
1:                 #include <p24FJ64GB002.h>
2:                 #include <uart.h>
3:                 #include <ports.h>
4:                 #include <assert.h>
5:                 
6:                 #include "FreeRTOS.h"
7:                 #include "task.h"
8:                 #include "croutine.h"
9:                 #include "queue.h"
10:                
11:                #include "computerIO.h"
12:                #include "busIO.h"
13:                
14:                _CONFIG1 (FWDTEN_OFF & ICS_PGx1 & GWRP_OFF & GCP_OFF & JTAGEN_OFF);
15:                _CONFIG2 (POSCMOD_NONE & IOL1WAY_OFF & OSCIOFNC_ON & FCKSM_CSDCMD & FNOSC_FRC & PLL96MHZ_OFF & IESO_OFF);
16:                _CONFIG3 (SOSCSEL_IO);
17:                
18:                void initHardware(void) {
001B4E  FA0000     LNK #0x0
19:                    __builtin_write_OSCCONL(OSCCON & 0xBF);
001B50  803A11     MOV OSCCON, W1
001B52  200BF0     MOV #0xBF, W0
001B54  608100     AND W1, W0, W2
001B56  200461     MOV #0x46, W1
001B58  200570     MOV #0x57, W0
001B5A  207423     MOV #0x742, W3
001B5C  784981     MOV.B W1, [W3]
001B5E  784980     MOV.B W0, [W3]
001B60  784982     MOV.B W2, [W3]
20:                    // Configure RS485 UART pins
21:                    RPINR18bits.U1RXR = 7;
001B62  206A41     MOV #0x6A4, W1
001B64  784091     MOV.B [W1], W1
001B66  B3CE00     MOV #0xE0, W0
001B68  60C000     AND.B W1, W0, W0
001B6A  B34070     IOR.B #0x7, W0
001B6C  B7E6A4     MOVWF.B WREG, RPINR18
22:                    RPOR4bits.RP9R = 4;
001B6E  206C91     MOV #0x6C9, W1
001B70  784091     MOV.B [W1], W1
001B72  B3CE00     MOV #0xE0, W0
001B74  60C000     AND.B W1, W0, W0
001B76  A02400     BSET.B W0, #2
001B78  B7E6C9     MOVWF.B WREG, 0x6C9
23:                    RPOR4bits.RP8R = 3;
001B7A  206C81     MOV #0x6C8, W1
001B7C  784091     MOV.B [W1], W1
001B7E  B3CE00     MOV #0xE0, W0
001B80  60C000     AND.B W1, W0, W0
001B82  B34030     IOR.B #0x3, W0
001B84  B7E6C8     MOVWF.B WREG, RPOR4
24:                
25:                    // Configure RS232 UART pins
26:                    RPINR19bits.U2RXR = 11;
001B86  206A61     MOV #0x6A6, W1
001B88  784091     MOV.B [W1], W1
001B8A  B3CE00     MOV #0xE0, W0
001B8C  60C000     AND.B W1, W0, W0
001B8E  B340B0     IOR.B #0xB, W0
001B90  B7E6A6     MOVWF.B WREG, RPINR19
27:                    RPOR5bits.RP10R = 5;
001B92  206CA1     MOV #0x6CA, W1
001B94  784091     MOV.B [W1], W1
001B96  B3CE00     MOV #0xE0, W0
001B98  60C000     AND.B W1, W0, W0
001B9A  B34050     IOR.B #0x5, W0
001B9C  B7E6CA     MOVWF.B WREG, RPOR5
28:                
29:                    __builtin_write_OSCCONL(OSCCON | 0x40);
001B9E  803A11     MOV OSCCON, W1
001BA0  200400     MOV #0x40, W0
001BA2  708100     IOR W1, W0, W2
001BA4  200461     MOV #0x46, W1
001BA6  200570     MOV #0x57, W0
001BA8  207423     MOV #0x742, W3
001BAA  784981     MOV.B W1, [W3]
001BAC  784980     MOV.B W0, [W3]
001BAE  784982     MOV.B W2, [W3]
30:                
31:                    // Enable pullups for DIP switches
32:                    EnablePullUpCN2;
001BB0  A84068     BSET CNPU1, #2
33:                    EnablePullUpCN3;
001BB2  A86068     BSET CNPU1, #3
34:                    EnablePullUpCN30;
001BB4  A8C06B     BSET 0x6B, #6
35:                    EnablePullUpCN29;
001BB6  A8A06B     BSET 0x6B, #5
36:                    EnablePullUpCN0;
001BB8  A80068     BSET CNPU1, #0
37:                
38:                    // Disable analog inputs and set TRIS
39:                    AD1PCFG = 0x1FFF;
001BBA  21FFF0     MOV #0x1FFF, W0
001BBC  881960     MOV W0, AD1PCFG
40:                    LATA = 0;
001BBE  EB0000     CLR W0
001BC0  881620     MOV W0, LATA
41:                    LATB = 0;
001BC2  EB0000     CLR W0
001BC4  881660     MOV W0, LATB
42:                    TRISA = 0x1F;
001BC6  2001F0     MOV #0x1F, W0
001BC8  881600     MOV W0, TRISA
43:                    TRISB = 0x880;
001BCA  208800     MOV #0x880, W0
001BCC  881640     MOV W0, TRISB
44:                }
001BCE  FA8000     ULNK
001BD0  060000     RETURN
45:                
46:                
47:                void mainTaskLoop(void *parameters) {
001BD2  FA0004     LNK #0x4
001BD4  980710     MOV W0, [W14+2]
48:                
49:                    initializeComputerIO();
001BD6  07FF39     RCALL initializeComputerIO
50:                
51:                    while(1) {
52:                        char data = receiveByteComputer(portMAX_DELAY);
001BD8  EB8000     SETM W0
001BDA  07FF60     RCALL receiveByteComputer
001BDC  784F00     MOV.B W0, [W14]
53:                        sendByteComputer(data);
001BDE  78401E     MOV.B [W14], W0
001BE0  07FF53     RCALL sendByteComputer
54:                    }
001BE2  37FFFA     BRA 0x1BD8
55:                }
56:                
57:                int main(void) {
001BE4  FA0000     LNK #0x0
58:                    initHardware();
001BE6  07FFB3     RCALL initHardware
59:                
60:                    xTaskCreate(mainTaskLoop, (signed char *) "main", configMINIMAL_STACK_SIZE + 500, NULL, 1, NULL);
001BE8  283841     MOV #0x8384, W1
001BEA  EB0380     CLR W7
001BEC  EB0300     CLR W6
001BEE  EB0280     CLR W5
001BF0  200014     MOV #0x1, W4
001BF2  EB0180     CLR W3
001BF4  202672     MOV #0x267, W2
001BF6  21BD20     MOV #0x1BD2, W0
001BF8  07F3C9     RCALL xTaskGenericCreate
61:                
62:                    vTaskStartScheduler();
001BFA  07F5AF     RCALL vTaskStartScheduler
63:                
64:                    return 0;
001BFC  EB0000     CLR W0
65:                }
001BFE  FA8000     ULNK
001C00  060000     RETURN
66:                
67:                void vApplicationIdleHook(void) {
001C02  FA0000     LNK #0x0
68:                //	vCoRoutineSchedule();
69:                }
001C04  FA8000     ULNK
001C06  060000     RETURN
70:                
71:                
72:                
73:                
74:                
75:                
76:                
77:                ///* Standard includes. */
78:                //#include <stdio.h>
79:                //#include <string.h>
80:                //
81:                ///* Scheduler includes. */
82:                //#include "FreeRTOS.h"
83:                //#include "task.h"
84:                //#include "queue.h"
85:                //#include "semphr.h"
86:                //#include "croutine.h"
87:                //
88:                //#include "controls.h"
89:                //#include "lcd.h"
90:                //
91:                ///* Configuration directives. */
92:                //_CONFIG1(WDTPS_PS1 & FWPSA_PR32 & ALTVREF_ALTVREDIS & WINDIS_OFF & FWDTEN_OFF & ICS_PGx1 & GWRP_OFF & GCP_OFF & JTAGEN_OFF);
93:                //_CONFIG2(POSCMOD_HS & IOL1WAY_OFF & OSCIOFNC_ON & FCKSM_CSDCMD & FNOSC_PRI & PLL96MHZ_OFF & PLLDIV_DIV2 & IESO_OFF);
94:                //_CONFIG3(WPFP_WPFP255 & SOSCSEL_LPSOSC & WUTSEL_FST & ALTPMP_ALPMPDIS & WPDIS_WPDIS & WPCFG_WPCFGDIS & WPEND_WPSTARTMEM);
95:                //
96:                //static xQueueHandle mainQueue;
97:                //static xSemaphoreHandle mainLock;
98:                //static enum buttonState bState[5];
99:                //
100:               //static void bHandler(enum buttonState *state) {
101:               //	xSemaphoreTake(mainLock, portMAX_DELAY);
102:               //	memcpy(bState, state, sizeof(bState));
103:               //	xQueueSend(mainQueue, NULL, 0);
104:               //	xSemaphoreGive(mainLock);
105:               //}
106:               //
107:               //static void mainTaskLoop(void *parameters) {
108:               //	static enum lightState lState[4];
109:               //	static enum buttonState localBState[5];
110:               //	int i;
111:               //
112:               //	for(i = 0; i < 4; i++)
113:               //		lState[i] = LIGHT_OFF;
114:               //
115:               //	setLights(lState);
116:               //	LCDSetCursorType (CURSOR_BOTH);
117:               //
118:               //	while(1) {
119:               //		xQueueReceive(mainQueue, NULL, portMAX_DELAY);
120:               //		xSemaphoreTake(mainLock, portMAX_DELAY);
121:               //		memcpy(localBState, bState, sizeof(localBState));
122:               //		xSemaphoreGive(mainLock);
123:               //
124:               //		memset(lState, 0, sizeof(lState));
125:               //		for(i = 0; i < 5; i++) {
126:               //			if(localBState[i] == BUTTON_RELEASED) {
127:               //				lState[i % 4] = LIGHT_TOGGLE;
128:               //				printf ("%d rel!\n", i);
129:               //			} else if (localBState[i] == BUTTON_PRESSED) {
130:               //				printf ("%d pressed... ", i);
131:               //			}
132:               //		}
133:               //		setLights(lState);
134:               //		//LCDWrite(1, 7, "worked!");
135:               //	}
136:               //}
137:               //
138:               //static void mainTaskInit(void) {
139:               //	mainQueue = xQueueCreate(1, 0);
140:               //	mainLock = xSemaphoreCreateMutex();
141:               //
142:               //	registerButtonHandler(bHandler);
143:               //
144:               //	xTaskCreate(mainTaskLoop, (signed char *) "main", configMINIMAL_STACK_SIZE + 100, NULL, 1, NULL);
145:               //}
146:               //
147:               //int main(void) {
148:               //	TRISGbits.TRISG9 = 0;
149:               //	LATGbits.LATG9 = 1;
150:               //
151:               //	TRISD = 0;
152:               //	LATD = 0b00111110;
153:               //
154:               //	LATE = 0;
155:               //	TRISE = 0;
156:               //
157:               //	controlsInit();
158:               //	LCDInit();
159:               //
160:               //	mainTaskInit();
161:               //
162:               //	vTaskStartScheduler();
163:               //
164:               //	return 0;
165:               //}
166:               //
167:               //void vApplicationIdleHook(void) {
168:               //	vCoRoutineSchedule();
169:               //}
---  /Users/jhiesey/Desktop/SensorNet/WellInterface/source/computerIO.c  --------------------------------
1:                 #include <p24FJ64GB002.h>
2:                 #include <uart.h>
3:                 #include <ports.h>
4:                 
5:                 #include "computerIO.h"
6:                 #include "task.h"
7:                 #include "croutine.h"
8:                 #include "queue.h"
9:                 
10:                static xQueueHandle computerRxQueue;
11:                static xQueueHandle computerTxQueue;
12:                
13:                void initializeComputerIO(void) {
001A4A  FA0000     LNK #0x0
14:                    // Open the port for the computer connection
15:                    OpenUART2(UART_EN & UART_IDLE_CON & UART_IrDA_DISABLE & UART_MODE_SIMPLEX & UART_UEN_00 & UART_DIS_WAKE & UART_DIS_LOOPBACK & UART_DIS_ABAUD & UART_NO_PAR_8BIT & UART_UXRX_IDLE_ONE & UART_BRGH_SIXTEEN & UART_1STOPBIT,
001A4C  200192     MOV #0x19, W2
001A4E  2075F1     MOV #0x75F, W1
001A50  2CC000     MOV #0xCC00, W0
001A52  07F434     RCALL _OpenUART2
16:                        UART_INT_TX & UART_IrDA_POL_INV_ZERO & UART_SYNC_BREAK_DISABLED & UART_TX_ENABLE & UART_INT_RX_CHAR & UART_ADR_DETECT_DIS, 25);
17:                
18:                    computerRxQueue = xQueueCreate( 4, sizeof (char));
001A54  EB4100     CLR.B W2
001A56  200011     MOV #0x1, W1
001A58  200040     MOV #0x4, W0
001A5A  07F924     RCALL xQueueGenericCreate
001A5C  88E860     MOV W0, _computerRxQueue
19:                    computerTxQueue = xQueueCreate( 4, sizeof (char));
001A5E  EB4100     CLR.B W2
001A60  200011     MOV #0x1, W1
001A62  200040     MOV #0x4, W0
001A64  07F91F     RCALL xQueueGenericCreate
001A66  88E870     MOV W0, _computerTxQueue
20:                
21:                    // Turn on the UART interrupts
22:                    SetPriorityIntU2RX(1);
001A68  200B31     MOV #0xB3, W1
001A6A  784091     MOV.B [W1], W1
001A6C  B3CF80     MOV #0xF8, W0
001A6E  60C000     AND.B W1, W0, W0
001A70  A00400     BSET.B W0, #0
001A72  B7E0B3     MOVWF.B WREG, 0xB3
23:                    SetPriorityIntU2TX(1);
001A74  200B31     MOV #0xB3, W1
001A76  784091     MOV.B [W1], W1
001A78  B3C8F0     MOV #0x8F, W0
001A7A  60C000     AND.B W1, W0, W0
001A7C  A04400     BSET.B W0, #4
001A7E  B7E0B3     MOVWF.B WREG, 0xB3
24:                    EnableIntU2RX;
001A80  A8C097     BSET 0x97, #6
25:                    EnableIntU2TX;
001A82  A8E097     BSET 0x97, #7
26:                //    IEC4bits.U2ERIE = 1;
27:                }
001A84  FA8000     ULNK
001A86  060000     RETURN
28:                
29:                void sendByteComputer(char data) {
001A88  FA0002     LNK #0x2
001A8A  784F00     MOV.B W0, [W14]
30:                    xQueueSendToBack(computerTxQueue, &data, portMAX_DELAY);
001A8C  80E870     MOV _computerTxQueue, W0
001A8E  EB0180     CLR W3
001A90  EB8100     SETM W2
001A92  78008E     MOV W14, W1
001A94  07F986     RCALL xQueueGenericSend
31:                    IFS1bits.U2TXIF = 1;
001A96  A8E087     BSET 0x87, #7
32:                }
001A98  FA8000     ULNK
001A9A  060000     RETURN
33:                
34:                char receiveByteComputer(portTickType ticksToWait) {
001A9C  FA0004     LNK #0x4
001A9E  980710     MOV W0, [W14+2]
35:                    char data;
36:                    xQueueReceive(computerRxQueue, &data, ticksToWait);
001AA0  80E860     MOV _computerRxQueue, W0
001AA2  EB0180     CLR W3
001AA4  90011E     MOV [W14+2], W2
001AA6  78008E     MOV W14, W1
001AA8  07FA0F     RCALL xQueueGenericReceive
37:                    return data;
001AAA  78401E     MOV.B [W14], W0
001AAC  FB0000     SE W0, W0
38:                }
001AAE  FA8000     ULNK
001AB0  060000     RETURN
39:                
40:                void __attribute__((__interrupt__, auto_psv)) _U2RXInterrupt( void ) {
001AB2  F80036     PUSH RCOUNT
001AB4  BE9F80     MOV.D W0, [W15++]
001AB6  BE9F82     MOV.D W2, [W15++]
001AB8  BE9F84     MOV.D W4, [W15++]
001ABA  BE9F86     MOV.D W6, [W15++]
001ABC  F80034     PUSH PSVPAG
001ABE  200000     MOV #0x0, W0
001AC0  8801A0     MOV W0, PSVPAG
001AC2  FA0004     LNK #0x4
41:                    portBASE_TYPE higherPriorityTaskWoken = pdFALSE;
001AC4  EB0000     CLR W0
001AC6  780F00     MOV W0, [W14]
42:                    IFS1bits.U2RXIF = 0;
001AC8  A9C087     BCLR 0x87, #6
43:                
44:                    while(DataRdyUART2()) {
001ACA  370007     BRA 0x1ADA
001ADA  07F3E3     RCALL _DataRdyUART2
001ADC  E00400     CP0.B W0
001ADE  3AFFF6     BRA NZ, 0x1ACC
45:                        char byte = ReadUART2();
001ACC  07F40A     RCALL _ReadUART2
001ACE  984720     MOV.B W0, [W14+2]
46:                        xQueueSendToBackFromISR(computerRxQueue, &byte, &higherPriorityTaskWoken);
001AD0  80E860     MOV _computerRxQueue, W0
001AD2  E8808E     INC2 W14, W1
001AD4  EB0180     CLR W3
001AD6  78010E     MOV W14, W2
001AD8  07F9C8     RCALL xQueueGenericSendFromISR
47:                    }
48:                
49:                    U2STAbits.OERR = 0;
001AE0  A92232     BCLR U2STA, #1
50:                    if(higherPriorityTaskWoken) {
001AE2  78001E     MOV [W14], W0
001AE4  E00000     CP0 W0
001AE6  320003     BRA Z, 0x1AEE
51:                        taskYIELD();
001AE8  021C5C     CALL _vPortYield
001AEA  000000     NOP
001AEC  000000     NOP
52:                    }
53:                }
001AEE  FA8000     ULNK
001AF0  F90034     POP PSVPAG
001AF2  BE034F     MOV.D [--W15], W6
001AF4  BE024F     MOV.D [--W15], W4
001AF6  BE014F     MOV.D [--W15], W2
001AF8  BE004F     MOV.D [--W15], W0
001AFA  F90036     POP RCOUNT
001AFC  064000     RETFIE
54:                
55:                void __attribute((__interrupt__, auto_psv)) _U2TXInterrupt( void ) {
001AFE  F80036     PUSH RCOUNT
001B00  BE9F80     MOV.D W0, [W15++]
001B02  BE9F82     MOV.D W2, [W15++]
001B04  BE9F84     MOV.D W4, [W15++]
001B06  BE9F86     MOV.D W6, [W15++]
001B08  F80034     PUSH PSVPAG
001B0A  200000     MOV #0x0, W0
001B0C  8801A0     MOV W0, PSVPAG
001B0E  FA0004     LNK #0x4
56:                     portBASE_TYPE higherPriorityTaskWoken = pdFALSE;
001B10  EB0000     CLR W0
001B12  780F00     MOV W0, [W14]
57:                    IFS1bits.U2TXIF = 0;
001B14  A9E087     BCLR 0x87, #7
58:                
59:                    while(!(U2STAbits.UTXBF)) {
001B16  370009     BRA 0x1B2A
001B2A  BFC233     MOVF.B 0x233, WREG
001B2C  604062     AND.B W0, #0x2, W0
001B2E  E00400     CP0.B W0
001B30  32FFF3     BRA Z, 0x1B18
60:                        char byte;
61:                        if (xQueueReceiveFromISR(computerTxQueue, &byte, &higherPriorityTaskWoken)) {
001B18  80E870     MOV _computerTxQueue, W0
001B1A  E8808E     INC2 W14, W1
001B1C  78010E     MOV W14, W2
001B1E  07FA62     RCALL xQueueReceiveFromISR
001B20  E00000     CP0 W0
001B22  320007     BRA Z, 0x1B32
62:                            WriteUART2(byte);
001B24  90402E     MOV.B [W14+2], W0
001B26  FB0000     SE W0, W0
001B28  07F3ED     RCALL _WriteUART2
63:                        } else {
64:                            break;
65:                        }
66:                    }
67:                
68:                    if(higherPriorityTaskWoken) {
001B32  78001E     MOV [W14], W0
001B34  E00000     CP0 W0
001B36  320003     BRA Z, 0x1B3E
69:                        taskYIELD();
001B38  021C5C     CALL _vPortYield
001B3A  000000     NOP
001B3C  000000     NOP
70:                    }
71:                }
001B3E  FA8000     ULNK
001B40  F90034     POP PSVPAG
001B42  BE034F     MOV.D [--W15], W6
001B44  BE024F     MOV.D [--W15], W4
001B46  BE014F     MOV.D [--W15], W2
001B48  BE004F     MOV.D [--W15], W0
001B4A  F90036     POP RCOUNT
001B4C  064000     RETFIE
---  /Users/jhiesey/Desktop/SensorNet/WellInterface/source/busIO.c  -------------------------------------
1:                 #include <p24FJ64GB002.h>
2:                 #include <uart.h>
3:                 #include <ports.h>
4:                 
5:                 #include "busIO.h"
6:                 #include "task.h"
7:                 #include "croutine.h"
8:                 #include "queue.h"
9:                 
10:                struct busDataElem {
11:                    char data;
12:                    char signal;
13:                };
14:                
15:                static xQueueHandle busRxQueue;
16:                static xQueueHandle busTxQueue;
17:                static BOOL transmitting = 0;
18:                
19:                void initializeBusIO() {
0014CA  FA0000     LNK #0x0
20:                    // Open the port for the computer connection
21:                    OpenUART1(UART_EN & UART_IDLE_CON & UART_IrDA_DISABLE & UART_MODE_SIMPLEX & UART_UEN_00 & UART_DIS_WAKE & UART_DIS_LOOPBACK & UART_DIS_ABAUD & UART_NO_PAR_8BIT & UART_UXRX_IDLE_ONE & UART_BRGH_SIXTEEN & UART_1STOPBIT,
0014CC  200192     MOV #0x19, W2
0014CE  2075F1     MOV #0x75F, W1
0014D0  2CC000     MOV #0xCC00, W0
0014D2  07F6EA     RCALL _OpenUART1
22:                        UART_INT_TX & UART_IrDA_POL_INV_ZERO & UART_SYNC_BREAK_DISABLED & UART_TX_ENABLE & UART_INT_RX_CHAR & UART_ADR_DETECT_DIS, 25);
23:                
24:                    busRxQueue = xQueueCreate( 4, sizeof (struct busDataElem));
0014D4  EB4100     CLR.B W2
0014D6  200021     MOV #0x2, W1
0014D8  200040     MOV #0x4, W0
0014DA  07FBE4     RCALL xQueueGenericCreate
0014DC  88E840     MOV W0, _busRxQueue
25:                    busTxQueue = xQueueCreate( 4, sizeof (struct busDataElem));
0014DE  EB4100     CLR.B W2
0014E0  200021     MOV #0x2, W1
0014E2  200040     MOV #0x4, W0
0014E4  07FBDF     RCALL xQueueGenericCreate
0014E6  88E850     MOV W0, _busTxQueue
26:                
27:                    // Turn on the UART interrupts
28:                    EnableIntU1RX;
0014E8  A86095     BSET 0x95, #3
29:                    EnableIntU1TX;
0014EA  A88095     BSET 0x95, #4
30:                    IEC4bits.U1ERIE = 1;
0014EC  A8209C     BSET IEC4, #1
31:                }
0014EE  FA8000     ULNK
0014F0  060000     RETURN
32:                
33:                static void switchTransmitter(BOOL transmit) {
0014F2  FA0002     LNK #0x2
0014F4  780F00     MOV W0, [W14]
34:                    if(transmit) {
0014F6  E0001E     CP0 [W14]
0014F8  320003     BRA Z, 0x1500
35:                        DisableIntU1RX;
0014FA  A96095     BCLR 0x95, #3
36:                        LATBbits.LATB9 = 1;
0014FC  A822CD     BSET 0x2CD, #1
0014FE  370008     BRA 0x1510
37:                    } else {
38:                        LATBbits.LATB9 = 0;
001500  A922CD     BCLR 0x2CD, #1
39:                
40:                        while(DataRdyUART1()) {
001502  370001     BRA 0x1506
001506  07F6CA     RCALL _DataRdyUART1
001508  E00400     CP0.B W0
00150A  3AFFFC     BRA NZ, 0x1504
41:                            ReadUART1();
001504  07F6E5     RCALL _ReadUART1
42:                        }
43:                        U1STAbits.OERR = 0;
00150C  A92222     BCLR U1STA, #1
44:                
45:                        EnableIntU1RX;
00150E  A86095     BSET 0x95, #3
46:                    }
47:                }
001510  FA8000     ULNK
001512  060000     RETURN
48:                
49:                void switchDirection(BOOL transmit) {
001514  FA0006     LNK #0x6
001516  980720     MOV W0, [W14+4]
50:                    if(transmit == transmitting)
001518  80E831     MOV _transmitting, W1
00151A  90002E     MOV [W14+4], W0
00151C  500F81     SUB W0, W1, [W15]
00151E  32001B     BRA Z, 0x1556
51:                        return;
52:                
53:                    if(transmit) {
001520  90002E     MOV [W14+4], W0
001522  E00000     CP0 W0
001524  32000A     BRA Z, 0x153A
54:                        switchTransmitter(TRUE);
001526  200010     MOV #0x1, W0
001528  07FFE4     RCALL switchTransmitter
55:                        struct busDataElem e;
56:                        while(xQueueReceive(busRxQueue, &e, 0) == pdPASS);
00152A  80E840     MOV _busRxQueue, W0
00152C  EB0180     CLR W3
00152E  EB0100     CLR W2
001530  78008E     MOV W14, W1
001532  07FCCA     RCALL xQueueGenericReceive
001534  500FE1     SUB W0, #0x1, [W15]
001536  32FFF9     BRA Z, 0x152A
001538  37000E     BRA 0x1556
57:                    } else {
58:                        struct busDataElem e;
59:                        e.signal = 1;
00153A  E8808E     INC2 W14, W1
00153C  B3C010     MOV #0x1, W0
00153E  984090     MOV.B W0, [W1+1]
60:                        xQueueSendToBack(busTxQueue, &e, portMAX_DELAY);
001540  80E850     MOV _busTxQueue, W0
001542  E8808E     INC2 W14, W1
001544  EB0180     CLR W3
001546  EB8100     SETM W2
001548  07FC2C     RCALL xQueueGenericSend
61:                        IFS0bits.U1TXIF = 1;
00154A  A88085     BSET 0x85, #4
62:                        xQueueReceive(busRxQueue, &e, portMAX_DELAY);
00154C  80E840     MOV _busRxQueue, W0
00154E  E8808E     INC2 W14, W1
001550  EB0180     CLR W3
001552  EB8100     SETM W2
001554  07FCB9     RCALL xQueueGenericReceive
63:                    }
64:                }
001556  FA8000     ULNK
001558  060000     RETURN
65:                
66:                void sendByteBus(char data) {
00155A  FA0004     LNK #0x4
00155C  984720     MOV.B W0, [W14+2]
67:                    switchDirection(TRUE);
00155E  200010     MOV #0x1, W0
001560  07FFD9     RCALL switchDirection
68:                    struct busDataElem e;
69:                    e.data = data;
001562  90402E     MOV.B [W14+2], W0
001564  784F00     MOV.B W0, [W14]
70:                    e.signal = 0;
001566  EB4000     CLR.B W0
001568  984710     MOV.B W0, [W14+1]
71:                    xQueueSendToBack(busTxQueue, &data, portMAX_DELAY);
00156A  80E850     MOV _busTxQueue, W0
00156C  E8808E     INC2 W14, W1
00156E  EB0180     CLR W3
001570  EB8100     SETM W2
001572  07FC17     RCALL xQueueGenericSend
72:                    IFS0bits.U1TXIF = 1;
001574  A88085     BSET 0x85, #4
73:                }
001576  FA8000     ULNK
001578  060000     RETURN
74:                
75:                char receiveByteBus(portTickType ticksToWait) {
00157A  FA0004     LNK #0x4
00157C  980710     MOV W0, [W14+2]
76:                    switchDirection(FALSE);
00157E  EB0000     CLR W0
001580  07FFC9     RCALL switchDirection
77:                    struct busDataElem e;
78:                    xQueueReceive(busRxQueue, &e, ticksToWait);
001582  80E840     MOV _busRxQueue, W0
001584  EB0180     CLR W3
001586  90011E     MOV [W14+2], W2
001588  78008E     MOV W14, W1
00158A  07FC9E     RCALL xQueueGenericReceive
79:                    return e.data;
00158C  78401E     MOV.B [W14], W0
00158E  FB0000     SE W0, W0
80:                }
001590  FA8000     ULNK
001592  060000     RETURN
81:                
82:                void __attribute__((__interrupt__, auto_psv)) _U1RXInterrupt( void ) {
001594  F80036     PUSH RCOUNT
001596  BE9F80     MOV.D W0, [W15++]
001598  BE9F82     MOV.D W2, [W15++]
00159A  BE9F84     MOV.D W4, [W15++]
00159C  BE9F86     MOV.D W6, [W15++]
00159E  F80034     PUSH PSVPAG
0015A0  200000     MOV #0x0, W0
0015A2  8801A0     MOV W0, PSVPAG
0015A4  FA0004     LNK #0x4
83:                    portBASE_TYPE higherPriorityTaskWoken = pdFALSE;
0015A6  EB0000     CLR W0
0015A8  780F00     MOV W0, [W14]
84:                    IFS0bits.U1RXIF = 0;
0015AA  A96085     BCLR 0x85, #3
85:                    struct busDataElem e;
86:                
87:                    while(DataRdyUART1()) {
0015AC  37000C     BRA 0x15C6
0015C6  07F66A     RCALL _DataRdyUART1
0015C8  E00400     CP0.B W0
0015CA  3AFFF1     BRA NZ, 0x15AE
88:                        e.data = ReadUART1();
0015AE  07F690     RCALL _ReadUART1
0015B0  784080     MOV.B W0, W1
0015B2  E8800E     INC2 W14, W0
0015B4  784801     MOV.B W1, [W0]
89:                        e.signal = 0;
0015B6  E8808E     INC2 W14, W1
0015B8  EB4000     CLR.B W0
0015BA  984090     MOV.B W0, [W1+1]
90:                        xQueueSendToBackFromISR(busRxQueue, &e, &higherPriorityTaskWoken);
0015BC  80E840     MOV _busRxQueue, W0
0015BE  E8808E     INC2 W14, W1
0015C0  EB0180     CLR W3
0015C2  78010E     MOV W14, W2
0015C4  07FC52     RCALL xQueueGenericSendFromISR
91:                    }
92:                
93:                    U1STAbits.OERR = 0;
0015CC  A92222     BCLR U1STA, #1
94:                    if(higherPriorityTaskWoken) {
0015CE  78001E     MOV [W14], W0
0015D0  E00000     CP0 W0
0015D2  320003     BRA Z, 0x15DA
95:                        taskYIELD();
0015D4  021C5C     CALL _vPortYield
0015D6  000000     NOP
0015D8  000000     NOP
96:                    }
97:                }
0015DA  FA8000     ULNK
0015DC  F90034     POP PSVPAG
0015DE  BE034F     MOV.D [--W15], W6
0015E0  BE024F     MOV.D [--W15], W4
0015E2  BE014F     MOV.D [--W15], W2
0015E4  BE004F     MOV.D [--W15], W0
0015E6  F90036     POP RCOUNT
0015E8  064000     RETFIE
98:                
99:                void __attribute((__interrupt__, auto_psv)) _U1TXInterrupt( void ) {
0015EA  F80036     PUSH RCOUNT
0015EC  BE9F80     MOV.D W0, [W15++]
0015EE  BE9F82     MOV.D W2, [W15++]
0015F0  BE9F84     MOV.D W4, [W15++]
0015F2  BE9F86     MOV.D W6, [W15++]
0015F4  F80034     PUSH PSVPAG
0015F6  200000     MOV #0x0, W0
0015F8  8801A0     MOV W0, PSVPAG
0015FA  FA0004     LNK #0x4
100:                    portBASE_TYPE higherPriorityTaskWoken = pdFALSE;
0015FC  EB0000     CLR W0
0015FE  780F00     MOV W0, [W14]
101:                   IFS0bits.U1TXIF = 0;
001600  A98085     BCLR 0x85, #4
102:                   struct busDataElem e;
103:               
104:                   if(U1STAbits.UTXISEL0 && U1STAbits.TRMT == 1) {
001602  BFC223     MOVF.B 0x223, WREG
001604  B24200     AND.B #0x20, W0
001606  E00400     CP0.B W0
001608  320020     BRA Z, 0x164A
00160A  BFC223     MOVF.B 0x223, WREG
00160C  604061     AND.B W0, #0x1, W0
00160E  E00400     CP0.B W0
001610  32001C     BRA Z, 0x164A
001628  370014     BRA 0x1652
105:                       switchTransmitter(FALSE);
001612  EB0000     CLR W0
001614  07FF6E     RCALL switchTransmitter
106:                       U1STAbits.UTXISEL0 = 0;
001616  A9A223     BCLR 0x223, #5
107:                       e.signal = 1;
001618  E8808E     INC2 W14, W1
00161A  B3C010     MOV #0x1, W0
00161C  984090     MOV.B W0, [W1+1]
108:                       xQueueSendToBackFromISR(busRxQueue, &e, &higherPriorityTaskWoken);
00161E  80E840     MOV _busRxQueue, W0
001620  E8808E     INC2 W14, W1
001622  EB0180     CLR W3
001624  78010E     MOV W14, W2
001626  07FC21     RCALL xQueueGenericSendFromISR
109:                   } else {
110:                       while(!(U1STAbits.UTXBF)) {
00164A  BFC223     MOVF.B 0x223, WREG
00164C  604062     AND.B W0, #0x2, W0
00164E  E00400     CP0.B W0
001650  32FFEC     BRA Z, 0x162A
111:                           if (xQueueReceiveFromISR(busTxQueue, &e, &higherPriorityTaskWoken)) {
00162A  80E850     MOV _busTxQueue, W0
00162C  E8808E     INC2 W14, W1
00162E  78010E     MOV W14, W2
001630  07FCD9     RCALL xQueueReceiveFromISR
001632  E00000     CP0 W0
001634  32000E     BRA Z, 0x1652
112:                               if(e.signal == 1) {
001636  E8800E     INC2 W14, W0
001638  904010     MOV.B [W0+1], W0
00163A  504FE1     SUB.B W0, #0x1, [W15]
00163C  3A0002     BRA NZ, 0x1642
113:                                   U1STAbits.UTXISEL0 = 1;
00163E  A8A223     BSET 0x223, #5
114:                                   break;
001640  370008     BRA 0x1652
115:                               } else {
116:                                   WriteUART1(e.data);
001642  E8800E     INC2 W14, W0
001644  784010     MOV.B [W0], W0
001646  FB0000     SE W0, W0
001648  07F655     RCALL _WriteUART1
117:                               }
118:                           } else {
119:                               break;
120:                           }
121:                       }
122:                   }
123:               
124:                   if(higherPriorityTaskWoken) {
001652  78001E     MOV [W14], W0
001654  E00000     CP0 W0
001656  320003     BRA Z, 0x165E
125:                       taskYIELD();
001658  021C5C     CALL _vPortYield
00165A  000000     NOP
00165C  000000     NOP
126:                   }
127:               }
00165E  FA8000     ULNK
001660  F90034     POP PSVPAG
001662  BE034F     MOV.D [--W15], W6
001664  BE024F     MOV.D [--W15], W4
001666  BE014F     MOV.D [--W15], W2
001668  BE004F     MOV.D [--W15], W0
00166A  F90036     POP RCOUNT
00166C  064000     RETFIE
---  /Users/jhiesey/Desktop/SensorNet/WellInterface/FreeRTOS/Source/tasks.c  ----------------------------
1:                 /*
2:                     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
3:                 	
4:                 
5:                     ***************************************************************************
6:                      *                                                                       *
7:                      *    FreeRTOS tutorial books are available in pdf and paperback.        *
8:                      *    Complete, revised, and edited pdf reference manuals are also       *
9:                      *    available.                                                         *
10:                     *                                                                       *
11:                     *    Purchasing FreeRTOS documentation will not only help you, by       *
12:                     *    ensuring you get running as quickly as possible and with an        *
13:                     *    in-depth knowledge of how to use FreeRTOS, it will also help       *
14:                     *    the FreeRTOS project to continue with its mission of providing     *
15:                     *    professional grade, cross platform, de facto standard solutions    *
16:                     *    for microcontrollers - completely free of charge!                  *
17:                     *                                                                       *
18:                     *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
19:                     *                                                                       *
20:                     *    Thank you for using FreeRTOS, and thank you for your support!      *
21:                     *                                                                       *
22:                    ***************************************************************************
23:                
24:                
25:                    This file is part of the FreeRTOS distribution.
26:                
27:                    FreeRTOS is free software; you can redistribute it and/or modify it under
28:                    the terms of the GNU General Public License (version 2) as published by the
29:                    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
30:                    >>>NOTE<<< The modification to the GPL is included to allow you to
31:                    distribute a combined work that includes FreeRTOS without being obliged to
32:                    provide the source code for proprietary components outside of the FreeRTOS
33:                    kernel.  FreeRTOS is distributed in the hope that it will be useful, but
34:                    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
35:                    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
36:                    more details. You should have received a copy of the GNU General Public
37:                    License and the FreeRTOS license exception along with FreeRTOS; if not it
38:                    can be viewed here: http://www.freertos.org/a00114.html and also obtained
39:                    by writing to Richard Barry, contact details for whom are available on the
40:                    FreeRTOS WEB site.
41:                
42:                    1 tab == 4 spaces!
43:                
44:                    http://www.FreeRTOS.org - Documentation, latest information, license and
45:                    contact details.
46:                
47:                    http://www.SafeRTOS.com - A version that is certified for use in safety
48:                    critical systems.
49:                
50:                    http://www.OpenRTOS.com - Commercial support, development, porting,
51:                    licensing and training services.
52:                */
53:                
54:                
55:                #include <stdio.h>
56:                #include <stdlib.h>
57:                #include <string.h>
58:                
59:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
60:                all the API functions to use the MPU wrappers.  That should only be done when
61:                task.h is included from an application file. */
62:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
63:                
64:                #include "FreeRTOS.h"
65:                #include "task.h"
66:                #include "timers.h"
67:                #include "StackMacros.h"
68:                
69:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
70:                
71:                /*
72:                 * Macro to define the amount of stack available to the idle task.
73:                 */
74:                #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
75:                
76:                /*
77:                 * Task control block.  A task control block (TCB) is allocated to each task,
78:                 * and stores the context of the task.
79:                 */
80:                typedef struct tskTaskControlBlock
81:                {
82:                	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE STRUCT. */
83:                
84:                	#if ( portUSING_MPU_WRAPPERS == 1 )
85:                		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE STRUCT. */
86:                	#endif	
87:                	
88:                	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
89:                	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
90:                	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. */
91:                	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
92:                	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */
93:                
94:                	#if ( portSTACK_GROWTH > 0 )
95:                		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the stack grows up from low memory. */
96:                	#endif
97:                
98:                	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
99:                		unsigned portBASE_TYPE uxCriticalNesting;
100:               	#endif
101:               
102:               	#if ( configUSE_TRACE_FACILITY == 1 )
103:               		unsigned portBASE_TYPE	uxTCBNumber;	/*< This stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
104:               		unsigned portBASE_TYPE  uxTaskNumber;	/*< This stores a number specifically for use by third party trace code. */
105:               	#endif
106:               
107:               	#if ( configUSE_MUTEXES == 1 )
108:               		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
109:               	#endif
110:               
111:               	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
112:               		pdTASK_HOOK_CODE pxTaskTag;
113:               	#endif
114:               
115:               	#if ( configGENERATE_RUN_TIME_STATS == 1 )
116:               		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilising. */
117:               	#endif
118:               
119:               } tskTCB;
120:               
121:               
122:               /*
123:                * Some kernel aware debuggers require data to be viewed to be global, rather
124:                * than file scope.
125:                */
126:               #ifdef portREMOVE_STATIC_QUALIFIER
127:               	#define static
128:               #endif
129:               
130:               /*lint -e956 */
131:               PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
132:               
133:               /* Lists for ready and blocked tasks. --------------------*/
134:               
135:               PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks. */
136:               PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
137:               PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
138:               PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list currently being used. */
139:               PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
140:               PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready queue when the scheduler is resumed. */
141:               
142:               #if ( INCLUDE_vTaskDelete == 1 )
143:               
144:               	PRIVILEGED_DATA static xList xTasksWaitingTermination;				/*< Tasks that have been deleted - but the their memory not yet freed. */
145:               	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE ) 0U;
146:               
147:               #endif
148:               
149:               #if ( INCLUDE_vTaskSuspend == 1 )
150:               
151:               	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
152:               
153:               #endif
154:               
155:               #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
156:               	
157:               	PRIVILEGED_DATA static xTaskHandle xIdleTaskHandle = NULL;
158:               	
159:               #endif
160:               
161:               /* File private variables. --------------------------------*/
162:               PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBASE_TYPE ) 0U;
163:               PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0U;
164:               PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
165:               PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
166:               PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
167:               PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE_TYPE ) pdFALSE;
168:               PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE ) 0U;
169:               PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
170:               PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
171:               PRIVILEGED_DATA static unsigned portBASE_TYPE uxTCBNumber 						= ( unsigned portBASE_TYPE ) 0U;
172:               PRIVILEGED_DATA static portTickType xNextTaskUnblockTime						= ( portTickType ) portMAX_DELAY;
173:               
174:               #if ( configGENERATE_RUN_TIME_STATS == 1 )
175:               
176:               	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
177:               	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
178:               	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList, unsigned long ulTotalRunTime ) PRIVILEGED_FUNCTION;
179:               
180:               #endif
181:               
182:               /* Debugging and trace facilities private variables and macros. ------------*/
183:               
184:               /*
185:                * The value used to fill the stack of a task when the task is created.  This
186:                * is used purely for checking the high water mark for tasks.
187:                */
188:               #define tskSTACK_FILL_BYTE	( 0xa5U )
189:               
190:               /*
191:                * Macros used by vListTask to indicate which state a task is in.
192:                */
193:               #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
194:               #define tskREADY_CHAR		( ( signed char ) 'R' )
195:               #define tskDELETED_CHAR		( ( signed char ) 'D' )
196:               #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
197:               
198:               /*-----------------------------------------------------------*/
199:               
200:               /*
201:                * Place the task represented by pxTCB into the appropriate ready queue for
202:                * the task.  It is inserted at the end of the list.  One quirk of this is
203:                * that if the task being inserted is at the same priority as the currently
204:                * executing task, then it will only be rescheduled after the currently
205:                * executing task has been rescheduled.
206:                */
207:               #define prvAddTaskToReadyQueue( pxTCB )																					\
208:               	if( ( pxTCB )->uxPriority > uxTopReadyPriority )																	\
209:               	{																													\
210:               		uxTopReadyPriority = ( pxTCB )->uxPriority;																		\
211:               	}																													\
212:               	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) )
213:               /*-----------------------------------------------------------*/
214:               
215:               /*
216:                * Macro that looks at the list of tasks that are currently delayed to see if
217:                * any require waking.
218:                *
219:                * Tasks are stored in the queue in the order of their wake time - meaning
220:                * once one tasks has been found whose timer has not expired we need not look
221:                * any further down the list.
222:                */
223:               #define prvCheckDelayedTasks()															\
224:               {																						\
225:               portTickType xItemValue;																\
226:               																						\
227:               	/* Is the tick count greater than or equal to the wake time of the first			\
228:               	task referenced from the delayed tasks list? */										\
229:               	if( xTickCount >= xNextTaskUnblockTime )											\
230:               	{																					\
231:               		for( ;; )																		\
232:               		{																				\
233:               			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )						\
234:               			{																			\
235:               				/* The delayed list is empty.  Set xNextTaskUnblockTime to the			\
236:               				maximum possible value so it is extremely unlikely that the				\
237:               				if( xTickCount >= xNextTaskUnblockTime ) test will pass next			\
238:               				time through. */														\
239:               				xNextTaskUnblockTime = portMAX_DELAY;									\
240:               				break;																	\
241:               			}																			\
242:               			else																		\
243:               			{																			\
244:               				/* The delayed list is not empty, get the value of the item at			\
245:               				the head of the delayed list.  This is the time at which the			\
246:               				task at the head of the delayed list should be removed from				\
247:               				the Blocked state. */													\
248:               				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );	\
249:               				xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );	\
250:               																						\
251:               				if( xTickCount < xItemValue )											\
252:               				{																		\
253:               					/* It is not time to unblock this item yet, but the item			\
254:               					value is the time at which the task at the head of the				\
255:               					blocked list should be removed from the Blocked state -				\
256:               					so record the item value in xNextTaskUnblockTime. */				\
257:               					xNextTaskUnblockTime = xItemValue;									\
258:               					break;																\
259:               				}																		\
260:               																						\
261:               				/* It is time to remove the item from the Blocked state. */				\
262:               				vListRemove( &( pxTCB->xGenericListItem ) );							\
263:               																						\
264:               				/* Is the task waiting on an event also? */								\
265:               				if( pxTCB->xEventListItem.pvContainer != NULL )							\
266:               				{																		\
267:               					vListRemove( &( pxTCB->xEventListItem ) );							\
268:               				}																		\
269:               				prvAddTaskToReadyQueue( pxTCB );										\
270:               			}																			\
271:               		}																				\
272:               	}																					\
273:               }
274:               /*-----------------------------------------------------------*/
275:               
276:               /*
277:                * Several functions take an xTaskHandle parameter that can optionally be NULL,
278:                * where NULL is used to indicate that the handle of the currently executing
279:                * task should be used in place of the parameter.  This macro simply checks to
280:                * see if the parameter is NULL and returns a pointer to the appropriate TCB.
281:                */
282:               #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( tskTCB * ) ( pxHandle ) )
283:               
284:               /* Callback function prototypes. --------------------------*/
285:               extern void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName );
286:               extern void vApplicationTickHook( void );
287:               		
288:               /* File private functions. --------------------------------*/
289:               
290:               /*
291:                * Utility to ready a TCB for a given task.  Mainly just copies the parameters
292:                * into the TCB structure.
293:                */
294:               static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth ) PRIVILEGED_FUNCTION;
295:               
296:               /*
297:                * Utility to ready all the lists used by the scheduler.  This is called
298:                * automatically upon the creation of the first task.
299:                */
300:               static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
301:               
302:               /*
303:                * The idle task, which as all tasks is implemented as a never ending loop.
304:                * The idle task is automatically created and added to the ready lists upon
305:                * creation of the first user task.
306:                *
307:                * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
308:                * language extensions.  The equivalent prototype for this function is:
309:                *
310:                * void prvIdleTask( void *pvParameters );
311:                *
312:                */
313:               static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
314:               
315:               /*
316:                * Utility to free all memory allocated by the scheduler to hold a TCB,
317:                * including the stack pointed to by the TCB.
318:                *
319:                * This does not free memory allocated by the task itself (i.e. memory
320:                * allocated by calls to pvPortMalloc from within the tasks application code).
321:                */
322:               #if ( INCLUDE_vTaskDelete == 1 )
323:               
324:               	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
325:               
326:               #endif
327:               
328:               /*
329:                * Used only by the idle task.  This checks to see if anything has been placed
330:                * in the list of tasks waiting to be deleted.  If so the task is cleaned up
331:                * and its TCB deleted.
332:                */
333:               static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
334:               
335:               /*
336:                * The currently executing task is entering the Blocked state.  Add the task to
337:                * either the current or the overflow delayed task list.
338:                */
339:               static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake ) PRIVILEGED_FUNCTION;
340:               
341:               /*
342:                * Allocates memory from the heap for a TCB and associated stack.  Checks the
343:                * allocation was successful.
344:                */
345:               static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer ) PRIVILEGED_FUNCTION;
346:               
347:               /*
348:                * Called from vTaskList.  vListTasks details all the tasks currently under
349:                * control of the scheduler.  The tasks may be in one of a number of lists.
350:                * prvListTaskWithinSingleList accepts a list and details the tasks from
351:                * within just that list.
352:                *
353:                * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
354:                * NORMAL APPLICATION CODE.
355:                */
356:               #if ( configUSE_TRACE_FACILITY == 1 )
357:               
358:               	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus ) PRIVILEGED_FUNCTION;
359:               
360:               #endif
361:               
362:               /*
363:                * When a task is created, the stack of the task is filled with a known value.
364:                * This function determines the 'high water mark' of the task stack by
365:                * determining how much of the stack remains at the original preset value.
366:                */
367:               #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
368:               
369:               	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_FUNCTION;
370:               
371:               #endif
372:               
373:               
374:               /*lint +e956 */
375:               
376:               
377:               
378:               /*-----------------------------------------------------------
379:                * TASK CREATION API documented in task.h
380:                *----------------------------------------------------------*/
381:               
382:               signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
383:               {
00038C  FA0016     LNK #0x16
00038E  980730     MOV W0, [W14+6]
000390  980741     MOV W1, [W14+8]
000392  980752     MOV W2, [W14+10]
000394  980763     MOV W3, [W14+12]
000396  980774     MOV W4, [W14+14]
000398  980F05     MOV W5, [W14+16]
00039A  980F16     MOV W6, [W14+18]
00039C  980F27     MOV W7, [W14+20]
384:               signed portBASE_TYPE xReturn;
385:               tskTCB * pxNewTCB;
386:               
387:               	configASSERT( pxTaskCode );
388:               	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );
389:               
390:               	/* Allocate the memory required by the TCB and stack for the new task,
391:               	checking that the allocation was successful. */
392:               	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
00039E  90089E     MOV [W14+18], W1
0003A0  90005E     MOV [W14+10], W0
0003A2  0703F0     RCALL prvAllocateTCBAndStack
0003A4  980710     MOV W0, [W14+2]
393:               
394:               	if( pxNewTCB != NULL )
0003A6  90001E     MOV [W14+2], W0
0003A8  E00000     CP0 W0
0003AA  320057     BRA Z, 0x45A
395:               	{
396:               		portSTACK_TYPE *pxTopOfStack;
397:               
398:               		#if( portUSING_MPU_WRAPPERS == 1 )
399:               			/* Should the task be created in privileged mode? */
400:               			portBASE_TYPE xRunPrivileged;
401:               			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
402:               			{
403:               				xRunPrivileged = pdTRUE;
404:               			}
405:               			else
406:               			{
407:               				xRunPrivileged = pdFALSE;
408:               			}
409:               			uxPriority &= ~portPRIVILEGE_BIT;
410:               		#endif /* portUSING_MPU_WRAPPERS == 1 */
411:               
412:               		/* Calculate the top of stack address.  This depends on whether the
413:               		stack grows from high memory to low (as per the 80x86) or visa versa.
414:               		portSTACK_GROWTH is used to make the result positive or negative as
415:               		required by the port. */
416:               		#if( portSTACK_GROWTH < 0 )
417:               		{
418:               			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
419:               			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
420:               
421:               			/* Check the alignment of the calculated top of stack is correct. */
422:               			configASSERT( ( ( ( unsigned long ) pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
423:               		}
424:               		#else
425:               		{
426:               			pxTopOfStack = pxNewTCB->pxStack;
0003AC  90001E     MOV [W14+2], W0
0003AE  9008C0     MOV [W0+24], W1
0003B0  780F01     MOV W1, [W14]
427:               			
428:               			/* Check the alignment of the stack buffer is correct. */
429:               			configASSERT( ( ( ( unsigned long ) pxNewTCB->pxStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
430:               
431:               			/* If we want to use stack checking on architectures that use
432:               			a positive stack growth direction then we also need to store the
433:               			other extreme of the stack space. */
434:               			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
0003B2  90001E     MOV [W14+2], W0
0003B4  9008C0     MOV [W0+24], W1
0003B6  90005E     MOV [W14+10], W0
0003B8  400000     ADD W0, W0, W0
0003BA  408000     ADD W1, W0, W0
0003BC  E98080     DEC2 W0, W1
0003BE  90001E     MOV [W14+2], W0
0003C0  980871     MOV W1, [W0+30]
435:               		}
436:               		#endif
437:               
438:               		/* Setup the newly allocated TCB with the initial state of the task. */
439:               		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
0003C2  90025E     MOV [W14+10], W4
0003C4  9009AE     MOV [W14+20], W3
0003C6  90017E     MOV [W14+14], W2
0003C8  9000CE     MOV [W14+8], W1
0003CA  90001E     MOV [W14+2], W0
0003CC  07037A     RCALL prvInitialiseTCBVariables
440:               
441:               		/* Initialize the TCB stack to look as if the task was already running,
442:               		but had been interrupted by the scheduler.  The return address is set
443:               		to the start of the task function. Once the stack has been initialised
444:               		the	top of stack variable is updated. */
445:               		#if( portUSING_MPU_WRAPPERS == 1 )
446:               		{
447:               			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
448:               		}
449:               		#else
450:               		{
451:               			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
0003CE  90016E     MOV [W14+12], W2
0003D0  9000BE     MOV [W14+6], W1
0003D2  78001E     MOV [W14], W0
0003D4  070A04     RCALL pxPortInitialiseStack
0003D6  780080     MOV W0, W1
0003D8  90001E     MOV [W14+2], W0
0003DA  780801     MOV W1, [W0]
452:               		}
453:               		#endif
454:               
455:               		/* Check the alignment of the initialised stack. */
456:               		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
457:               
458:               		if( ( void * ) pxCreatedTask != NULL )
0003DC  90080E     MOV [W14+16], W0
0003DE  E00000     CP0 W0
0003E0  320003     BRA Z, 0x3E8
459:               		{
460:               			/* Pass the TCB out - in an anonymous way.  The calling function/
461:               			task can use this as a handle to delete the task later if
462:               			required.*/
463:               			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
0003E2  90080E     MOV [W14+16], W0
0003E4  90009E     MOV [W14+2], W1
0003E6  780801     MOV W1, [W0]
464:               		}
465:               		
466:               		/* We are going to manipulate the task queues to add this task to a
467:               		ready list, so must make sure no interrupts occur. */
468:               		taskENTER_CRITICAL();
0003E8  070A6F     RCALL vPortEnterCritical
469:               		{
470:               			uxCurrentNumberOfTasks++;
0003EA  80E730     MOV 0x1CE6, W0
0003EC  E80000     INC W0, W0
0003EE  88E730     MOV W0, 0x1CE6
471:               			if( pxCurrentTCB == NULL )
0003F0  80E720     MOV 0x1CE4, W0
0003F2  E00000     CP0 W0
0003F4  3A0007     BRA NZ, 0x404
472:               			{
473:               				/* There are no other tasks, or all the other tasks are in
474:               				the suspended state - make this the current task. */
475:               				pxCurrentTCB =  pxNewTCB;
0003F6  90001E     MOV [W14+2], W0
0003F8  88E720     MOV W0, 0x1CE4
476:               
477:               				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
0003FA  80E730     MOV 0x1CE6, W0
0003FC  500FE1     SUB W0, #0x1, [W15]
0003FE  3A000C     BRA NZ, 0x418
478:               				{
479:               					/* This is the first task to be created so do the preliminary
480:               					initialisation required.  We will not recover if this call
481:               					fails, but we will report the failure. */
482:               					prvInitialiseTaskLists();
000400  07038A     RCALL prvInitialiseTaskLists
000402  37000A     BRA 0x418
483:               				}
484:               			}
485:               			else
486:               			{
487:               				/* If the scheduler is not already running, make this task the
488:               				current task if it is the highest priority task to be created
489:               				so far. */
490:               				if( xSchedulerRunning == pdFALSE )
000404  80E770     MOV 0x1CEE, W0
000406  E00000     CP0 W0
000408  3A0007     BRA NZ, 0x418
491:               				{
492:               					if( pxCurrentTCB->uxPriority <= uxPriority )
00040A  80E720     MOV 0x1CE4, W0
00040C  9008B0     MOV [W0+22], W1
00040E  90007E     MOV [W14+14], W0
000410  508F80     SUB W1, W0, [W15]
000412  3E0002     BRA GTU, 0x418
493:               					{
494:               						pxCurrentTCB = pxNewTCB;
000414  90009E     MOV [W14+2], W1
000416  88E721     MOV W1, 0x1CE4
495:               					}
496:               				}
497:               			}
498:               
499:               			/* Remember the top priority to make context switching faster.  Use
500:               			the priority in pxNewTCB as this has been capped to a valid value. */
501:               			if( pxNewTCB->uxPriority > uxTopUsedPriority )
000418  90001E     MOV [W14+2], W0
00041A  9008B0     MOV [W0+22], W1
00041C  80E750     MOV 0x1CEA, W0
00041E  508F80     SUB W1, W0, [W15]
000420  360003     BRA LEU, 0x428
502:               			{
503:               				uxTopUsedPriority = pxNewTCB->uxPriority;
000422  90001E     MOV [W14+2], W0
000424  900830     MOV [W0+22], W0
000426  88E750     MOV W0, 0x1CEA
504:               			}
505:               
506:               			#if ( configUSE_TRACE_FACILITY == 1 )
507:               			{
508:               				/* Add a counter into the TCB for tracing only. */
509:               				pxNewTCB->uxTCBNumber = uxTCBNumber;
510:               			}
511:               			#endif
512:               			uxTCBNumber++;
000428  80E7C0     MOV 0x1CF8, W0
00042A  E80000     INC W0, W0
00042C  88E7C0     MOV W0, 0x1CF8
513:               
514:               			prvAddTaskToReadyQueue( pxNewTCB );
00042E  90001E     MOV [W14+2], W0
000430  9008B0     MOV [W0+22], W1
000432  80E760     MOV 0x1CEC, W0
000434  508F80     SUB W1, W0, [W15]
000436  360003     BRA LEU, 0x43E
000438  90001E     MOV [W14+2], W0
00043A  900830     MOV [W0+22], W0
00043C  88E760     MOV W0, 0x1CEC
00043E  90001E     MOV [W14+2], W0
000440  E88100     INC2 W0, W2
000442  90001E     MOV [W14+2], W0
000444  900830     MOV [W0+22], W0
000446  B9006A     MUL.SU W0, #10, W0
000448  780080     MOV W0, W1
00044A  21C5A0     MOV #0x1C5A, W0
00044C  408000     ADD W1, W0, W0
00044E  780082     MOV W2, W1
000450  070A88     RCALL vListInsertEnd
515:               
516:               			xReturn = pdPASS;
000452  200010     MOV #0x1, W0
000454  980720     MOV W0, [W14+4]
517:               			traceTASK_CREATE( pxNewTCB );
518:               		}
519:               		taskEXIT_CRITICAL();
000456  070A42     RCALL vPortExitCritical
000458  370002     BRA 0x45E
520:               	}
521:               	else
522:               	{
523:               		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
00045A  EB8000     SETM W0
00045C  980720     MOV W0, [W14+4]
524:               		traceTASK_CREATE_FAILED();
525:               	}
526:               
527:               	if( xReturn == pdPASS )
00045E  90002E     MOV [W14+4], W0
000460  500FE1     SUB W0, #0x1, [W15]
000462  3A000B     BRA NZ, 0x47A
528:               	{
529:               		if( xSchedulerRunning != pdFALSE )
000464  80E770     MOV 0x1CEE, W0
000466  E00000     CP0 W0
000468  320008     BRA Z, 0x47A
530:               		{
531:               			/* If the created task is of a higher priority than the current task
532:               			then it should run now. */
533:               			if( pxCurrentTCB->uxPriority < uxPriority )
00046A  80E720     MOV 0x1CE4, W0
00046C  9008B0     MOV [W0+22], W1
00046E  90007E     MOV [W14+14], W0
000470  508F80     SUB W1, W0, [W15]
000472  310003     BRA C, 0x47A
534:               			{
535:               				portYIELD_WITHIN_API();
000474  021C5C     CALL _vPortYield
000476  000000     NOP
000478  000000     NOP
536:               			}
537:               		}
538:               	}
539:               
540:               	return xReturn;
00047A  90002E     MOV [W14+4], W0
541:               }
00047C  FA8000     ULNK
00047E  060000     RETURN
542:               /*-----------------------------------------------------------*/
543:               
544:               #if ( INCLUDE_vTaskDelete == 1 )
545:               
546:               	void vTaskDelete( xTaskHandle pxTaskToDelete )
547:               	{
548:               	tskTCB *pxTCB;
549:               
550:               		taskENTER_CRITICAL();
551:               		{
552:               			/* Ensure a yield is performed if the current task is being
553:               			deleted. */
554:               			if( pxTaskToDelete == pxCurrentTCB )
555:               			{
556:               				pxTaskToDelete = NULL;
557:               			}
558:               
559:               			/* If null is passed in here then we are deleting ourselves. */
560:               			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
561:               
562:               			/* Remove task from the ready list and place in the	termination list.
563:               			This will stop the task from be scheduled.  The idle task will check
564:               			the termination list and free up any memory allocated by the
565:               			scheduler for the TCB and stack. */
566:               			vListRemove( &( pxTCB->xGenericListItem ) );
567:               
568:               			/* Is the task waiting on an event also? */
569:               			if( pxTCB->xEventListItem.pvContainer != NULL )
570:               			{
571:               				vListRemove( &( pxTCB->xEventListItem ) );
572:               			}
573:               
574:               			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
575:               
576:               			/* Increment the ucTasksDeleted variable so the idle task knows
577:               			there is a task that has been deleted and that it should therefore
578:               			check the xTasksWaitingTermination list. */
579:               			++uxTasksDeleted;
580:               
581:               			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
582:               			can detect that the task lists need re-generating. */
583:               			uxTCBNumber++;
584:               
585:               			traceTASK_DELETE( pxTCB );
586:               		}
587:               		taskEXIT_CRITICAL();
588:               
589:               		/* Force a reschedule if we have just deleted the current task. */
590:               		if( xSchedulerRunning != pdFALSE )
591:               		{
592:               			if( ( void * ) pxTaskToDelete == NULL )
593:               			{
594:               				portYIELD_WITHIN_API();
595:               			}
596:               		}
597:               	}
598:               
599:               #endif
600:               
601:               
602:               
603:               
604:               
605:               
606:               /*-----------------------------------------------------------
607:                * TASK CONTROL API documented in task.h
608:                *----------------------------------------------------------*/
609:               
610:               #if ( INCLUDE_vTaskDelayUntil == 1 )
611:               
612:               	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
613:               	{
000480  FA000A     LNK #0xA
000482  980730     MOV W0, [W14+6]
000484  980741     MOV W1, [W14+8]
614:               	portTickType xTimeToWake;
615:               	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
000486  EB0000     CLR W0
000488  780F00     MOV W0, [W14]
616:               
617:               		configASSERT( pxPreviousWakeTime );
618:               		configASSERT( ( xTimeIncrement > 0U ) );
619:               
620:               		vTaskSuspendAll();
00048A  07018A     RCALL vTaskSuspendAll
621:               		{
622:               			/* Generate the tick time at which the task wants to wake. */
623:               			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
00048C  90003E     MOV [W14+6], W0
00048E  780090     MOV [W0], W1
000490  90004E     MOV [W14+8], W0
000492  408000     ADD W1, W0, W0
000494  980720     MOV W0, [W14+4]
624:               
625:               			if( xTickCount < *pxPreviousWakeTime )
000496  90003E     MOV [W14+6], W0
000498  780090     MOV [W0], W1
00049A  80E740     MOV 0x1CE8, W0
00049C  508F80     SUB W1, W0, [W15]
00049E  36000C     BRA LEU, 0x4B8
626:               			{
627:               				/* The tick count has overflowed since this function was
628:               				lasted called.  In this case the only time we should ever
629:               				actually delay is if the wake time has also	overflowed,
630:               				and the wake time is greater than the tick time.  When this
631:               				is the case it is as if neither time had overflowed. */
632:               				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
0004A0  90003E     MOV [W14+6], W0
0004A2  780090     MOV [W0], W1
0004A4  90002E     MOV [W14+4], W0
0004A6  508F80     SUB W1, W0, [W15]
0004A8  360012     BRA LEU, 0x4CE
0004AA  80E741     MOV 0x1CE8, W1
0004AC  90002E     MOV [W14+4], W0
0004AE  500F81     SUB W0, W1, [W15]
0004B0  36000E     BRA LEU, 0x4CE
633:               				{
634:               					xShouldDelay = pdTRUE;
0004B2  200010     MOV #0x1, W0
0004B4  780F00     MOV W0, [W14]
0004B6  37000B     BRA 0x4CE
635:               				}
636:               			}
637:               			else
638:               			{
639:               				/* The tick time has not overflowed.  In this case we will
640:               				delay if either the wake time has overflowed, and/or the
641:               				tick time is less than the wake time. */
642:               				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
0004B8  90003E     MOV [W14+6], W0
0004BA  780090     MOV [W0], W1
0004BC  90002E     MOV [W14+4], W0
0004BE  508F80     SUB W1, W0, [W15]
0004C0  3E0004     BRA GTU, 0x4CA
0004C2  80E741     MOV 0x1CE8, W1
0004C4  90002E     MOV [W14+4], W0
0004C6  500F81     SUB W0, W1, [W15]
0004C8  360002     BRA LEU, 0x4CE
643:               				{
644:               					xShouldDelay = pdTRUE;
0004CA  200010     MOV #0x1, W0
0004CC  780F00     MOV W0, [W14]
645:               				}
646:               			}
647:               
648:               			/* Update the wake time ready for the next call. */
649:               			*pxPreviousWakeTime = xTimeToWake;
0004CE  90003E     MOV [W14+6], W0
0004D0  9000AE     MOV [W14+4], W1
0004D2  780801     MOV W1, [W0]
650:               
651:               			if( xShouldDelay != pdFALSE )
0004D4  E0001E     CP0 [W14]
0004D6  320005     BRA Z, 0x4E2
652:               			{
653:               				traceTASK_DELAY_UNTIL();
654:               
655:               				/* We must remove ourselves from the ready list before adding
656:               				ourselves to the blocked list as the same list item is used for
657:               				both lists. */
658:               				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
0004D8  80E720     MOV 0x1CE4, W0
0004DA  E88000     INC2 W0, W0
0004DC  070A94     RCALL vListRemove
659:               				prvAddCurrentTaskToDelayedList( xTimeToWake );
0004DE  90002E     MOV [W14+4], W0
0004E0  070339     RCALL prvAddCurrentTaskToDelayedList
660:               			}
661:               		}
662:               		xAlreadyYielded = xTaskResumeAll();
0004E2  070164     RCALL xTaskResumeAll
0004E4  980710     MOV W0, [W14+2]
663:               
664:               		/* Force a reschedule if xTaskResumeAll has not already done so, we may
665:               		have put ourselves to sleep. */
666:               		if( xAlreadyYielded == pdFALSE )
0004E6  90001E     MOV [W14+2], W0
0004E8  E00000     CP0 W0
0004EA  3A0003     BRA NZ, 0x4F2
667:               		{
668:               			portYIELD_WITHIN_API();
0004EC  021C5C     CALL _vPortYield
0004EE  000000     NOP
0004F0  000000     NOP
669:               		}
670:               	}
0004F2  FA8000     ULNK
0004F4  060000     RETURN
671:               
672:               #endif
673:               /*-----------------------------------------------------------*/
674:               
675:               #if ( INCLUDE_vTaskDelay == 1 )
676:               
677:               	void vTaskDelay( portTickType xTicksToDelay )
678:               	{
0004F6  FA0006     LNK #0x6
0004F8  980720     MOV W0, [W14+4]
679:               	portTickType xTimeToWake;
680:               	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
0004FA  EB0000     CLR W0
0004FC  780F00     MOV W0, [W14]
681:               
682:               		/* A delay time of zero just forces a reschedule. */
683:               		if( xTicksToDelay > ( portTickType ) 0U )
0004FE  90002E     MOV [W14+4], W0
000500  E00000     CP0 W0
000502  32000C     BRA Z, 0x51C
684:               		{
685:               			vTaskSuspendAll();
000504  07014D     RCALL vTaskSuspendAll
686:               			{
687:               				traceTASK_DELAY();
688:               
689:               				/* A task that is removed from the event list while the
690:               				scheduler is suspended will not get placed in the ready
691:               				list or removed from the blocked list until the scheduler
692:               				is resumed.
693:               
694:               				This task cannot be in an event list as it is the currently
695:               				executing task. */
696:               
697:               				/* Calculate the time to wake - this may overflow but this is
698:               				not a problem. */
699:               				xTimeToWake = xTickCount + xTicksToDelay;
000506  80E741     MOV 0x1CE8, W1
000508  90002E     MOV [W14+4], W0
00050A  408000     ADD W1, W0, W0
00050C  980710     MOV W0, [W14+2]
700:               
701:               				/* We must remove ourselves from the ready list before adding
702:               				ourselves to the blocked list as the same list item is used for
703:               				both lists. */
704:               				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
00050E  80E720     MOV 0x1CE4, W0
000510  E88000     INC2 W0, W0
000512  070A79     RCALL vListRemove
705:               				prvAddCurrentTaskToDelayedList( xTimeToWake );
000514  90001E     MOV [W14+2], W0
000516  07031E     RCALL prvAddCurrentTaskToDelayedList
706:               			}
707:               			xAlreadyYielded = xTaskResumeAll();
000518  070149     RCALL xTaskResumeAll
00051A  780F00     MOV W0, [W14]
708:               		}
709:               
710:               		/* Force a reschedule if xTaskResumeAll has not already done so, we may
711:               		have put ourselves to sleep. */
712:               		if( xAlreadyYielded == pdFALSE )
00051C  E0001E     CP0 [W14]
00051E  3A0003     BRA NZ, 0x526
713:               		{
714:               			portYIELD_WITHIN_API();
000520  021C5C     CALL _vPortYield
000522  000000     NOP
000524  000000     NOP
715:               		}
716:               	}
000526  FA8000     ULNK
000528  060000     RETURN
717:               
718:               #endif
719:               /*-----------------------------------------------------------*/
720:               
721:               #if ( INCLUDE_uxTaskPriorityGet == 1 )
722:               
723:               	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
724:               	{
725:               	tskTCB *pxTCB;
726:               	unsigned portBASE_TYPE uxReturn;
727:               
728:               		taskENTER_CRITICAL();
729:               		{
730:               			/* If null is passed in here then we are changing the
731:               			priority of the calling function. */
732:               			pxTCB = prvGetTCBFromHandle( pxTask );
733:               			uxReturn = pxTCB->uxPriority;
734:               		}
735:               		taskEXIT_CRITICAL();
736:               
737:               		return uxReturn;
738:               	}
739:               
740:               #endif
741:               /*-----------------------------------------------------------*/
742:               
743:               #if ( INCLUDE_vTaskPrioritySet == 1 )
744:               
745:               	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
746:               	{
00052A  FA000C     LNK #0xC
00052C  980730     MOV W0, [W14+6]
00052E  980741     MOV W1, [W14+8]
747:               	tskTCB *pxTCB;
748:               	unsigned portBASE_TYPE uxCurrentPriority;
749:               	portBASE_TYPE xYieldRequired = pdFALSE;
000530  EB0000     CLR W0
000532  780F00     MOV W0, [W14]
750:               
751:               		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
752:               
753:               		/* Ensure the new priority is valid. */
754:               		if( uxNewPriority >= configMAX_PRIORITIES )
000534  90004E     MOV [W14+8], W0
000536  500FE3     SUB W0, #0x3, [W15]
000538  360002     BRA LEU, 0x53E
755:               		{
756:               			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
00053A  200030     MOV #0x3, W0
00053C  980740     MOV W0, [W14+8]
757:               		}
758:               
759:               		taskENTER_CRITICAL();
00053E  0709C4     RCALL vPortEnterCritical
760:               		{
761:               			if( pxTask == pxCurrentTCB )
000540  80E721     MOV 0x1CE4, W1
000542  90003E     MOV [W14+6], W0
000544  500F81     SUB W0, W1, [W15]
000546  3A0002     BRA NZ, 0x54C
762:               			{
763:               				pxTask = NULL;
000548  EB0000     CLR W0
00054A  980730     MOV W0, [W14+6]
764:               			}
765:               
766:               			/* If null is passed in here then we are changing the
767:               			priority of the calling function. */
768:               			pxTCB = prvGetTCBFromHandle( pxTask );
00054C  90003E     MOV [W14+6], W0
00054E  E00000     CP0 W0
000550  3A0003     BRA NZ, 0x558
000552  80E720     MOV 0x1CE4, W0
000554  980750     MOV W0, [W14+10]
000556  370002     BRA 0x55C
000558  9000BE     MOV [W14+6], W1
00055A  980751     MOV W1, [W14+10]
00055C  90005E     MOV [W14+10], W0
00055E  980720     MOV W0, [W14+4]
769:               
770:               			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
771:               
772:               			#if ( configUSE_MUTEXES == 1 )
773:               			{
774:               				uxCurrentPriority = pxTCB->uxBasePriority;
000560  90002E     MOV [W14+4], W0
000562  901080     MOV [W0+32], W1
000564  980711     MOV W1, [W14+2]
775:               			}
776:               			#else
777:               			{
778:               				uxCurrentPriority = pxTCB->uxPriority;
779:               			}
780:               			#endif
781:               
782:               			if( uxCurrentPriority != uxNewPriority )
000566  90009E     MOV [W14+2], W1
000568  90004E     MOV [W14+8], W0
00056A  508F80     SUB W1, W0, [W15]
00056C  320043     BRA Z, 0x5F4
783:               			{
784:               				/* The priority change may have readied a task of higher
785:               				priority than the calling task. */
786:               				if( uxNewPriority > uxCurrentPriority )
00056E  9000CE     MOV [W14+8], W1
000570  90001E     MOV [W14+2], W0
000572  508F80     SUB W1, W0, [W15]
000574  360006     BRA LEU, 0x582
787:               				{
788:               					if( pxTask != NULL )
000576  90003E     MOV [W14+6], W0
000578  E00000     CP0 W0
00057A  320008     BRA Z, 0x58C
789:               					{
790:               						/* The priority of another task is being raised.  If we
791:               						were raising the priority of the currently running task
792:               						there would be no need to switch as it must have already
793:               						been the highest priority task. */
794:               						xYieldRequired = pdTRUE;
00057C  200010     MOV #0x1, W0
00057E  780F00     MOV W0, [W14]
000580  370005     BRA 0x58C
795:               					}
796:               				}
797:               				else if( pxTask == NULL )
000582  90003E     MOV [W14+6], W0
000584  E00000     CP0 W0
000586  3A0002     BRA NZ, 0x58C
798:               				{
799:               					/* Setting our own priority down means there may now be another
800:               					task of higher priority that is ready to execute. */
801:               					xYieldRequired = pdTRUE;
000588  200010     MOV #0x1, W0
00058A  780F00     MOV W0, [W14]
802:               				}
803:               
804:               
805:               
806:               				#if ( configUSE_MUTEXES == 1 )
807:               				{
808:               					/* Only change the priority being used if the task is not
809:               					currently using an inherited priority. */
810:               					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
00058C  90002E     MOV [W14+4], W0
00058E  901080     MOV [W0+32], W1
000590  90002E     MOV [W14+4], W0
000592  900830     MOV [W0+22], W0
000594  508F80     SUB W1, W0, [W15]
000596  3A0003     BRA NZ, 0x59E
811:               					{
812:               						pxTCB->uxPriority = uxNewPriority;
000598  90002E     MOV [W14+4], W0
00059A  9000CE     MOV [W14+8], W1
00059C  980831     MOV W1, [W0+22]
813:               					}
814:               
815:               					/* The base priority gets set whatever. */
816:               					pxTCB->uxBasePriority = uxNewPriority;
00059E  90002E     MOV [W14+4], W0
0005A0  9000CE     MOV [W14+8], W1
0005A2  981001     MOV W1, [W0+32]
817:               				}
818:               				#else
819:               				{
820:               					pxTCB->uxPriority = uxNewPriority;
821:               				}
822:               				#endif
823:               
824:               				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
0005A4  90004E     MOV [W14+8], W0
0005A6  1000E4     SUBR W0, #0x4, W1
0005A8  90002E     MOV [W14+4], W0
0005AA  980061     MOV W1, [W0+12]
825:               
826:               				/* If the task is in the blocked or suspended list we need do
827:               				nothing more than change it's priority variable. However, if
828:               				the task is in a ready list it needs to be removed and placed
829:               				in the queue appropriate to its new priority. */
830:               				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
0005AC  90002E     MOV [W14+4], W0
0005AE  900150     MOV [W0+10], W2
0005B0  90001E     MOV [W14+2], W0
0005B2  B9006A     MUL.SU W0, #10, W0
0005B4  780080     MOV W0, W1
0005B6  21C5A0     MOV #0x1C5A, W0
0005B8  408000     ADD W1, W0, W0
0005BA  510F80     SUB W2, W0, [W15]
0005BC  3A0015     BRA NZ, 0x5E8
831:               				{
832:               					/* The task is currently in its ready list - remove before adding
833:               					it to it's new ready list.  As we are in a critical section we
834:               					can do this even if the scheduler is suspended. */
835:               					vListRemove( &( pxTCB->xGenericListItem ) );
0005BE  90002E     MOV [W14+4], W0
0005C0  E88000     INC2 W0, W0
0005C2  070A21     RCALL vListRemove
836:               					prvAddTaskToReadyQueue( pxTCB );
0005C4  90002E     MOV [W14+4], W0
0005C6  9008B0     MOV [W0+22], W1
0005C8  80E760     MOV 0x1CEC, W0
0005CA  508F80     SUB W1, W0, [W15]
0005CC  360003     BRA LEU, 0x5D4
0005CE  90002E     MOV [W14+4], W0
0005D0  900830     MOV [W0+22], W0
0005D2  88E760     MOV W0, 0x1CEC
0005D4  90002E     MOV [W14+4], W0
0005D6  E88100     INC2 W0, W2
0005D8  90002E     MOV [W14+4], W0
0005DA  900830     MOV [W0+22], W0
0005DC  B9006A     MUL.SU W0, #10, W0
0005DE  780080     MOV W0, W1
0005E0  21C5A0     MOV #0x1C5A, W0
0005E2  408000     ADD W1, W0, W0
0005E4  780082     MOV W2, W1
0005E6  0709BD     RCALL vListInsertEnd
837:               				}
838:               
839:               				if( xYieldRequired == pdTRUE )
0005E8  200010     MOV #0x1, W0
0005EA  100F9E     SUBR W0, [W14], [W15]
0005EC  3A0003     BRA NZ, 0x5F4
840:               				{
841:               					portYIELD_WITHIN_API();
0005EE  021C5C     CALL _vPortYield
0005F0  000000     NOP
0005F2  000000     NOP
842:               				}
843:               			}
844:               		}
845:               		taskEXIT_CRITICAL();
0005F4  070973     RCALL vPortExitCritical
846:               	}
0005F6  FA8000     ULNK
0005F8  060000     RETURN
847:               
848:               #endif
849:               /*-----------------------------------------------------------*/
850:               
851:               #if ( INCLUDE_vTaskSuspend == 1 )
852:               
853:               	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
854:               	{
0005FA  FA0006     LNK #0x6
0005FC  980710     MOV W0, [W14+2]
855:               	tskTCB *pxTCB;
856:               
857:               		taskENTER_CRITICAL();
0005FE  070964     RCALL vPortEnterCritical
858:               		{
859:               			/* Ensure a yield is performed if the current task is being
860:               			suspended. */
861:               			if( pxTaskToSuspend == pxCurrentTCB )
000600  80E721     MOV 0x1CE4, W1
000602  90001E     MOV [W14+2], W0
000604  500F81     SUB W0, W1, [W15]
000606  3A0002     BRA NZ, 0x60C
862:               			{
863:               				pxTaskToSuspend = NULL;
000608  EB0000     CLR W0
00060A  980710     MOV W0, [W14+2]
864:               			}
865:               
866:               			/* If null is passed in here then we are suspending ourselves. */
867:               			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
00060C  90001E     MOV [W14+2], W0
00060E  E00000     CP0 W0
000610  3A0003     BRA NZ, 0x618
000612  80E720     MOV 0x1CE4, W0
000614  980720     MOV W0, [W14+4]
000616  370002     BRA 0x61C
000618  90009E     MOV [W14+2], W1
00061A  980721     MOV W1, [W14+4]
00061C  90002E     MOV [W14+4], W0
00061E  780F00     MOV W0, [W14]
868:               
869:               			traceTASK_SUSPEND( pxTCB );
870:               
871:               			/* Remove task from the ready/delayed list and place in the	suspended list. */
872:               			vListRemove( &( pxTCB->xGenericListItem ) );
000620  E8801E     INC2 [W14], W0
000622  0709F1     RCALL vListRemove
873:               
874:               			/* Is the task waiting on an event also? */
875:               			if( pxTCB->xEventListItem.pvContainer != NULL )
000624  78001E     MOV [W14], W0
000626  900820     MOV [W0+20], W0
000628  E00000     CP0 W0
00062A  320003     BRA Z, 0x632
876:               			{
877:               				vListRemove( &( pxTCB->xEventListItem ) );
00062C  78009E     MOV [W14], W1
00062E  40806C     ADD W1, #0xC, W0
000630  0709EA     RCALL vListRemove
878:               			}
879:               
880:               			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
000632  E8809E     INC2 [W14], W1
000634  21CA40     MOV #0x1CA4, W0
000636  070995     RCALL vListInsertEnd
881:               		}
882:               		taskEXIT_CRITICAL();
000638  070951     RCALL vPortExitCritical
883:               
884:               		if( ( void * ) pxTaskToSuspend == NULL )
00063A  90001E     MOV [W14+2], W0
00063C  E00000     CP0 W0
00063E  3A000F     BRA NZ, 0x65E
885:               		{
886:               			if( xSchedulerRunning != pdFALSE )
000640  80E770     MOV 0x1CEE, W0
000642  E00000     CP0 W0
000644  320004     BRA Z, 0x64E
887:               			{
888:               				/* We have just suspended the current task. */
889:               				portYIELD_WITHIN_API();
000646  021C5C     CALL _vPortYield
000648  000000     NOP
00064A  000000     NOP
00064C  370008     BRA 0x65E
890:               			}
891:               			else
892:               			{
893:               				/* The scheduler is not running, but the task that was pointed
894:               				to by pxCurrentTCB has just been suspended and pxCurrentTCB
895:               				must be adjusted to point to a different task. */
896:               				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
00064E  80E521     MOV xSuspendedTaskList, W1
000650  80E730     MOV 0x1CE6, W0
000652  508F80     SUB W1, W0, [W15]
000654  3A0003     BRA NZ, 0x65C
897:               				{
898:               					/* No other tasks are ready, so set pxCurrentTCB back to
899:               					NULL so when the next task is created pxCurrentTCB will
900:               					be set to point to it no matter what its relative priority
901:               					is. */
902:               					pxCurrentTCB = NULL;
000656  EB0000     CLR W0
000658  88E720     MOV W0, 0x1CE4
00065A  370001     BRA 0x65E
903:               				}
904:               				else
905:               				{
906:               					vTaskSwitchContext();
00065C  07016A     RCALL vTaskSwitchContext
907:               				}
908:               			}
909:               		}
910:               	}
00065E  FA8000     ULNK
000660  060000     RETURN
911:               
912:               #endif
913:               /*-----------------------------------------------------------*/
914:               
915:               #if ( INCLUDE_vTaskSuspend == 1 )
916:               
917:               	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
918:               	{
000662  FA0006     LNK #0x6
000664  980720     MOV W0, [W14+4]
919:               	portBASE_TYPE xReturn = pdFALSE;
000666  EB0000     CLR W0
000668  980710     MOV W0, [W14+2]
920:               	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
00066A  90002E     MOV [W14+4], W0
00066C  780F00     MOV W0, [W14]
921:               
922:               		/* It does not make sense to check if the calling task is suspended. */
923:               		configASSERT( xTask );
924:               
925:               		/* Is the task we are attempting to resume actually in the
926:               		suspended list? */
927:               		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
00066E  78001E     MOV [W14], W0
000670  9000D0     MOV [W0+10], W1
000672  21CA40     MOV #0x1CA4, W0
000674  508F80     SUB W1, W0, [W15]
000676  3A000B     BRA NZ, 0x68E
928:               		{
929:               			/* Has the task already been resumed from within an ISR? */
930:               			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
000678  78001E     MOV [W14], W0
00067A  9008A0     MOV [W0+20], W1
00067C  21C9A0     MOV #0x1C9A, W0
00067E  508F80     SUB W1, W0, [W15]
000680  320006     BRA Z, 0x68E
931:               			{
932:               				/* Is it in the suspended list because it is in the
933:               				Suspended state?  It is possible to be in the suspended
934:               				list because it is blocked on a task with no timeout
935:               				specified. */
936:               				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
000682  78001E     MOV [W14], W0
000684  900820     MOV [W0+20], W0
000686  E00000     CP0 W0
000688  3A0002     BRA NZ, 0x68E
937:               				{
938:               					xReturn = pdTRUE;
00068A  200010     MOV #0x1, W0
00068C  980710     MOV W0, [W14+2]
939:               				}
940:               			}
941:               		}
942:               
943:               		return xReturn;
00068E  90001E     MOV [W14+2], W0
944:               	}
000690  FA8000     ULNK
000692  060000     RETURN
945:               
946:               #endif
947:               /*-----------------------------------------------------------*/
948:               
949:               #if ( INCLUDE_vTaskSuspend == 1 )
950:               
951:               	void vTaskResume( xTaskHandle pxTaskToResume )
952:               	{
000694  FA0004     LNK #0x4
000696  980710     MOV W0, [W14+2]
953:               	tskTCB *pxTCB;
954:               
955:               		/* It does not make sense to resume the calling task. */
956:               		configASSERT( pxTaskToResume );
957:               
958:               		/* Remove the task from whichever list it is currently in, and place
959:               		it in the ready list. */
960:               		pxTCB = ( tskTCB * ) pxTaskToResume;
000698  90001E     MOV [W14+2], W0
00069A  780F00     MOV W0, [W14]
961:               
962:               		/* The parameter cannot be NULL as it is impossible to resume the
963:               		currently executing task. */
964:               		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
00069C  E0001E     CP0 [W14]
00069E  320025     BRA Z, 0x6EA
0006A0  80E720     MOV 0x1CE4, W0
0006A2  100F9E     SUBR W0, [W14], [W15]
0006A4  320022     BRA Z, 0x6EA
965:               		{
966:               			taskENTER_CRITICAL();
0006A6  070910     RCALL vPortEnterCritical
967:               			{
968:               				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
0006A8  78001E     MOV [W14], W0
0006AA  07FFDB     RCALL xTaskIsTaskSuspended
0006AC  500FE1     SUB W0, #0x1, [W15]
0006AE  3A001C     BRA NZ, 0x6E8
969:               				{
970:               					traceTASK_RESUME( pxTCB );
971:               
972:               					/* As we are in a critical section we can access the ready
973:               					lists even if the scheduler is suspended. */
974:               					vListRemove(  &( pxTCB->xGenericListItem ) );
0006B0  E8801E     INC2 [W14], W0
0006B2  0709A9     RCALL vListRemove
975:               					prvAddTaskToReadyQueue( pxTCB );
0006B4  78001E     MOV [W14], W0
0006B6  9008B0     MOV [W0+22], W1
0006B8  80E760     MOV 0x1CEC, W0
0006BA  508F80     SUB W1, W0, [W15]
0006BC  360003     BRA LEU, 0x6C4
0006BE  78001E     MOV [W14], W0
0006C0  900830     MOV [W0+22], W0
0006C2  88E760     MOV W0, 0x1CEC
0006C4  E8811E     INC2 [W14], W2
0006C6  78001E     MOV [W14], W0
0006C8  900830     MOV [W0+22], W0
0006CA  B9006A     MUL.SU W0, #10, W0
0006CC  780080     MOV W0, W1
0006CE  21C5A0     MOV #0x1C5A, W0
0006D0  408000     ADD W1, W0, W0
0006D2  780082     MOV W2, W1
0006D4  070946     RCALL vListInsertEnd
976:               
977:               					/* We may have just resumed a higher priority task. */
978:               					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0006D6  78001E     MOV [W14], W0
0006D8  9008B0     MOV [W0+22], W1
0006DA  80E720     MOV 0x1CE4, W0
0006DC  900830     MOV [W0+22], W0
0006DE  508F80     SUB W1, W0, [W15]
0006E0  390003     BRA NC, 0x6E8
979:               					{
980:               						/* This yield may not cause the task just resumed to run, but
981:               						will leave the lists in the correct state for the next yield. */
982:               						portYIELD_WITHIN_API();
0006E2  021C5C     CALL _vPortYield
0006E4  000000     NOP
0006E6  000000     NOP
983:               					}
984:               				}
985:               			}
986:               			taskEXIT_CRITICAL();
0006E8  0708F9     RCALL vPortExitCritical
987:               		}
988:               	}
0006EA  FA8000     ULNK
0006EC  060000     RETURN
989:               
990:               #endif
991:               
992:               /*-----------------------------------------------------------*/
993:               
994:               #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
995:               
996:               	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
997:               	{
0006EE  FA0008     LNK #0x8
0006F0  980730     MOV W0, [W14+6]
998:               	portBASE_TYPE xYieldRequired = pdFALSE;
0006F2  EB0000     CLR W0
0006F4  980720     MOV W0, [W14+4]
999:               	tskTCB *pxTCB;
1000:              	unsigned portBASE_TYPE uxSavedInterruptStatus;
1001:              
1002:              		configASSERT( pxTaskToResume );
1003:              
1004:              		pxTCB = ( tskTCB * ) pxTaskToResume;
0006F6  90003E     MOV [W14+6], W0
0006F8  980710     MOV W0, [W14+2]
1005:              
1006:              		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0006FA  EB0000     CLR W0
0006FC  780F00     MOV W0, [W14]
1007:              		{
1008:              			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
0006FE  90001E     MOV [W14+2], W0
000700  07FFB0     RCALL xTaskIsTaskSuspended
000702  500FE1     SUB W0, #0x1, [W15]
000704  3A0027     BRA NZ, 0x754
1009:              			{
1010:              				traceTASK_RESUME_FROM_ISR( pxTCB );
1011:              
1012:              				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
000706  80E780     MOV 0x1CF0, W0
000708  E00000     CP0 W0
00070A  3A0020     BRA NZ, 0x74C
1013:              				{
1014:              					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
00070C  90001E     MOV [W14+2], W0
00070E  900930     MOV [W0+22], W2
000710  80E720     MOV 0x1CE4, W0
000712  9008B0     MOV [W0+22], W1
000714  EB0000     CLR W0
000716  980720     MOV W0, [W14+4]
000718  510F81     SUB W2, W1, [W15]
00071A  390002     BRA NC, 0x720
00071C  200010     MOV #0x1, W0
00071E  980720     MOV W0, [W14+4]
1015:              					vListRemove(  &( pxTCB->xGenericListItem ) );
000720  90001E     MOV [W14+2], W0
000722  E88000     INC2 W0, W0
000724  070970     RCALL vListRemove
1016:              					prvAddTaskToReadyQueue( pxTCB );
000726  90001E     MOV [W14+2], W0
000728  9008B0     MOV [W0+22], W1
00072A  80E760     MOV 0x1CEC, W0
00072C  508F80     SUB W1, W0, [W15]
00072E  360003     BRA LEU, 0x736
000730  90001E     MOV [W14+2], W0
000732  900830     MOV [W0+22], W0
000734  88E760     MOV W0, 0x1CEC
000736  90001E     MOV [W14+2], W0
000738  E88100     INC2 W0, W2
00073A  90001E     MOV [W14+2], W0
00073C  900830     MOV [W0+22], W0
00073E  B9006A     MUL.SU W0, #10, W0
000740  780080     MOV W0, W1
000742  21C5A0     MOV #0x1C5A, W0
000744  408000     ADD W1, W0, W0
000746  780082     MOV W2, W1
000748  07090C     RCALL vListInsertEnd
00074A  370004     BRA 0x754
1017:              				}
1018:              				else
1019:              				{
1020:              					/* We cannot access the delayed or ready lists, so will hold this
1021:              					task pending until the scheduler is resumed, at which point a
1022:              					yield will be performed if necessary. */
1023:              					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
00074C  90001E     MOV [W14+2], W0
00074E  4000EC     ADD W0, #0xC, W1
000750  21C9A0     MOV #0x1C9A, W0
000752  070907     RCALL vListInsertEnd
1024:              				}
1025:              			}
1026:              		}
1027:              		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1028:              
1029:              		return xYieldRequired;
000754  90002E     MOV [W14+4], W0
1030:              	}
000756  FA8000     ULNK
000758  060000     RETURN
1031:              
1032:              #endif
1033:              
1034:              
1035:              
1036:              
1037:              /*-----------------------------------------------------------
1038:               * PUBLIC SCHEDULER CONTROL documented in task.h
1039:               *----------------------------------------------------------*/
1040:              
1041:              
1042:              void vTaskStartScheduler( void )
1043:              {
00075A  FA0002     LNK #0x2
1044:              portBASE_TYPE xReturn;
1045:              
1046:              	/* Add the idle task at the lowest priority. */
1047:              	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1048:              	{
1049:              		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1050:              		be returned by the xTaskGetIdleTaskHandle() function. */
1051:              		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
1052:              	}
1053:              	#else
1054:              	{
1055:              		/* Create the idle task without storing its handle. */
1056:              		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
00075C  2837E1     MOV #0x837E, W1
00075E  EB0380     CLR W7
000760  EB0300     CLR W6
000762  EB0280     CLR W5
000764  EB0200     CLR W4
000766  EB0180     CLR W3
000768  200732     MOV #0x73, W2
00076A  20AAC0     MOV #0xAAC, W0
00076C  07FE0F     RCALL xTaskGenericCreate
00076E  780F00     MOV W0, [W14]
1057:              	}
1058:              	#endif
1059:              
1060:              	#if ( configUSE_TIMERS == 1 )
1061:              	{
1062:              		if( xReturn == pdPASS )
1063:              		{
1064:              			xReturn = xTimerCreateTimerTask();
1065:              		}
1066:              	}
1067:              	#endif
1068:              
1069:              	if( xReturn == pdPASS )
000770  200010     MOV #0x1, W0
000772  100F9E     SUBR W0, [W14], [W15]
000774  3A0009     BRA NZ, 0x788
1070:              	{
1071:              		/* Interrupts are turned off here, to ensure a tick does not occur
1072:              		before or during the call to xPortStartScheduler().  The stacks of
1073:              		the created tasks contain a status word with interrupts switched on
1074:              		so interrupts will automatically get re-enabled when the first task
1075:              		starts to run.
1076:              
1077:              		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1078:              		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1079:              		portDISABLE_INTERRUPTS();
000776  800211     MOV SR, W1
000778  200E00     MOV #0xE0, W0
00077A  708000     IOR W1, W0, W0
00077C  880210     MOV W0, SR
1080:              
1081:              		xSchedulerRunning = pdTRUE;
00077E  200010     MOV #0x1, W0
000780  88E770     MOV W0, 0x1CEE
1082:              		xTickCount = ( portTickType ) 0U;
000782  EB0000     CLR W0
000784  88E740     MOV W0, 0x1CE8
1083:              
1084:              		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1085:              		macro must be defined to configure the timer/counter used to generate
1086:              		the run time counter time base. */
1087:              		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1088:              		
1089:              		/* Setting up the timer tick is hardware specific and thus in the
1090:              		portable interface. */
1091:              		if( xPortStartScheduler() != pdFALSE )
000786  070870     RCALL xPortStartScheduler
1092:              		{
1093:              			/* Should not reach here as if the scheduler is running the
1094:              			function will not return. */
1095:              		}
1096:              		else
1097:              		{
1098:              			/* Should only reach here if a task calls xTaskEndScheduler(). */
1099:              		}
1100:              	}
1101:              
1102:              	/* This line will only be reached if the kernel could not be started. */
1103:              	configASSERT( xReturn );
1104:              }
000788  FA8000     ULNK
00078A  060000     RETURN
1105:              /*-----------------------------------------------------------*/
1106:              
1107:              void vTaskEndScheduler( void )
1108:              {
00078C  FA0000     LNK #0x0
1109:              	/* Stop the scheduler interrupts and call the portable scheduler end
1110:              	routine so the original ISRs can be restored if necessary.  The port
1111:              	layer must ensure interrupts enable	bit is left in the correct state. */
1112:              	portDISABLE_INTERRUPTS();
00078E  800211     MOV SR, W1
000790  200E00     MOV #0xE0, W0
000792  708000     IOR W1, W0, W0
000794  880210     MOV W0, SR
1113:              	xSchedulerRunning = pdFALSE;
000796  EB0000     CLR W0
000798  88E770     MOV W0, 0x1CEE
1114:              	vPortEndScheduler();
00079A  07087D     RCALL vPortEndScheduler
1115:              }
00079C  FA8000     ULNK
00079E  060000     RETURN
1116:              /*----------------------------------------------------------*/
1117:              
1118:              void vTaskSuspendAll( void )
1119:              {
0007A0  FA0000     LNK #0x0
1120:              	/* A critical section is not required as the variable is of type
1121:              	portBASE_TYPE. */
1122:              	++uxSchedulerSuspended;
0007A2  80E780     MOV 0x1CF0, W0
0007A4  E80000     INC W0, W0
0007A6  88E780     MOV W0, 0x1CF0
1123:              }
0007A8  FA8000     ULNK
0007AA  060000     RETURN
1124:              /*----------------------------------------------------------*/
1125:              
1126:              signed portBASE_TYPE xTaskResumeAll( void )
1127:              {
0007AC  FA0006     LNK #0x6
1128:              register tskTCB *pxTCB;
1129:              signed portBASE_TYPE xAlreadyYielded = pdFALSE;
0007AE  EB0000     CLR W0
0007B0  980710     MOV W0, [W14+2]
1130:              
1131:              	/* If uxSchedulerSuspended is zero then this function does not match a
1132:              	previous call to vTaskSuspendAll(). */
1133:              	configASSERT( uxSchedulerSuspended );
1134:              
1135:              	/* It is possible that an ISR caused a task to be removed from an event
1136:              	list while the scheduler was suspended.  If this was the case then the
1137:              	removed task will have been added to the xPendingReadyList.  Once the
1138:              	scheduler has been resumed it is safe to move all the pending ready
1139:              	tasks from this list into their appropriate ready list. */
1140:              	taskENTER_CRITICAL();
0007B2  07088A     RCALL vPortEnterCritical
1141:              	{
1142:              		--uxSchedulerSuspended;
0007B4  80E780     MOV 0x1CF0, W0
0007B6  E90000     DEC W0, W0
0007B8  88E780     MOV W0, 0x1CF0
1143:              
1144:              		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
0007BA  80E780     MOV 0x1CF0, W0
0007BC  E00000     CP0 W0
0007BE  3A0046     BRA NZ, 0x84C
1145:              		{
1146:              			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
0007C0  80E730     MOV 0x1CE6, W0
0007C2  E00000     CP0 W0
0007C4  320043     BRA Z, 0x84C
1147:              			{
1148:              				portBASE_TYPE xYieldRequired = pdFALSE;
0007C6  EB0000     CLR W0
0007C8  780F00     MOV W0, [W14]
1149:              
1150:              				/* Move any readied tasks from the pending list into the
1151:              				appropriate ready list. */
1152:              				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
0007CA  370023     BRA 0x812
000812  80E4D0     MOV xPendingReadyList, W0
000814  E00000     CP0 W0
000816  3AFFDA     BRA NZ, 0x7CC
1153:              				{
1154:              					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
0007CC  80E500     MOV 0x1CA0, W0
0007CE  900030     MOV [W0+6], W0
0007D0  980720     MOV W0, [W14+4]
1155:              					vListRemove( &( pxTCB->xEventListItem ) );
0007D2  9000AE     MOV [W14+4], W1
0007D4  40806C     ADD W1, #0xC, W0
0007D6  070917     RCALL vListRemove
1156:              					vListRemove( &( pxTCB->xGenericListItem ) );
0007D8  9000AE     MOV [W14+4], W1
0007DA  E88001     INC2 W1, W0
0007DC  070914     RCALL vListRemove
1157:              					prvAddTaskToReadyQueue( pxTCB );
0007DE  90002E     MOV [W14+4], W0
0007E0  9008B0     MOV [W0+22], W1
0007E2  80E760     MOV 0x1CEC, W0
0007E4  508F80     SUB W1, W0, [W15]
0007E6  360003     BRA LEU, 0x7EE
0007E8  9000AE     MOV [W14+4], W1
0007EA  900831     MOV [W1+22], W0
0007EC  88E760     MOV W0, 0x1CEC
0007EE  90002E     MOV [W14+4], W0
0007F0  E88100     INC2 W0, W2
0007F2  9000AE     MOV [W14+4], W1
0007F4  900831     MOV [W1+22], W0
0007F6  B9006A     MUL.SU W0, #10, W0
0007F8  780080     MOV W0, W1
0007FA  21C5A0     MOV #0x1C5A, W0
0007FC  408000     ADD W1, W0, W0
0007FE  780082     MOV W2, W1
000800  0708B0     RCALL vListInsertEnd
1158:              
1159:              					/* If we have moved a task that has a priority higher than
1160:              					the current task then we should yield. */
1161:              					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000802  90002E     MOV [W14+4], W0
000804  9008B0     MOV [W0+22], W1
000806  80E720     MOV 0x1CE4, W0
000808  900830     MOV [W0+22], W0
00080A  508F80     SUB W1, W0, [W15]
00080C  390002     BRA NC, 0x812
1162:              					{
1163:              						xYieldRequired = pdTRUE;
00080E  200010     MOV #0x1, W0
000810  780F00     MOV W0, [W14]
1164:              					}
1165:              				}
1166:              
1167:              				/* If any ticks occurred while the scheduler was suspended then
1168:              				they should be processed now.  This ensures the tick count does not
1169:              				slip, and that any delayed tasks are resumed at the correct time. */
1170:              				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
000818  80E790     MOV 0x1CF2, W0
00081A  E00000     CP0 W0
00081C  32000A     BRA Z, 0x832
1171:              				{
1172:              					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
00081E  370004     BRA 0x828
000828  80E790     MOV 0x1CF2, W0
00082A  E00000     CP0 W0
00082C  3AFFF9     BRA NZ, 0x820
1173:              					{
1174:              						vTaskIncrementTick();
000820  07002D     RCALL vTaskIncrementTick
1175:              						--uxMissedTicks;
000822  80E790     MOV 0x1CF2, W0
000824  E90000     DEC W0, W0
000826  88E790     MOV W0, 0x1CF2
1176:              					}
1177:              
1178:              					/* As we have processed some ticks it is appropriate to yield
1179:              					to ensure the highest priority task that is ready to run is
1180:              					the task actually running. */
1181:              					#if configUSE_PREEMPTION == 1
1182:              					{
1183:              						xYieldRequired = pdTRUE;
00082E  200010     MOV #0x1, W0
000830  780F00     MOV W0, [W14]
1184:              					}
1185:              					#endif
1186:              				}
1187:              
1188:              				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
000832  200011     MOV #0x1, W1
000834  108F9E     SUBR W1, [W14], [W15]
000836  320003     BRA Z, 0x83E
000838  80E7A0     MOV 0x1CF4, W0
00083A  500FE1     SUB W0, #0x1, [W15]
00083C  3A0007     BRA NZ, 0x84C
1189:              				{
1190:              					xAlreadyYielded = pdTRUE;
00083E  200010     MOV #0x1, W0
000840  980710     MOV W0, [W14+2]
1191:              					xMissedYield = pdFALSE;
000842  EB0000     CLR W0
000844  88E7A0     MOV W0, 0x1CF4
1192:              					portYIELD_WITHIN_API();
000846  021C5C     CALL _vPortYield
000848  000000     NOP
00084A  000000     NOP
1193:              				}
1194:              			}
1195:              		}
1196:              	}
1197:              	taskEXIT_CRITICAL();
00084C  070847     RCALL vPortExitCritical
1198:              
1199:              	return xAlreadyYielded;
00084E  90001E     MOV [W14+2], W0
1200:              }
000850  FA8000     ULNK
000852  060000     RETURN
1201:              
1202:              
1203:              
1204:              
1205:              
1206:              
1207:              /*-----------------------------------------------------------
1208:               * PUBLIC TASK UTILITIES documented in task.h
1209:               *----------------------------------------------------------*/
1210:              
1211:              
1212:              
1213:              portTickType xTaskGetTickCount( void )
1214:              {
000854  FA0002     LNK #0x2
1215:              portTickType xTicks;
1216:              
1217:              	/* Critical section required if running on a 16 bit processor. */
1218:              	taskENTER_CRITICAL();
000856  070838     RCALL vPortEnterCritical
1219:              	{
1220:              		xTicks = xTickCount;
000858  80E740     MOV 0x1CE8, W0
00085A  780F00     MOV W0, [W14]
1221:              	}
1222:              	taskEXIT_CRITICAL();
00085C  07083F     RCALL vPortExitCritical
1223:              
1224:              	return xTicks;
00085E  78001E     MOV [W14], W0
1225:              }
000860  FA8000     ULNK
000862  060000     RETURN
1226:              /*-----------------------------------------------------------*/
1227:              
1228:              portTickType xTaskGetTickCountFromISR( void )
1229:              {
000864  FA0004     LNK #0x4
1230:              portTickType xReturn;
1231:              unsigned portBASE_TYPE uxSavedInterruptStatus;
1232:              
1233:              	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000866  EB0000     CLR W0
000868  780F00     MOV W0, [W14]
1234:              	xReturn = xTickCount;
00086A  80E740     MOV 0x1CE8, W0
00086C  980710     MOV W0, [W14+2]
1235:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1236:              
1237:              	return xReturn;
00086E  90001E     MOV [W14+2], W0
1238:              }
000870  FA8000     ULNK
000872  060000     RETURN
1239:              /*-----------------------------------------------------------*/
1240:              
1241:              unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1242:              {
000874  FA0000     LNK #0x0
1243:              	/* A critical section is not required because the variables are of type
1244:              	portBASE_TYPE. */
1245:              	return uxCurrentNumberOfTasks;
000876  80E730     MOV 0x1CE6, W0
1246:              }
000878  FA8000     ULNK
00087A  060000     RETURN
1247:              /*-----------------------------------------------------------*/
1248:              
1249:              #if ( INCLUDE_pcTaskGetTaskName == 1 )
1250:              
1251:              	signed char *pcTaskGetTaskName( xTaskHandle xTaskToQuery )
1252:              	{
1253:              	tskTCB *pxTCB;
1254:              
1255:              		/* If null is passed in here then the name of the calling task is being queried. */
1256:              		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
1257:              		configASSERT( pxTCB );
1258:              		return &( pxTCB->pcTaskName[ 0 ] );
1259:              	}
1260:              
1261:              #endif
1262:              /*-----------------------------------------------------------*/
1263:              
1264:              #if ( configUSE_TRACE_FACILITY == 1 )
1265:              
1266:              	void vTaskList( signed char *pcWriteBuffer )
1267:              	{
1268:              	unsigned portBASE_TYPE uxQueue;
1269:              
1270:              		/* This is a VERY costly function that should be used for debug only.
1271:              		It leaves interrupts disabled for a LONG time. */
1272:              
1273:              		vTaskSuspendAll();
1274:              		{
1275:              			/* Run through all the lists that could potentially contain a TCB and
1276:              			report the task name, state and stack high water mark. */
1277:              
1278:              			*pcWriteBuffer = ( signed char ) 0x00;
1279:              			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1280:              
1281:              			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1282:              
1283:              			do
1284:              			{
1285:              				uxQueue--;
1286:              
1287:              				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1288:              				{
1289:              					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tskREADY_CHAR );
1290:              				}
1291:              			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1292:              
1293:              			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1294:              			{
1295:              				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1296:              			}
1297:              
1298:              			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1299:              			{
1300:              				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_CHAR );
1301:              			}
1302:              
1303:              			#if( INCLUDE_vTaskDelete == 1 )
1304:              			{
1305:              				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1306:              				{
1307:              					prvListTaskWithinSingleList( pcWriteBuffer, &xTasksWaitingTermination, tskDELETED_CHAR );
1308:              				}
1309:              			}
1310:              			#endif
1311:              
1312:              			#if ( INCLUDE_vTaskSuspend == 1 )
1313:              			{
1314:              				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1315:              				{
1316:              					prvListTaskWithinSingleList( pcWriteBuffer, &xSuspendedTaskList, tskSUSPENDED_CHAR );
1317:              				}
1318:              			}
1319:              			#endif
1320:              		}
1321:              		xTaskResumeAll();
1322:              	}
1323:              
1324:              #endif
1325:              /*----------------------------------------------------------*/
1326:              
1327:              #if ( configGENERATE_RUN_TIME_STATS == 1 )
1328:              
1329:              	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1330:              	{
1331:              	unsigned portBASE_TYPE uxQueue;
1332:              	unsigned long ulTotalRunTime;
1333:              
1334:              		/* This is a VERY costly function that should be used for debug only.
1335:              		It leaves interrupts disabled for a LONG time. */
1336:              
1337:              		vTaskSuspendAll();
1338:              		{
1339:              			#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1340:              				portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
1341:              			#else
1342:              				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1343:              			#endif
1344:              
1345:              			/* Divide ulTotalRunTime by 100 to make the percentage caluclations
1346:              			simpler in the prvGenerateRunTimeStatsForTasksInList() function. */
1347:              			ulTotalRunTime /= 100UL;
1348:              			
1349:              			/* Run through all the lists that could potentially contain a TCB,
1350:              			generating a table of run timer percentages in the provided
1351:              			buffer. */
1352:              
1353:              			*pcWriteBuffer = ( signed char ) 0x00;
1354:              			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1355:              
1356:              			uxQueue = uxTopUsedPriority + ( unsigned portBASE_TYPE ) 1U;
1357:              
1358:              			do
1359:              			{
1360:              				uxQueue--;
1361:              
1362:              				if( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) == pdFALSE )
1363:              				{
1364:              					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), ulTotalRunTime );
1365:              				}
1366:              			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1367:              
1368:              			if( listLIST_IS_EMPTY( pxDelayedTaskList ) == pdFALSE )
1369:              			{
1370:              				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRunTime );
1371:              			}
1372:              
1373:              			if( listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) == pdFALSE )
1374:              			{
1375:              				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ulTotalRunTime );
1376:              			}
1377:              
1378:              			#if ( INCLUDE_vTaskDelete == 1 )
1379:              			{
1380:              				if( listLIST_IS_EMPTY( &xTasksWaitingTermination ) == pdFALSE )
1381:              				{
1382:              					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xTasksWaitingTermination, ulTotalRunTime );
1383:              				}
1384:              			}
1385:              			#endif
1386:              
1387:              			#if ( INCLUDE_vTaskSuspend == 1 )
1388:              			{
1389:              				if( listLIST_IS_EMPTY( &xSuspendedTaskList ) == pdFALSE )
1390:              				{
1391:              					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, &xSuspendedTaskList, ulTotalRunTime );
1392:              				}
1393:              			}
1394:              			#endif
1395:              		}
1396:              		xTaskResumeAll();
1397:              	}
1398:              
1399:              #endif
1400:              /*----------------------------------------------------------*/
1401:              
1402:              #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1403:              
1404:              	xTaskHandle xTaskGetIdleTaskHandle( void )
1405:              	{
1406:              		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1407:              		started, then xIdleTaskHandle will be NULL. */
1408:              		configASSERT( ( xIdleTaskHandle != NULL ) );
1409:              		return xIdleTaskHandle;
1410:              	}
1411:              	
1412:              #endif
1413:              
1414:              /*-----------------------------------------------------------
1415:               * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1416:               * documented in task.h
1417:               *----------------------------------------------------------*/
1418:              
1419:              void vTaskIncrementTick( void )
1420:              {
00087C  FA0006     LNK #0x6
1421:              tskTCB * pxTCB;
1422:              
1423:              	/* Called by the portable layer each time a tick interrupt occurs.
1424:              	Increments the tick then checks to see if the new tick value will cause any
1425:              	tasks to be unblocked. */
1426:              	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
00087E  80E780     MOV 0x1CF0, W0
000880  E00000     CP0 W0
000882  3A0052     BRA NZ, 0x928
1427:              	{
1428:              		++xTickCount;
000884  80E740     MOV 0x1CE8, W0
000886  E80000     INC W0, W0
000888  88E740     MOV W0, 0x1CE8
1429:              		if( xTickCount == ( portTickType ) 0U )
00088A  80E740     MOV 0x1CE8, W0
00088C  E00000     CP0 W0
00088E  3A0017     BRA NZ, 0x8BE
1430:              		{
1431:              			xList *pxTemp;
1432:              
1433:              			/* Tick count has overflowed so we need to swap the delay lists.
1434:              			If there are any items in pxDelayedTaskList here then there is
1435:              			an error! */
1436:              			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
1437:              			
1438:              			pxTemp = pxDelayedTaskList;
000890  80E4B0     MOV pxDelayedTaskList, W0
000892  980710     MOV W0, [W14+2]
1439:              			pxDelayedTaskList = pxOverflowDelayedTaskList;
000894  80E4C0     MOV pxOverflowDelayedTaskList, W0
000896  88E4B0     MOV W0, pxDelayedTaskList
1440:              			pxOverflowDelayedTaskList = pxTemp;
000898  90009E     MOV [W14+2], W1
00089A  88E4C1     MOV W1, pxOverflowDelayedTaskList
1441:              			xNumOfOverflows++;
00089C  80E7B0     MOV 0x1CF6, W0
00089E  E80000     INC W0, W0
0008A0  88E7B0     MOV W0, 0x1CF6
1442:              	
1443:              			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
0008A2  80E4B0     MOV pxDelayedTaskList, W0
0008A4  780010     MOV [W0], W0
0008A6  E00000     CP0 W0
0008A8  3A0003     BRA NZ, 0x8B0
1444:              			{
1445:              				/* The new current delayed list is empty.  Set
1446:              				xNextTaskUnblockTime to the maximum possible value so it is
1447:              				extremely unlikely that the	
1448:              				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
1449:              				there is an item in the delayed list. */
1450:              				xNextTaskUnblockTime = portMAX_DELAY;
0008AA  EB8000     SETM W0
0008AC  88E7D0     MOV W0, 0x1CFA
0008AE  370007     BRA 0x8BE
1451:              			}
1452:              			else
1453:              			{
1454:              				/* The new current delayed list is not empty, get the value of
1455:              				the item at the head of the delayed list.  This is the time at
1456:              				which the task at the head of the delayed list should be removed
1457:              				from the Blocked state. */
1458:              				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
0008B0  80E4B0     MOV pxDelayedTaskList, W0
0008B2  900030     MOV [W0+6], W0
0008B4  900030     MOV [W0+6], W0
0008B6  980720     MOV W0, [W14+4]
1459:              				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
0008B8  90002E     MOV [W14+4], W0
0008BA  900010     MOV [W0+2], W0
0008BC  88E7D0     MOV W0, 0x1CFA
1460:              			}
1461:              		}
1462:              
1463:              		/* See if this tick has made a timeout expire. */
1464:              		prvCheckDelayedTasks();
0008BE  80E741     MOV 0x1CE8, W1
0008C0  80E7D0     MOV 0x1CFA, W0
0008C2  508F80     SUB W1, W0, [W15]
0008C4  390034     BRA NC, 0x92E
0008C6  80E4B0     MOV pxDelayedTaskList, W0
0008C8  780010     MOV [W0], W0
0008CA  E00000     CP0 W0
0008CC  3A0003     BRA NZ, 0x8D4
0008CE  EB8000     SETM W0
0008D0  88E7D0     MOV W0, 0x1CFA
0008D2  37002D     BRA 0x92E
0008D4  80E4B0     MOV pxDelayedTaskList, W0
0008D6  900030     MOV [W0+6], W0
0008D8  900030     MOV [W0+6], W0
0008DA  980720     MOV W0, [W14+4]
0008DC  90002E     MOV [W14+4], W0
0008DE  900090     MOV [W0+2], W1
0008E0  780F01     MOV W1, [W14]
0008E2  80E740     MOV 0x1CE8, W0
0008E4  500F9E     SUB W0, [W14], [W15]
0008E6  310003     BRA C, 0x8EE
0008E8  78001E     MOV [W14], W0
0008EA  88E7D0     MOV W0, 0x1CFA
0008EC  370020     BRA 0x92E
0008EE  90002E     MOV [W14+4], W0
0008F0  E88000     INC2 W0, W0
0008F2  070889     RCALL vListRemove
0008F4  90002E     MOV [W14+4], W0
0008F6  900820     MOV [W0+20], W0
0008F8  E00000     CP0 W0
0008FA  320003     BRA Z, 0x902
0008FC  90002E     MOV [W14+4], W0
0008FE  40006C     ADD W0, #0xC, W0
000900  070882     RCALL vListRemove
000902  90002E     MOV [W14+4], W0
000904  9008B0     MOV [W0+22], W1
000906  80E760     MOV 0x1CEC, W0
000908  508F80     SUB W1, W0, [W15]
00090A  360003     BRA LEU, 0x912
00090C  90002E     MOV [W14+4], W0
00090E  900830     MOV [W0+22], W0
000910  88E760     MOV W0, 0x1CEC
000912  90002E     MOV [W14+4], W0
000914  E88100     INC2 W0, W2
000916  90002E     MOV [W14+4], W0
000918  900830     MOV [W0+22], W0
00091A  B9006A     MUL.SU W0, #10, W0
00091C  780080     MOV W0, W1
00091E  21C5A0     MOV #0x1C5A, W0
000920  408000     ADD W1, W0, W0
000922  780082     MOV W2, W1
000924  07081E     RCALL vListInsertEnd
000926  37FFCF     BRA 0x8C6
1465:              	}
1466:              	else
1467:              	{
1468:              		++uxMissedTicks;
000928  80E790     MOV 0x1CF2, W0
00092A  E80000     INC W0, W0
00092C  88E790     MOV W0, 0x1CF2
1469:              
1470:              		/* The tick hook gets called at regular intervals, even if the
1471:              		scheduler is locked. */
1472:              		#if ( configUSE_TICK_HOOK == 1 )
1473:              		{
1474:              			vApplicationTickHook();
1475:              		}
1476:              		#endif
1477:              	}
1478:              
1479:              	#if ( configUSE_TICK_HOOK == 1 )
1480:              	{
1481:              		/* Guard against the tick hook being called when the missed tick
1482:              		count is being unwound (when the scheduler is being unlocked. */
1483:              		if( uxMissedTicks == ( unsigned portBASE_TYPE ) 0U )
1484:              		{
1485:              			vApplicationTickHook();
1486:              		}
1487:              	}
1488:              	#endif
1489:              
1490:              	traceTASK_INCREMENT_TICK( xTickCount );
1491:              }
00092E  FA8000     ULNK
000930  060000     RETURN
1492:              /*-----------------------------------------------------------*/
1493:              
1494:              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1495:              
1496:              	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction )
1497:              	{
1498:              	tskTCB *xTCB;
1499:              
1500:              		/* If xTask is NULL then we are setting our own task hook. */
1501:              		if( xTask == NULL )
1502:              		{
1503:              			xTCB = ( tskTCB * ) pxCurrentTCB;
1504:              		}
1505:              		else
1506:              		{
1507:              			xTCB = ( tskTCB * ) xTask;
1508:              		}
1509:              
1510:              		/* Save the hook function in the TCB.  A critical section is required as
1511:              		the value can be accessed from an interrupt. */
1512:              		taskENTER_CRITICAL();
1513:              			xTCB->pxTaskTag = pxHookFunction;
1514:              		taskEXIT_CRITICAL();
1515:              	}
1516:              
1517:              #endif
1518:              /*-----------------------------------------------------------*/
1519:              
1520:              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1521:              
1522:              	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1523:              	{
1524:              	tskTCB *xTCB;
1525:              	pdTASK_HOOK_CODE xReturn;
1526:              
1527:              		/* If xTask is NULL then we are setting our own task hook. */
1528:              		if( xTask == NULL )
1529:              		{
1530:              			xTCB = ( tskTCB * ) pxCurrentTCB;
1531:              		}
1532:              		else
1533:              		{
1534:              			xTCB = ( tskTCB * ) xTask;
1535:              		}
1536:              
1537:              		/* Save the hook function in the TCB.  A critical section is required as
1538:              		the value can be accessed from an interrupt. */
1539:              		taskENTER_CRITICAL();
1540:              			xReturn = xTCB->pxTaskTag;
1541:              		taskEXIT_CRITICAL();
1542:              
1543:              		return xReturn;
1544:              	}
1545:              
1546:              #endif
1547:              /*-----------------------------------------------------------*/
1548:              
1549:              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1550:              
1551:              	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1552:              	{
1553:              	tskTCB *xTCB;
1554:              	portBASE_TYPE xReturn;
1555:              
1556:              		/* If xTask is NULL then we are calling our own task hook. */
1557:              		if( xTask == NULL )
1558:              		{
1559:              			xTCB = ( tskTCB * ) pxCurrentTCB;
1560:              		}
1561:              		else
1562:              		{
1563:              			xTCB = ( tskTCB * ) xTask;
1564:              		}
1565:              
1566:              		if( xTCB->pxTaskTag != NULL )
1567:              		{
1568:              			xReturn = xTCB->pxTaskTag( pvParameter );
1569:              		}
1570:              		else
1571:              		{
1572:              			xReturn = pdFAIL;
1573:              		}
1574:              
1575:              		return xReturn;
1576:              	}
1577:              
1578:              #endif
1579:              /*-----------------------------------------------------------*/
1580:              
1581:              void vTaskSwitchContext( void )
1582:              {
000932  FA0002     LNK #0x2
1583:              	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
000934  80E780     MOV 0x1CF0, W0
000936  E00000     CP0 W0
000938  320006     BRA Z, 0x946
1584:              	{
1585:              		/* The scheduler is currently suspended - do not allow a context
1586:              		switch. */
1587:              		xMissedYield = pdTRUE;
00093A  200010     MOV #0x1, W0
00093C  88E7A0     MOV W0, 0x1CF4
00093E  370024     BRA 0x988
1588:              	}
1589:              	else
1590:              	{
1591:              		traceTASK_SWITCHED_OUT();
1592:              	
1593:              		#if ( configGENERATE_RUN_TIME_STATS == 1 )
1594:              		{
1595:              			unsigned long ulTempCounter;
1596:              			
1597:              				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1598:              					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTempCounter );
1599:              				#else
1600:              					ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1601:              				#endif
1602:              	
1603:              				/* Add the amount of time the task has been running to the accumulated
1604:              				time so far.  The time the task started running was stored in
1605:              				ulTaskSwitchedInTime.  Note that there is no overflow protection here
1606:              				so count values are only valid until the timer overflows.  Generally
1607:              				this will be about 1 hour assuming a 1uS timer increment. */
1608:              				pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1609:              				ulTaskSwitchedInTime = ulTempCounter;
1610:              		}
1611:              		#endif
1612:              	
1613:              		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1614:              		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1615:              	
1616:              		/* Find the highest priority queue that contains ready tasks. */
1617:              		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
000946  80E760     MOV 0x1CEC, W0
000948  B9006A     MUL.SU W0, #10, W0
00094A  780080     MOV W0, W1
00094C  21C5A0     MOV #0x1C5A, W0
00094E  408000     ADD W1, W0, W0
000950  780010     MOV [W0], W0
000952  E00000     CP0 W0
000954  32FFF5     BRA Z, 0x940
1618:              		{
1619:              			configASSERT( uxTopReadyPriority );
1620:              			--uxTopReadyPriority;
000940  80E760     MOV 0x1CEC, W0
000942  E90000     DEC W0, W0
000944  88E760     MOV W0, 0x1CEC
1621:              		}
1622:              	
1623:              		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1624:              		same priority get an equal share of the processor time. */
1625:              		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
000956  80E760     MOV 0x1CEC, W0
000958  B9006A     MUL.SU W0, #10, W0
00095A  780080     MOV W0, W1
00095C  21C5A0     MOV #0x1C5A, W0
00095E  408F00     ADD W1, W0, [W14]
000960  78001E     MOV [W14], W0
000962  900010     MOV [W0+2], W0
000964  900090     MOV [W0+2], W1
000966  78001E     MOV [W14], W0
000968  980011     MOV W1, [W0+2]
00096A  78001E     MOV [W14], W0
00096C  900090     MOV [W0+2], W1
00096E  78011E     MOV [W14], W2
000970  410064     ADD W2, #0x4, W0
000972  508F80     SUB W1, W0, [W15]
000974  3A0005     BRA NZ, 0x980
000976  78001E     MOV [W14], W0
000978  900010     MOV [W0+2], W0
00097A  900090     MOV [W0+2], W1
00097C  78001E     MOV [W14], W0
00097E  980011     MOV W1, [W0+2]
000980  78001E     MOV [W14], W0
000982  900010     MOV [W0+2], W0
000984  900030     MOV [W0+6], W0
000986  88E720     MOV W0, 0x1CE4
1626:              	
1627:              		traceTASK_SWITCHED_IN();
1628:              	}
1629:              }
000988  FA8000     ULNK
00098A  060000     RETURN
1630:              /*-----------------------------------------------------------*/
1631:              
1632:              void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1633:              {
00098C  FA0006     LNK #0x6
00098E  980710     MOV W0, [W14+2]
000990  980721     MOV W1, [W14+4]
1634:              portTickType xTimeToWake;
1635:              
1636:              	configASSERT( pxEventList );
1637:              
1638:              	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1639:              	SCHEDULER SUSPENDED. */
1640:              
1641:              	/* Place the event list item of the TCB in the appropriate event list.
1642:              	This is placed in the list in priority order so the highest priority task
1643:              	is the first to be woken by the event. */
1644:              	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
000992  80E720     MOV 0x1CE4, W0
000994  4000EC     ADD W0, #0xC, W1
000996  90001E     MOV [W14+2], W0
000998  070806     RCALL vListInsert
1645:              
1646:              	/* We must remove ourselves from the ready list before adding ourselves
1647:              	to the blocked list as the same list item is used for both lists.  We have
1648:              	exclusive access to the ready lists as the scheduler is locked. */
1649:              	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
00099A  80E720     MOV 0x1CE4, W0
00099C  E88000     INC2 W0, W0
00099E  070833     RCALL vListRemove
1650:              
1651:              
1652:              	#if ( INCLUDE_vTaskSuspend == 1 )
1653:              	{
1654:              		if( xTicksToWait == portMAX_DELAY )
0009A0  90002E     MOV [W14+4], W0
0009A2  400FE1     ADD W0, #0x1, [W15]
0009A4  3A0005     BRA NZ, 0x9B0
1655:              		{
1656:              			/* Add ourselves to the suspended task list instead of a delayed task
1657:              			list to ensure we are not woken by a timing event.  We will block
1658:              			indefinitely. */
1659:              			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
0009A6  80E720     MOV 0x1CE4, W0
0009A8  E88080     INC2 W0, W1
0009AA  21CA40     MOV #0x1CA4, W0
0009AC  0707DA     RCALL vListInsertEnd
0009AE  370005     BRA 0x9BA
1660:              		}
1661:              		else
1662:              		{
1663:              			/* Calculate the time at which the task should be woken if the event does
1664:              			not occur.  This may overflow but this doesn't matter. */
1665:              			xTimeToWake = xTickCount + xTicksToWait;
0009B0  80E741     MOV 0x1CE8, W1
0009B2  90002E     MOV [W14+4], W0
0009B4  408F00     ADD W1, W0, [W14]
1666:              			prvAddCurrentTaskToDelayedList( xTimeToWake );
0009B6  78001E     MOV [W14], W0
0009B8  0700CD     RCALL prvAddCurrentTaskToDelayedList
1667:              		}
1668:              	}
1669:              	#else
1670:              	{
1671:              			/* Calculate the time at which the task should be woken if the event does
1672:              			not occur.  This may overflow but this doesn't matter. */
1673:              			xTimeToWake = xTickCount + xTicksToWait;
1674:              			prvAddCurrentTaskToDelayedList( xTimeToWake );
1675:              	}
1676:              	#endif
1677:              }
0009BA  FA8000     ULNK
0009BC  060000     RETURN
1678:              /*-----------------------------------------------------------*/
1679:              
1680:              #if configUSE_TIMERS == 1
1681:              
1682:              	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
1683:              	{
1684:              	portTickType xTimeToWake;
1685:              
1686:              		configASSERT( pxEventList );
1687:              
1688:              		/* This function should not be called by application code hence the
1689:              		'Restricted' in its name.  It is not part of the public API.  It is
1690:              		designed for use by kernel code, and has special calling requirements -
1691:              		it should be called from a critical section. */
1692:              
1693:              	
1694:              		/* Place the event list item of the TCB in the appropriate event list.
1695:              		In this case it is assume that this is the only task that is going to
1696:              		be waiting on this event list, so the faster vListInsertEnd() function
1697:              		can be used in place of vListInsert. */
1698:              		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
1699:              
1700:              		/* We must remove this task from the ready list before adding it to the
1701:              		blocked list as the same list item is used for both lists.  This
1702:              		function is called form a critical section. */
1703:              		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
1704:              
1705:              		/* Calculate the time at which the task should be woken if the event does
1706:              		not occur.  This may overflow but this doesn't matter. */
1707:              		xTimeToWake = xTickCount + xTicksToWait;
1708:              		prvAddCurrentTaskToDelayedList( xTimeToWake );
1709:              	}
1710:              	
1711:              #endif /* configUSE_TIMERS */
1712:              /*-----------------------------------------------------------*/
1713:              
1714:              signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1715:              {
0009BE  FA0006     LNK #0x6
0009C0  980720     MOV W0, [W14+4]
1716:              tskTCB *pxUnblockedTCB;
1717:              portBASE_TYPE xReturn;
1718:              
1719:              	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1720:              	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1721:              
1722:              	/* The event list is sorted in priority order, so we can remove the
1723:              	first in the list, remove the TCB from the delayed list, and add
1724:              	it to the ready list.
1725:              
1726:              	If an event is for a queue that is locked then this function will never
1727:              	get called - the lock count on the queue will get modified instead.  This
1728:              	means we can always expect exclusive access to the event list here.
1729:              	
1730:              	This function assumes that a check has already been made to ensure that
1731:              	pxEventList is not empty. */
1732:              	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
0009C2  90002E     MOV [W14+4], W0
0009C4  900030     MOV [W0+6], W0
0009C6  900030     MOV [W0+6], W0
0009C8  980710     MOV W0, [W14+2]
1733:              	configASSERT( pxUnblockedTCB );
1734:              	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
0009CA  90001E     MOV [W14+2], W0
0009CC  40006C     ADD W0, #0xC, W0
0009CE  07081B     RCALL vListRemove
1735:              
1736:              	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
0009D0  80E780     MOV 0x1CF0, W0
0009D2  E00000     CP0 W0
0009D4  3A0016     BRA NZ, 0xA02
1737:              	{
1738:              		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
0009D6  90001E     MOV [W14+2], W0
0009D8  E88000     INC2 W0, W0
0009DA  070815     RCALL vListRemove
1739:              		prvAddTaskToReadyQueue( pxUnblockedTCB );
0009DC  90001E     MOV [W14+2], W0
0009DE  9008B0     MOV [W0+22], W1
0009E0  80E760     MOV 0x1CEC, W0
0009E2  508F80     SUB W1, W0, [W15]
0009E4  360003     BRA LEU, 0x9EC
0009E6  90001E     MOV [W14+2], W0
0009E8  900830     MOV [W0+22], W0
0009EA  88E760     MOV W0, 0x1CEC
0009EC  90001E     MOV [W14+2], W0
0009EE  E88100     INC2 W0, W2
0009F0  90001E     MOV [W14+2], W0
0009F2  900830     MOV [W0+22], W0
0009F4  B9006A     MUL.SU W0, #10, W0
0009F6  780080     MOV W0, W1
0009F8  21C5A0     MOV #0x1C5A, W0
0009FA  408000     ADD W1, W0, W0
0009FC  780082     MOV W2, W1
0009FE  0707B1     RCALL vListInsertEnd
000A00  370004     BRA 0xA0A
1740:              	}
1741:              	else
1742:              	{
1743:              		/* We cannot access the delayed or ready lists, so will hold this
1744:              		task pending until the scheduler is resumed. */
1745:              		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
000A02  90001E     MOV [W14+2], W0
000A04  4000EC     ADD W0, #0xC, W1
000A06  21C9A0     MOV #0x1C9A, W0
000A08  0707AC     RCALL vListInsertEnd
1746:              	}
1747:              
1748:              	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
000A0A  90001E     MOV [W14+2], W0
000A0C  9008B0     MOV [W0+22], W1
000A0E  80E720     MOV 0x1CE4, W0
000A10  900830     MOV [W0+22], W0
000A12  508F80     SUB W1, W0, [W15]
000A14  390003     BRA NC, 0xA1C
1749:              	{
1750:              		/* Return true if the task removed from the event list has
1751:              		a higher priority than the calling task.  This allows
1752:              		the calling task to know if it should force a context
1753:              		switch now. */
1754:              		xReturn = pdTRUE;
000A16  200010     MOV #0x1, W0
000A18  780F00     MOV W0, [W14]
000A1A  370002     BRA 0xA20
1755:              	}
1756:              	else
1757:              	{
1758:              		xReturn = pdFALSE;
000A1C  EB0000     CLR W0
000A1E  780F00     MOV W0, [W14]
1759:              	}
1760:              
1761:              	return xReturn;
000A20  78001E     MOV [W14], W0
1762:              }
000A22  FA8000     ULNK
000A24  060000     RETURN
1763:              /*-----------------------------------------------------------*/
1764:              
1765:              void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1766:              {
000A26  FA0002     LNK #0x2
000A28  780F00     MOV W0, [W14]
1767:              	configASSERT( pxTimeOut );
1768:              	pxTimeOut->xOverflowCount = xNumOfOverflows;
000A2A  80E7B1     MOV 0x1CF6, W1
000A2C  78001E     MOV [W14], W0
000A2E  780801     MOV W1, [W0]
1769:              	pxTimeOut->xTimeOnEntering = xTickCount;
000A30  80E741     MOV 0x1CE8, W1
000A32  78001E     MOV [W14], W0
000A34  980011     MOV W1, [W0+2]
1770:              }
000A36  FA8000     ULNK
000A38  060000     RETURN
1771:              /*-----------------------------------------------------------*/
1772:              
1773:              portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
1774:              {
000A3A  FA0006     LNK #0x6
000A3C  980710     MOV W0, [W14+2]
000A3E  980721     MOV W1, [W14+4]
1775:              portBASE_TYPE xReturn;
1776:              
1777:              	configASSERT( pxTimeOut );
1778:              	configASSERT( pxTicksToWait );
1779:              
1780:              	taskENTER_CRITICAL();
000A40  070743     RCALL vPortEnterCritical
1781:              	{
1782:              		#if ( INCLUDE_vTaskSuspend == 1 )
1783:              			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1784:              			the maximum block time then the task should block indefinitely, and
1785:              			therefore never time out. */
1786:              			if( *pxTicksToWait == portMAX_DELAY )
000A42  90002E     MOV [W14+4], W0
000A44  780010     MOV [W0], W0
000A46  400FE1     ADD W0, #0x1, [W15]
000A48  3A0003     BRA NZ, 0xA50
1787:              			{
1788:              				xReturn = pdFALSE;
000A4A  EB0000     CLR W0
000A4C  780F00     MOV W0, [W14]
000A4E  370025     BRA 0xA9A
1789:              			}
1790:              			else /* We are not blocking indefinitely, perform the checks below. */
1791:              		#endif
1792:              
1793:              		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
000A50  90001E     MOV [W14+2], W0
000A52  780090     MOV [W0], W1
000A54  80E7B0     MOV 0x1CF6, W0
000A56  508F80     SUB W1, W0, [W15]
000A58  320008     BRA Z, 0xA6A
000A5A  90001E     MOV [W14+2], W0
000A5C  900090     MOV [W0+2], W1
000A5E  80E740     MOV 0x1CE8, W0
000A60  508F80     SUB W1, W0, [W15]
000A62  3E0003     BRA GTU, 0xA6A
000A68  370018     BRA 0xA9A
1794:              		{
1795:              			/* The tick count is greater than the time at which vTaskSetTimeout()
1796:              			was called, but has also overflowed since vTaskSetTimeOut() was called.
1797:              			It must have wrapped all the way around and gone past us again. This
1798:              			passed since vTaskSetTimeout() was called. */
1799:              			xReturn = pdTRUE;
000A64  200010     MOV #0x1, W0
000A66  780F00     MOV W0, [W14]
1800:              		}
1801:              		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
000A6A  80E741     MOV 0x1CE8, W1
000A6C  90001E     MOV [W14+2], W0
000A6E  900010     MOV [W0+2], W0
000A70  508080     SUB W1, W0, W1
000A72  90002E     MOV [W14+4], W0
000A74  780010     MOV [W0], W0
000A76  508F80     SUB W1, W0, [W15]
000A78  31000E     BRA C, 0xA96
1802:              		{
1803:              			/* Not a genuine timeout. Adjust parameters for time remaining. */
1804:              			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
000A7A  90002E     MOV [W14+4], W0
000A7C  780110     MOV [W0], W2
000A7E  80E741     MOV 0x1CE8, W1
000A80  90001E     MOV [W14+2], W0
000A82  900010     MOV [W0+2], W0
000A84  508000     SUB W1, W0, W0
000A86  510080     SUB W2, W0, W1
000A88  90002E     MOV [W14+4], W0
000A8A  780801     MOV W1, [W0]
1805:              			vTaskSetTimeOutState( pxTimeOut );
000A8C  90001E     MOV [W14+2], W0
000A8E  07FFCB     RCALL vTaskSetTimeOutState
1806:              			xReturn = pdFALSE;
000A90  EB0000     CLR W0
000A92  780F00     MOV W0, [W14]
000A94  370002     BRA 0xA9A
1807:              		}
1808:              		else
1809:              		{
1810:              			xReturn = pdTRUE;
000A96  200010     MOV #0x1, W0
000A98  780F00     MOV W0, [W14]
1811:              		}
1812:              	}
1813:              	taskEXIT_CRITICAL();
000A9A  070720     RCALL vPortExitCritical
1814:              
1815:              	return xReturn;
000A9C  78001E     MOV [W14], W0
1816:              }
000A9E  FA8000     ULNK
000AA0  060000     RETURN
1817:              /*-----------------------------------------------------------*/
1818:              
1819:              void vTaskMissedYield( void )
1820:              {
000AA2  FA0000     LNK #0x0
1821:              	xMissedYield = pdTRUE;
000AA4  200010     MOV #0x1, W0
000AA6  88E7A0     MOV W0, 0x1CF4
1822:              }
000AA8  FA8000     ULNK
000AAA  060000     RETURN
1823:              /*-----------------------------------------------------------*/
1824:              
1825:              #if ( configUSE_TRACE_FACILITY == 1 )
1826:              	unsigned portBASE_TYPE uxTaskGetTaskNumber( xTaskHandle xTask )
1827:              	{
1828:              	unsigned portBASE_TYPE uxReturn;
1829:              	tskTCB *pxTCB;
1830:              	
1831:              		if( xTask != NULL )
1832:              		{
1833:              			pxTCB = ( tskTCB * ) xTask;
1834:              			uxReturn = pxTCB->uxTaskNumber;
1835:              		}
1836:              		else
1837:              		{
1838:              			uxReturn = 0U;
1839:              		}
1840:              		
1841:              		return uxReturn;
1842:              	}
1843:              #endif
1844:              /*-----------------------------------------------------------*/
1845:              
1846:              #if ( configUSE_TRACE_FACILITY == 1 )
1847:              	void vTaskSetTaskNumber( xTaskHandle xTask, unsigned portBASE_TYPE uxHandle )
1848:              	{
1849:              	tskTCB *pxTCB;
1850:              	
1851:              		if( xTask != NULL )
1852:              		{
1853:              			pxTCB = ( tskTCB * ) xTask;
1854:              			pxTCB->uxTaskNumber = uxHandle;
1855:              		}
1856:              	}
1857:              #endif
1858:              
1859:              
1860:              /*
1861:               * -----------------------------------------------------------
1862:               * The Idle task.
1863:               * ----------------------------------------------------------
1864:               *
1865:               * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1866:               * language extensions.  The equivalent prototype for this function is:
1867:               *
1868:               * void prvIdleTask( void *pvParameters );
1869:               *
1870:               */
1871:              static portTASK_FUNCTION( prvIdleTask, pvParameters )
1872:              {
000AAC  FA0002     LNK #0x2
000AAE  780F00     MOV W0, [W14]
1873:              	/* Stop warnings. */
1874:              	( void ) pvParameters;
1875:              
1876:              	for( ;; )
1877:              	{
1878:              		/* See if any tasks have been deleted. */
1879:              		prvCheckTasksWaitingTermination();
000AB0  07004E     RCALL prvCheckTasksWaitingTermination
1880:              
1881:              		#if ( configUSE_PREEMPTION == 0 )
1882:              		{
1883:              			/* If we are not using preemption we keep forcing a task switch to
1884:              			see if any other task has become available.  If we are using
1885:              			preemption we don't need to do this as any task becoming available
1886:              			will automatically get the processor anyway. */
1887:              			taskYIELD();
1888:              		}
1889:              		#endif
1890:              
1891:              		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1892:              		{
1893:              			/* When using preemption tasks of equal priority will be
1894:              			timesliced.  If a task that is sharing the idle priority is ready
1895:              			to run then the idle task should yield before the end of the
1896:              			timeslice.
1897:              
1898:              			A critical region is not required here as we are just reading from
1899:              			the list, and an occasional incorrect value will not matter.  If
1900:              			the ready list at the idle priority contains more than one task
1901:              			then a task other than the idle task is ready to execute. */
1902:              			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
000AB2  80E2D0     MOV pxReadyTasksLists, W0
000AB4  500FE1     SUB W0, #0x1, [W15]
000AB6  360003     BRA LEU, 0xABE
1903:              			{
1904:              				taskYIELD();
000AB8  021C5C     CALL _vPortYield
000ABA  000000     NOP
000ABC  000000     NOP
1905:              			}
1906:              		}
1907:              		#endif
1908:              
1909:              		#if ( configUSE_IDLE_HOOK == 1 )
1910:              		{
1911:              			extern void vApplicationIdleHook( void );
1912:              
1913:              			/* Call the user defined function from within the idle task.  This
1914:              			allows the application designer to add background functionality
1915:              			without the overhead of a separate task.
1916:              			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1917:              			CALL A FUNCTION THAT MIGHT BLOCK. */
1918:              			vApplicationIdleHook();
000ABE  0708A1     RCALL vApplicationIdleHook
1919:              		}
1920:              		#endif
1921:              	}
000AC0  37FFF7     BRA 0xAB0
1922:              } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1923:              
1924:              
1925:              
1926:              
1927:              
1928:              
1929:              
1930:              /*-----------------------------------------------------------
1931:               * File private functions documented at the top of the file.
1932:               *----------------------------------------------------------*/
1933:              
1934:              
1935:              
1936:              static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
1937:              {
000AC2  FA000A     LNK #0xA
000AC4  780F00     MOV W0, [W14]
000AC6  980711     MOV W1, [W14+2]
000AC8  980722     MOV W2, [W14+4]
000ACA  980733     MOV W3, [W14+6]
000ACC  980744     MOV W4, [W14+8]
1938:              	/* Store the function name in the TCB. */
1939:              	#if configMAX_TASK_NAME_LEN > 1
1940:              	{
1941:              		/* Don't bring strncpy into the build unnecessarily. */
1942:              		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
000ACE  90009E     MOV [W14+2], W1
000AD0  78011E     MOV [W14], W2
000AD2  41007A     ADD W2, #0x1A, W0
000AD4  200042     MOV #0x4, W2
000AD6  07FC2C     RCALL _strncpy
1943:              	}
1944:              	#endif
1945:              	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
000AD8  78009E     MOV [W14], W1
000ADA  EB4000     CLR.B W0
000ADC  9858D0     MOV.B W0, [W1+29]
1946:              
1947:              	/* This is used as an array index so must ensure it's not too large.  First
1948:              	remove the privilege bit if one is present. */
1949:              	if( uxPriority >= configMAX_PRIORITIES )
000ADE  90002E     MOV [W14+4], W0
000AE0  500FE3     SUB W0, #0x3, [W15]
000AE2  360002     BRA LEU, 0xAE8
1950:              	{
1951:              		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
000AE4  200030     MOV #0x3, W0
000AE6  980720     MOV W0, [W14+4]
1952:              	}
1953:              
1954:              	pxTCB->uxPriority = uxPriority;
000AE8  78001E     MOV [W14], W0
000AEA  9000AE     MOV [W14+4], W1
000AEC  980831     MOV W1, [W0+22]
1955:              	#if ( configUSE_MUTEXES == 1 )
1956:              	{
1957:              		pxTCB->uxBasePriority = uxPriority;
000AEE  78001E     MOV [W14], W0
000AF0  90012E     MOV [W14+4], W2
000AF2  981002     MOV W2, [W0+32]
1958:              	}
1959:              	#endif
1960:              
1961:              	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
000AF4  E8801E     INC2 [W14], W0
000AF6  07072E     RCALL vListInitialiseItem
1962:              	vListInitialiseItem( &( pxTCB->xEventListItem ) );
000AF8  78009E     MOV [W14], W1
000AFA  40806C     ADD W1, #0xC, W0
000AFC  07072B     RCALL vListInitialiseItem
1963:              
1964:              	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
1965:              	back to	the containing TCB from a generic item in a list. */
1966:              	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
000AFE  78001E     MOV [W14], W0
000B00  78011E     MOV [W14], W2
000B02  980042     MOV W2, [W0+8]
1967:              
1968:              	/* Event lists are always in priority order. */
1969:              	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
000B04  90002E     MOV [W14+4], W0
000B06  1000E4     SUBR W0, #0x4, W1
000B08  78001E     MOV [W14], W0
000B0A  980061     MOV W1, [W0+12]
1970:              	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
000B0C  78001E     MOV [W14], W0
000B0E  78009E     MOV [W14], W1
000B10  980811     MOV W1, [W0+18]
1971:              
1972:              	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
1973:              	{
1974:              		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0U;
1975:              	}
1976:              	#endif
1977:              
1978:              	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
1979:              	{
1980:              		pxTCB->pxTaskTag = NULL;
1981:              	}
1982:              	#endif
1983:              
1984:              	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1985:              	{
1986:              		pxTCB->ulRunTimeCounter = 0UL;
1987:              	}
1988:              	#endif
1989:              
1990:              	#if ( portUSING_MPU_WRAPPERS == 1 )
1991:              	{
1992:              		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
1993:              	}
1994:              	#else
1995:              	{
1996:              		( void ) xRegions;
1997:              		( void ) usStackDepth;
1998:              	}
1999:              	#endif
2000:              }
000B12  FA8000     ULNK
000B14  060000     RETURN
2001:              /*-----------------------------------------------------------*/
2002:              
2003:              #if ( portUSING_MPU_WRAPPERS == 1 )
2004:              
2005:              	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
2006:              	{
2007:              	tskTCB *pxTCB;
2008:              	
2009:              		if( xTaskToModify == pxCurrentTCB )
2010:              		{
2011:              			xTaskToModify = NULL;
2012:              		}
2013:              
2014:              		/* If null is passed in here then we are deleting ourselves. */
2015:              		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2016:              
2017:                      vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2018:              	}
2019:              	/*-----------------------------------------------------------*/
2020:              #endif
2021:              
2022:              static void prvInitialiseTaskLists( void )
2023:              {
000B16  FA0002     LNK #0x2
2024:              unsigned portBASE_TYPE uxPriority;
2025:              
2026:              	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
000B18  EB0000     CLR W0
000B1A  780F00     MOV W0, [W14]
000B1C  370007     BRA 0xB2C
000B2A  E80F1E     INC [W14], [W14]
000B2C  200030     MOV #0x3, W0
000B2E  100F9E     SUBR W0, [W14], [W15]
000B30  36FFF6     BRA LEU, 0xB1E
2027:              	{
2028:              		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
000B1E  78001E     MOV [W14], W0
000B20  B9006A     MUL.SU W0, #10, W0
000B22  780080     MOV W0, W1
000B24  21C5A0     MOV #0x1C5A, W0
000B26  408000     ADD W1, W0, W0
000B28  0706FC     RCALL vListInitialise
2029:              	}
2030:              
2031:              	vListInitialise( ( xList * ) &xDelayedTaskList1 );
000B32  21C820     MOV #0x1C82, W0
000B34  0706F6     RCALL vListInitialise
2032:              	vListInitialise( ( xList * ) &xDelayedTaskList2 );
000B36  21C8C0     MOV #0x1C8C, W0
000B38  0706F4     RCALL vListInitialise
2033:              	vListInitialise( ( xList * ) &xPendingReadyList );
000B3A  21C9A0     MOV #0x1C9A, W0
000B3C  0706F2     RCALL vListInitialise
2034:              
2035:              	#if ( INCLUDE_vTaskDelete == 1 )
2036:              	{
2037:              		vListInitialise( ( xList * ) &xTasksWaitingTermination );
2038:              	}
2039:              	#endif
2040:              
2041:              	#if ( INCLUDE_vTaskSuspend == 1 )
2042:              	{
2043:              		vListInitialise( ( xList * ) &xSuspendedTaskList );
000B3E  21CA40     MOV #0x1CA4, W0
000B40  0706F0     RCALL vListInitialise
2044:              	}
2045:              	#endif
2046:              
2047:              	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2048:              	using list2. */
2049:              	pxDelayedTaskList = &xDelayedTaskList1;
000B42  21C820     MOV #0x1C82, W0
000B44  88E4B0     MOV W0, pxDelayedTaskList
2050:              	pxOverflowDelayedTaskList = &xDelayedTaskList2;
000B46  21C8C0     MOV #0x1C8C, W0
000B48  88E4C0     MOV W0, pxOverflowDelayedTaskList
2051:              }
000B4A  FA8000     ULNK
000B4C  060000     RETURN
2052:              /*-----------------------------------------------------------*/
2053:              
2054:              static void prvCheckTasksWaitingTermination( void )
2055:              {
000B4E  FA0000     LNK #0x0
2056:              	#if ( INCLUDE_vTaskDelete == 1 )
2057:              	{
2058:              		portBASE_TYPE xListIsEmpty;
2059:              
2060:              		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2061:              		too often in the idle task. */
2062:              		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
2063:              		{
2064:              			vTaskSuspendAll();
2065:              				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
2066:              			xTaskResumeAll();
2067:              
2068:              			if( xListIsEmpty == pdFALSE )
2069:              			{
2070:              				tskTCB *pxTCB;
2071:              
2072:              				taskENTER_CRITICAL();
2073:              				{
2074:              					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
2075:              					vListRemove( &( pxTCB->xGenericListItem ) );
2076:              					--uxCurrentNumberOfTasks;
2077:              					--uxTasksDeleted;
2078:              				}
2079:              				taskEXIT_CRITICAL();
2080:              
2081:              				prvDeleteTCB( pxTCB );
2082:              			}
2083:              		}
2084:              	}
2085:              	#endif
2086:              }
000B50  FA8000     ULNK
000B52  060000     RETURN
2087:              /*-----------------------------------------------------------*/
2088:              
2089:              static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
2090:              {
000B54  FA0002     LNK #0x2
000B56  780F00     MOV W0, [W14]
2091:              	/* The list item will be inserted in wake time order. */
2092:              	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
000B58  80E720     MOV 0x1CE4, W0
000B5A  78009E     MOV [W14], W1
000B5C  980011     MOV W1, [W0+2]
2093:              
2094:              	if( xTimeToWake < xTickCount )
000B5E  80E740     MOV 0x1CE8, W0
000B60  100F9E     SUBR W0, [W14], [W15]
000B62  310005     BRA C, 0xB6E
2095:              	{
2096:              		/* Wake time has overflowed.  Place this item in the overflow list. */
2097:              		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
000B64  80E720     MOV 0x1CE4, W0
000B66  E88080     INC2 W0, W1
000B68  80E4C0     MOV pxOverflowDelayedTaskList, W0
000B6A  07071D     RCALL vListInsert
000B6C  370009     BRA 0xB80
2098:              	}
2099:              	else
2100:              	{
2101:              		/* The wake time has not overflowed, so we can use the current block list. */
2102:              		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
000B6E  80E720     MOV 0x1CE4, W0
000B70  E88080     INC2 W0, W1
000B72  80E4B0     MOV pxDelayedTaskList, W0
000B74  070718     RCALL vListInsert
2103:              
2104:              		/* If the task entering the blocked state was placed at the head of the
2105:              		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2106:              		too. */
2107:              		if( xTimeToWake < xNextTaskUnblockTime )
000B76  80E7D0     MOV 0x1CFA, W0
000B78  100F9E     SUBR W0, [W14], [W15]
000B7A  310002     BRA C, 0xB80
2108:              		{
2109:              			xNextTaskUnblockTime = xTimeToWake;
000B7C  78001E     MOV [W14], W0
000B7E  88E7D0     MOV W0, 0x1CFA
2110:              		}
2111:              	}
2112:              }
000B80  FA8000     ULNK
000B82  060000     RETURN
2113:              /*-----------------------------------------------------------*/
2114:              
2115:              static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
2116:              {
000B84  FA0008     LNK #0x8
000B86  980710     MOV W0, [W14+2]
000B88  980721     MOV W1, [W14+4]
2117:              tskTCB *pxNewTCB;
2118:              
2119:              	/* Allocate space for the TCB.  Where the memory comes from depends on
2120:              	the implementation of the port malloc function. */
2121:              	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
000B8A  200220     MOV #0x22, W0
000B8C  070570     RCALL pvPortMalloc
000B8E  780F00     MOV W0, [W14]
2122:              
2123:              	if( pxNewTCB != NULL )
000B90  E0001E     CP0 [W14]
000B92  32001D     BRA Z, 0xBCE
2124:              	{
2125:              		/* Allocate space for the stack used by the task being created.
2126:              		The base of the stack memory stored in the TCB so the task can
2127:              		be deleted later if required. */
2128:              		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
000B94  90002E     MOV [W14+4], W0
000B96  E00000     CP0 W0
000B98  3A0005     BRA NZ, 0xBA4
000B9A  90001E     MOV [W14+2], W0
000B9C  400000     ADD W0, W0, W0
000B9E  070567     RCALL pvPortMalloc
000BA0  980730     MOV W0, [W14+6]
000BA2  370002     BRA 0xBA8
000BA4  90002E     MOV [W14+4], W0
000BA6  980730     MOV W0, [W14+6]
000BA8  78001E     MOV [W14], W0
000BAA  9000BE     MOV [W14+6], W1
000BAC  980841     MOV W1, [W0+24]
2129:              
2130:              		if( pxNewTCB->pxStack == NULL )
000BAE  78001E     MOV [W14], W0
000BB0  900840     MOV [W0+24], W0
000BB2  E00000     CP0 W0
000BB4  3A0005     BRA NZ, 0xBC0
2131:              		{
2132:              			/* Could not allocate the stack.  Delete the allocated TCB. */
2133:              			vPortFree( pxNewTCB );
000BB6  78001E     MOV [W14], W0
000BB8  0705DF     RCALL vPortFree
2134:              			pxNewTCB = NULL;
000BBA  EB0000     CLR W0
000BBC  780F00     MOV W0, [W14]
000BBE  370007     BRA 0xBCE
2135:              		}
2136:              		else
2137:              		{
2138:              			/* Just to help debugging. */
2139:              			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
000BC0  90001E     MOV [W14+2], W0
000BC2  400000     ADD W0, W0, W0
000BC4  780100     MOV W0, W2
000BC6  78001E     MOV [W14], W0
000BC8  900840     MOV [W0+24], W0
000BCA  200A51     MOV #0xA5, W1
000BCC  07FBAA     RCALL _memset
2140:              		}
2141:              	}
2142:              
2143:              	return pxNewTCB;
000BCE  78001E     MOV [W14], W0
2144:              }
000BD0  FA8000     ULNK
000BD2  060000     RETURN
2145:              /*-----------------------------------------------------------*/
2146:              
2147:              #if ( configUSE_TRACE_FACILITY == 1 )
2148:              
2149:              	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed char cStatus )
2150:              	{
2151:              	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2152:              	unsigned short usStackRemaining;
2153:              	PRIVILEGED_DATA static char pcStatusString[ 50 ];
2154:              
2155:              		/* Write the details of all the TCB's in pxList into the buffer. */
2156:              		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2157:              		do
2158:              		{
2159:              			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2160:              			#if ( portSTACK_GROWTH > 0 )
2161:              			{
2162:              				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2163:              			}
2164:              			#else
2165:              			{
2166:              				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2167:              			}
2168:              			#endif			
2169:              			
2170:              			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, ( unsigned int ) pxNextTCB->uxPriority, usStackRemaining, ( unsigned int ) pxNextTCB->uxTCBNumber );
2171:              			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2172:              
2173:              		} while( pxNextTCB != pxFirstTCB );
2174:              	}
2175:              
2176:              #endif
2177:              /*-----------------------------------------------------------*/
2178:              
2179:              #if ( configGENERATE_RUN_TIME_STATS == 1 )
2180:              
2181:              	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList, unsigned long ulTotalRunTime )
2182:              	{
2183:              	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2184:              	unsigned long ulStatsAsPercentage;
2185:              
2186:              		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2187:              		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2188:              		do
2189:              		{
2190:              			/* Get next TCB in from the list. */
2191:              			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2192:              
2193:              			/* Divide by zero check. */
2194:              			if( ulTotalRunTime > 0UL )
2195:              			{
2196:              				/* Has the task run at all? */
2197:              				if( pxNextTCB->ulRunTimeCounter == 0UL )
2198:              				{
2199:              					/* The task has used no CPU time at all. */
2200:              					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
2201:              				}
2202:              				else
2203:              				{
2204:              					/* What percentage of the total run time has the task used?
2205:              					This will always be rounded down to the nearest integer.
2206:              					ulTotalRunTime has already been divided by 100. */
2207:              					ulStatsAsPercentage = pxNextTCB->ulRunTimeCounter / ulTotalRunTime;
2208:              
2209:              					if( ulStatsAsPercentage > 0UL )
2210:              					{
2211:              						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2212:              						{
2213:              							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", pxNextTCB->pcTaskName, pxNextTCB->ulRunTimeCounter, ulStatsAsPercentage );							
2214:              						}
2215:              						#else
2216:              						{
2217:              							/* sizeof( int ) == sizeof( long ) so a smaller
2218:              							printf() library can be used. */
2219:              							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned int ) pxNextTCB->ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
2220:              						}
2221:              						#endif
2222:              					}
2223:              					else
2224:              					{
2225:              						/* If the percentage is zero here then the task has
2226:              						consumed less than 1% of the total run time. */
2227:              						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
2228:              						{
2229:              							sprintf( pcStatsString, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", pxNextTCB->pcTaskName, pxNextTCB->ulRunTimeCounter );							
2230:              						}
2231:              						#else
2232:              						{
2233:              							/* sizeof( int ) == sizeof( long ) so a smaller
2234:              							printf() library can be used. */
2235:              							sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned int ) pxNextTCB->ulRunTimeCounter );
2236:              						}
2237:              						#endif
2238:              					}
2239:              				}
2240:              
2241:              				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2242:              			}
2243:              
2244:              		} while( pxNextTCB != pxFirstTCB );
2245:              	}
2246:              
2247:              #endif
2248:              /*-----------------------------------------------------------*/
2249:              
2250:              #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2251:              
2252:              	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2253:              	{
2254:              	register unsigned short usCount = 0U;
2255:              
2256:              		while( *pucStackByte == tskSTACK_FILL_BYTE )
2257:              		{
2258:              			pucStackByte -= portSTACK_GROWTH;
2259:              			usCount++;
2260:              		}
2261:              
2262:              		usCount /= sizeof( portSTACK_TYPE );
2263:              
2264:              		return usCount;
2265:              	}
2266:              
2267:              #endif
2268:              /*-----------------------------------------------------------*/
2269:              
2270:              #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2271:              
2272:              	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2273:              	{
2274:              	tskTCB *pxTCB;
2275:              	unsigned char *pcEndOfStack;
2276:              	unsigned portBASE_TYPE uxReturn;
2277:              
2278:              		pxTCB = prvGetTCBFromHandle( xTask );
2279:              
2280:              		#if portSTACK_GROWTH < 0
2281:              		{
2282:              			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
2283:              		}
2284:              		#else
2285:              		{
2286:              			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2287:              		}
2288:              		#endif
2289:              
2290:              		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
2291:              
2292:              		return uxReturn;
2293:              	}
2294:              
2295:              #endif
2296:              /*-----------------------------------------------------------*/
2297:              
2298:              #if ( INCLUDE_vTaskDelete == 1 )
2299:              
2300:              	static void prvDeleteTCB( tskTCB *pxTCB )
2301:              	{
2302:              		/* This call is required specifically for the TriCore port.  It must be
2303:              		above the vPortFree() calls. */
2304:              		portCLEAN_UP_TCB( pxTCB );
2305:              
2306:              		/* Free up the memory allocated by the scheduler for the task.  It is up to
2307:              		the task to free any memory allocated at the application level. */
2308:              		vPortFreeAligned( pxTCB->pxStack );
2309:              		vPortFree( pxTCB );
2310:              	}
2311:              
2312:              #endif
2313:              
2314:              
2315:              /*-----------------------------------------------------------*/
2316:              
2317:              #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
2318:              
2319:              	xTaskHandle xTaskGetCurrentTaskHandle( void )
2320:              	{
000BD4  FA0002     LNK #0x2
2321:              	xTaskHandle xReturn;
2322:              
2323:              		/* A critical section is not required as this is not called from
2324:              		an interrupt and the current TCB will always be the same for any
2325:              		individual execution thread. */
2326:              		xReturn = pxCurrentTCB;
000BD6  80E720     MOV 0x1CE4, W0
000BD8  780F00     MOV W0, [W14]
2327:              
2328:              		return xReturn;
000BDA  78001E     MOV [W14], W0
2329:              	}
000BDC  FA8000     ULNK
000BDE  060000     RETURN
2330:              
2331:              #endif
2332:              
2333:              /*-----------------------------------------------------------*/
2334:              
2335:              #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
2336:              
2337:              	portBASE_TYPE xTaskGetSchedulerState( void )
2338:              	{
2339:              	portBASE_TYPE xReturn;
2340:              
2341:              		if( xSchedulerRunning == pdFALSE )
2342:              		{
2343:              			xReturn = taskSCHEDULER_NOT_STARTED;
2344:              		}
2345:              		else
2346:              		{
2347:              			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
2348:              			{
2349:              				xReturn = taskSCHEDULER_RUNNING;
2350:              			}
2351:              			else
2352:              			{
2353:              				xReturn = taskSCHEDULER_SUSPENDED;
2354:              			}
2355:              		}
2356:              
2357:              		return xReturn;
2358:              	}
2359:              
2360:              #endif
2361:              /*-----------------------------------------------------------*/
2362:              
2363:              #if ( configUSE_MUTEXES == 1 )
2364:              
2365:              	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2366:              	{
000BE0  FA0004     LNK #0x4
000BE2  980710     MOV W0, [W14+2]
2367:              	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
000BE4  90001E     MOV [W14+2], W0
000BE6  780F00     MOV W0, [W14]
2368:              
2369:              		configASSERT( pxMutexHolder );
2370:              
2371:              		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
000BE8  78001E     MOV [W14], W0
000BEA  9008B0     MOV [W0+22], W1
000BEC  80E720     MOV 0x1CE4, W0
000BEE  900830     MOV [W0+22], W0
000BF0  508F80     SUB W1, W0, [W15]
000BF2  31002B     BRA C, 0xC4A
2372:              		{
2373:              			/* Adjust the mutex holder state to account for its new priority. */
2374:              			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
000BF4  80E720     MOV 0x1CE4, W0
000BF6  900830     MOV [W0+22], W0
000BF8  1000E4     SUBR W0, #0x4, W1
000BFA  78001E     MOV [W14], W0
000BFC  980061     MOV W1, [W0+12]
2375:              
2376:              			/* If the task being modified is in the ready state it will need to
2377:              			be moved in to a new list. */
2378:              			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
000BFE  78001E     MOV [W14], W0
000C00  900150     MOV [W0+10], W2
000C02  78001E     MOV [W14], W0
000C04  900830     MOV [W0+22], W0
000C06  B9006A     MUL.SU W0, #10, W0
000C08  780080     MOV W0, W1
000C0A  21C5A0     MOV #0x1C5A, W0
000C0C  408000     ADD W1, W0, W0
000C0E  510F80     SUB W2, W0, [W15]
000C10  3A0018     BRA NZ, 0xC42
2379:              			{
2380:              				vListRemove( &( pxTCB->xGenericListItem ) );
000C12  E8801E     INC2 [W14], W0
000C14  0706F8     RCALL vListRemove
2381:              
2382:              				/* Inherit the priority before being moved into the new list. */
2383:              				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
000C16  80E720     MOV 0x1CE4, W0
000C18  9008B0     MOV [W0+22], W1
000C1A  78001E     MOV [W14], W0
000C1C  980831     MOV W1, [W0+22]
2384:              				prvAddTaskToReadyQueue( pxTCB );
000C1E  78001E     MOV [W14], W0
000C20  9008B0     MOV [W0+22], W1
000C22  80E760     MOV 0x1CEC, W0
000C24  508F80     SUB W1, W0, [W15]
000C26  360003     BRA LEU, 0xC2E
000C28  78001E     MOV [W14], W0
000C2A  900830     MOV [W0+22], W0
000C2C  88E760     MOV W0, 0x1CEC
000C2E  E8811E     INC2 [W14], W2
000C30  78001E     MOV [W14], W0
000C32  900830     MOV [W0+22], W0
000C34  B9006A     MUL.SU W0, #10, W0
000C36  780080     MOV W0, W1
000C38  21C5A0     MOV #0x1C5A, W0
000C3A  408000     ADD W1, W0, W0
000C3C  780082     MOV W2, W1
000C3E  070691     RCALL vListInsertEnd
000C40  370004     BRA 0xC4A
2385:              			}
2386:              			else
2387:              			{
2388:              				/* Just inherit the priority. */
2389:              				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
000C42  80E720     MOV 0x1CE4, W0
000C44  9008B0     MOV [W0+22], W1
000C46  78001E     MOV [W14], W0
000C48  980831     MOV W1, [W0+22]
2390:              			}
2391:              
2392:              			traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
2393:              		}
2394:              	}
000C4A  FA8000     ULNK
000C4C  060000     RETURN
2395:              
2396:              #endif
2397:              /*-----------------------------------------------------------*/
2398:              
2399:              #if ( configUSE_MUTEXES == 1 )
2400:              
2401:              	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2402:              	{
000C4E  FA0004     LNK #0x4
000C50  980710     MOV W0, [W14+2]
2403:              	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
000C52  90001E     MOV [W14+2], W0
000C54  780F00     MOV W0, [W14]
2404:              
2405:              		if( pxMutexHolder != NULL )
000C56  90001E     MOV [W14+2], W0
000C58  E00000     CP0 W0
000C5A  320022     BRA Z, 0xCA0
2406:              		{
2407:              			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
000C5C  78001E     MOV [W14], W0
000C5E  9008B0     MOV [W0+22], W1
000C60  78001E     MOV [W14], W0
000C62  901000     MOV [W0+32], W0
000C64  508F80     SUB W1, W0, [W15]
000C66  32001C     BRA Z, 0xCA0
2408:              			{
2409:              				/* We must be the running task to be able to give the mutex back.
2410:              				Remove ourselves from the ready list we currently appear in. */
2411:              				vListRemove( &( pxTCB->xGenericListItem ) );
000C68  E8801E     INC2 [W14], W0
000C6A  0706CD     RCALL vListRemove
2412:              
2413:              				/* Disinherit the priority before adding the task into the new
2414:              				ready list. */
2415:              				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
2416:              				pxTCB->uxPriority = pxTCB->uxBasePriority;
000C6C  78001E     MOV [W14], W0
000C6E  901080     MOV [W0+32], W1
000C70  78001E     MOV [W14], W0
000C72  980831     MOV W1, [W0+22]
2417:              				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
000C74  78001E     MOV [W14], W0
000C76  900830     MOV [W0+22], W0
000C78  1000E4     SUBR W0, #0x4, W1
000C7A  78001E     MOV [W14], W0
000C7C  980061     MOV W1, [W0+12]
2418:              				prvAddTaskToReadyQueue( pxTCB );
000C7E  78001E     MOV [W14], W0
000C80  9008B0     MOV [W0+22], W1
000C82  80E760     MOV 0x1CEC, W0
000C84  508F80     SUB W1, W0, [W15]
000C86  360003     BRA LEU, 0xC8E
000C88  78001E     MOV [W14], W0
000C8A  900830     MOV [W0+22], W0
000C8C  88E760     MOV W0, 0x1CEC
000C8E  E8811E     INC2 [W14], W2
000C90  78001E     MOV [W14], W0
000C92  900830     MOV [W0+22], W0
000C94  B9006A     MUL.SU W0, #10, W0
000C96  780080     MOV W0, W1
000C98  21C5A0     MOV #0x1C5A, W0
000C9A  408000     ADD W1, W0, W0
000C9C  780082     MOV W2, W1
000C9E  070661     RCALL vListInsertEnd
2419:              			}
2420:              		}
2421:              	}
000CA0  FA8000     ULNK
000CA2  060000     RETURN
2422:              
2423:              #endif
2424:              /*-----------------------------------------------------------*/
2425:              
2426:              #if ( portCRITICAL_NESTING_IN_TCB == 1 )
2427:              
2428:              	void vTaskEnterCritical( void )
2429:              	{
2430:              		portDISABLE_INTERRUPTS();
2431:              
2432:              		if( xSchedulerRunning != pdFALSE )
2433:              		{
2434:              			( pxCurrentTCB->uxCriticalNesting )++;
2435:              		}
2436:              	}
2437:              
2438:              #endif
2439:              /*-----------------------------------------------------------*/
2440:              
2441:              #if ( portCRITICAL_NESTING_IN_TCB == 1 )
2442:              
2443:              void vTaskExitCritical( void )
2444:              {
2445:              	if( xSchedulerRunning != pdFALSE )
2446:              	{
2447:              		if( pxCurrentTCB->uxCriticalNesting > 0U )
2448:              		{
2449:              			( pxCurrentTCB->uxCriticalNesting )--;
2450:              
2451:              			if( pxCurrentTCB->uxCriticalNesting == 0U )
2452:              			{
2453:              				portENABLE_INTERRUPTS();
2454:              			}
2455:              		}
2456:              	}
2457:              }
2458:              
2459:              #endif
2460:              /*-----------------------------------------------------------*/
2461:              
2462:              
2463:              
2464:              
---  /Users/jhiesey/Desktop/SensorNet/WellInterface/FreeRTOS/Source/queue.c  ----------------------------
1:                 /*
2:                     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
3:                 
4:                 
5:                     ***************************************************************************
6:                      *                                                                       *
7:                      *    FreeRTOS tutorial books are available in pdf and paperback.        *
8:                      *    Complete, revised, and edited pdf reference manuals are also       *
9:                      *    available.                                                         *
10:                     *                                                                       *
11:                     *    Purchasing FreeRTOS documentation will not only help you, by       *
12:                     *    ensuring you get running as quickly as possible and with an        *
13:                     *    in-depth knowledge of how to use FreeRTOS, it will also help       *
14:                     *    the FreeRTOS project to continue with its mission of providing     *
15:                     *    professional grade, cross platform, de facto standard solutions    *
16:                     *    for microcontrollers - completely free of charge!                  *
17:                     *                                                                       *
18:                     *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
19:                     *                                                                       *
20:                     *    Thank you for using FreeRTOS, and thank you for your support!      *
21:                     *                                                                       *
22:                    ***************************************************************************
23:                
24:                
25:                    This file is part of the FreeRTOS distribution.
26:                
27:                    FreeRTOS is free software; you can redistribute it and/or modify it under
28:                    the terms of the GNU General Public License (version 2) as published by the
29:                    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
30:                    >>>NOTE<<< The modification to the GPL is included to allow you to
31:                    distribute a combined work that includes FreeRTOS without being obliged to
32:                    provide the source code for proprietary components outside of the FreeRTOS
33:                    kernel.  FreeRTOS is distributed in the hope that it will be useful, but
34:                    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
35:                    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
36:                    more details. You should have received a copy of the GNU General Public
37:                    License and the FreeRTOS license exception along with FreeRTOS; if not it
38:                    can be viewed here: http://www.freertos.org/a00114.html and also obtained
39:                    by writing to Richard Barry, contact details for whom are available on the
40:                    FreeRTOS WEB site.
41:                
42:                    1 tab == 4 spaces!
43:                
44:                    http://www.FreeRTOS.org - Documentation, latest information, license and
45:                    contact details.
46:                
47:                    http://www.SafeRTOS.com - A version that is certified for use in safety
48:                    critical systems.
49:                
50:                    http://www.OpenRTOS.com - Commercial support, development, porting,
51:                    licensing and training services.
52:                */
53:                
54:                #include <stdlib.h>
55:                #include <string.h>
56:                
57:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
58:                all the API functions to use the MPU wrappers.  That should only be done when
59:                task.h is included from an application file. */
60:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
61:                
62:                #include "FreeRTOS.h"
63:                #include "task.h"
64:                
65:                #if ( configUSE_CO_ROUTINES == 1 )
66:                	#include "croutine.h"
67:                #endif
68:                
69:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
70:                
71:                /*-----------------------------------------------------------
72:                 * PUBLIC LIST API documented in list.h
73:                 *----------------------------------------------------------*/
74:                
75:                /* Constants used with the cRxLock and cTxLock structure members. */
76:                #define queueUNLOCKED					( ( signed portBASE_TYPE ) -1 )
77:                #define queueLOCKED_UNMODIFIED			( ( signed portBASE_TYPE ) 0 )
78:                
79:                #define queueERRONEOUS_UNBLOCK			( -1 )
80:                
81:                /* For internal use only. */
82:                #define	queueSEND_TO_BACK				( 0 )
83:                #define	queueSEND_TO_FRONT				( 1 )
84:                
85:                /* Effectively make a union out of the xQUEUE structure. */
86:                #define pxMutexHolder					pcTail
87:                #define uxQueueType						pcHead
88:                #define uxRecursiveCallCount			pcReadFrom
89:                #define queueQUEUE_IS_MUTEX				NULL
90:                
91:                /* Semaphores do not actually store or copy data, so have an items size of
92:                zero. */
93:                #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( unsigned portBASE_TYPE ) 0 )
94:                #define queueDONT_BLOCK					 ( ( portTickType ) 0U )
95:                #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( portTickType ) 0U )
96:                
97:                /* These definitions *must* match those in queue.h. */
98:                #define queueQUEUE_TYPE_BASE				( 0U )
99:                #define queueQUEUE_TYPE_MUTEX 				( 1U )
100:               #define queueQUEUE_TYPE_COUNTING_SEMAPHORE	( 2U )
101:               #define queueQUEUE_TYPE_BINARY_SEMAPHORE	( 3U )
102:               #define queueQUEUE_TYPE_RECURSIVE_MUTEX		( 4U )
103:               
104:               /*
105:                * Definition of the queue used by the scheduler.
106:                * Items are queued by copy, not reference.
107:                */
108:               typedef struct QueueDefinition
109:               {
110:               	signed char *pcHead;				/*< Points to the beginning of the queue storage area. */
111:               	signed char *pcTail;				/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
112:               
113:               	signed char *pcWriteTo;				/*< Points to the free next place in the storage area. */
114:               	signed char *pcReadFrom;			/*< Points to the last place that a queued item was read from. */
115:               
116:               	xList xTasksWaitingToSend;				/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
117:               	xList xTasksWaitingToReceive;			/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
118:               
119:               	volatile unsigned portBASE_TYPE uxMessagesWaiting;/*< The number of items currently in the queue. */
120:               	unsigned portBASE_TYPE uxLength;		/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
121:               	unsigned portBASE_TYPE uxItemSize;		/*< The size of each items that the queue will hold. */
122:               
123:               	signed portBASE_TYPE xRxLock;			/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
124:               	signed portBASE_TYPE xTxLock;			/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
125:               	
126:               	#if ( configUSE_TRACE_FACILITY == 1 )
127:               		unsigned char ucQueueNumber;
128:               		unsigned char ucQueueType;
129:               	#endif
130:               
131:               } xQUEUE;
132:               /*-----------------------------------------------------------*/
133:               
134:               /*
135:                * Inside this file xQueueHandle is a pointer to a xQUEUE structure.
136:                * To keep the definition private the API header file defines it as a
137:                * pointer to void.
138:                */
139:               typedef xQUEUE * xQueueHandle;
140:               
141:               /*
142:                * Prototypes for public functions are included here so we don't have to
143:                * include the API header file (as it defines xQueueHandle differently).  These
144:                * functions are documented in the API header file.
145:                */
146:               xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType ) PRIVILEGED_FUNCTION;
147:               signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition ) PRIVILEGED_FUNCTION;
148:               unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
149:               void vQueueDelete( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
150:               signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition ) PRIVILEGED_FUNCTION;
151:               signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking ) PRIVILEGED_FUNCTION;
152:               signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken ) PRIVILEGED_FUNCTION;
153:               xQueueHandle xQueueCreateMutex( unsigned char ucQueueType ) PRIVILEGED_FUNCTION;
154:               xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount ) PRIVILEGED_FUNCTION;
155:               portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle xMutex, portTickType xBlockTime ) PRIVILEGED_FUNCTION;
156:               portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle xMutex ) PRIVILEGED_FUNCTION;
157:               signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition ) PRIVILEGED_FUNCTION;
158:               signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking ) PRIVILEGED_FUNCTION;
159:               signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
160:               signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
161:               unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
162:               void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait ) PRIVILEGED_FUNCTION;
163:               unsigned char ucQueueGetQueueNumber( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
164:               void vQueueSetQueueNumber( xQueueHandle pxQueue, unsigned char ucQueueNumber ) PRIVILEGED_FUNCTION;
165:               unsigned char ucQueueGetQueueType( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
166:               
167:               /*
168:                * Co-routine queue functions differ from task queue functions.  Co-routines are
169:                * an optional component.
170:                */
171:               #if configUSE_CO_ROUTINES == 1
172:               	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken ) PRIVILEGED_FUNCTION;
173:               	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE_TYPE *pxTaskWoken ) PRIVILEGED_FUNCTION;
174:               	signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType xTicksToWait ) PRIVILEGED_FUNCTION;
175:               	signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToWait ) PRIVILEGED_FUNCTION;
176:               #endif
177:               
178:               /*
179:                * The queue registry is just a means for kernel aware debuggers to locate
180:                * queue structures.  It has no other purpose so is an optional component.
181:                */
182:               #if configQUEUE_REGISTRY_SIZE > 0
183:               
184:               	/* The type stored within the queue registry array.  This allows a name
185:               	to be assigned to each queue making kernel aware debugging a little
186:               	more user friendly. */
187:               	typedef struct QUEUE_REGISTRY_ITEM
188:               	{
189:               		signed char *pcQueueName;
190:               		xQueueHandle xHandle;
191:               	} xQueueRegistryItem;
192:               
193:               	/* The queue registry is simply an array of xQueueRegistryItem structures.
194:               	The pcQueueName member of a structure being NULL is indicative of the
195:               	array position being vacant. */
196:               	xQueueRegistryItem xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
197:               
198:               	/* Removes a queue from the registry by simply setting the pcQueueName
199:               	member to NULL. */
200:               	static void vQueueUnregisterQueue( xQueueHandle xQueue ) PRIVILEGED_FUNCTION;
201:               	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName ) PRIVILEGED_FUNCTION;
202:               #endif
203:               
204:               /*
205:                * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
206:                * prevent an ISR from adding or removing items to the queue, but does prevent
207:                * an ISR from removing tasks from the queue event lists.  If an ISR finds a
208:                * queue is locked it will instead increment the appropriate queue lock count
209:                * to indicate that a task may require unblocking.  When the queue in unlocked
210:                * these lock counts are inspected, and the appropriate action taken.
211:                */
212:               static void prvUnlockQueue( xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
213:               
214:               /*
215:                * Uses a critical section to determine if there is any data in a queue.
216:                *
217:                * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
218:                */
219:               static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
220:               
221:               /*
222:                * Uses a critical section to determine if there is any space in a queue.
223:                *
224:                * @return pdTRUE if there is no space, otherwise pdFALSE;
225:                */
226:               static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue ) PRIVILEGED_FUNCTION;
227:               
228:               /*
229:                * Copies an item into the queue, either at the front of the queue or the
230:                * back of the queue.
231:                */
232:               static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition ) PRIVILEGED_FUNCTION;
233:               
234:               /*
235:                * Copies an item out of a queue.
236:                */
237:               static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer ) PRIVILEGED_FUNCTION;
238:               /*-----------------------------------------------------------*/
239:               
240:               /*
241:                * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
242:                * accessing the queue event lists.
243:                */
244:               #define prvLockQueue( pxQueue )								\
245:               	taskENTER_CRITICAL();									\
246:               	{														\
247:               		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
248:               		{													\
249:               			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
250:               		}													\
251:               		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
252:               		{													\
253:               			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
254:               		}													\
255:               	}														\
256:               	taskEXIT_CRITICAL()
257:               /*-----------------------------------------------------------*/
258:               
259:               
260:               /*-----------------------------------------------------------
261:                * PUBLIC QUEUE MANAGEMENT API documented in queue.h
262:                *----------------------------------------------------------*/
263:               
264:               xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
265:               {
000CA4  FA000C     LNK #0xC
000CA6  980730     MOV W0, [W14+6]
000CA8  980741     MOV W1, [W14+8]
000CAA  984F22     MOV.B W2, [W14+10]
266:               xQUEUE *pxNewQueue;
267:               size_t xQueueSizeInBytes;
268:               xQueueHandle xReturn = NULL;
000CAC  EB0000     CLR W0
000CAE  780F00     MOV W0, [W14]
269:               
270:               	/* Remove compiler warnings about unused parameters should 
271:               	configUSE_TRACE_FACILITY not be set to 1. */
272:               	( void ) ucQueueType;
273:               
274:               	/* Allocate the new queue structure. */
275:               	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
000CB0  90003E     MOV [W14+6], W0
000CB2  E00000     CP0 W0
000CB4  320043     BRA Z, 0xD3C
276:               	{
277:               		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
000CB6  200260     MOV #0x26, W0
000CB8  0704DA     RCALL pvPortMalloc
000CBA  980720     MOV W0, [W14+4]
278:               		if( pxNewQueue != NULL )
000CBC  90002E     MOV [W14+4], W0
000CBE  E00000     CP0 W0
000CC0  32003D     BRA Z, 0xD3C
279:               		{
280:               			/* Create the list of pointers to queue items.  The queue is one byte
281:               			longer than asked for to make wrap checking easier/faster. */
282:               			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
000CC2  9000BE     MOV [W14+6], W1
000CC4  90004E     MOV [W14+8], W0
000CC6  B98800     MUL.SS W1, W0, W0
000CC8  E80000     INC W0, W0
000CCA  980710     MOV W0, [W14+2]
283:               
284:               			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
000CCC  90001E     MOV [W14+2], W0
000CCE  0704CF     RCALL pvPortMalloc
000CD0  780080     MOV W0, W1
000CD2  90002E     MOV [W14+4], W0
000CD4  780801     MOV W1, [W0]
285:               			if( pxNewQueue->pcHead != NULL )
000CD6  90002E     MOV [W14+4], W0
000CD8  780010     MOV [W0], W0
000CDA  E00000     CP0 W0
000CDC  32002D     BRA Z, 0xD38
286:               			{
287:               				/* Initialise the queue members as described above where the
288:               				queue type is defined. */
289:               				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
000CDE  90002E     MOV [W14+4], W0
000CE0  780110     MOV [W0], W2
000CE2  9000BE     MOV [W14+6], W1
000CE4  90004E     MOV [W14+8], W0
000CE6  B98800     MUL.SS W1, W0, W0
000CE8  410080     ADD W2, W0, W1
000CEA  90002E     MOV [W14+4], W0
000CEC  980011     MOV W1, [W0+2]
290:               				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
000CEE  9000AE     MOV [W14+4], W1
000CF0  EB0000     CLR W0
000CF2  9808E0     MOV W0, [W1+28]
291:               				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
000CF4  90002E     MOV [W14+4], W0
000CF6  780090     MOV [W0], W1
000CF8  90002E     MOV [W14+4], W0
000CFA  980021     MOV W1, [W0+4]
292:               				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
000CFC  90002E     MOV [W14+4], W0
000CFE  780110     MOV [W0], W2
000D00  90003E     MOV [W14+6], W0
000D02  E90080     DEC W0, W1
000D04  90004E     MOV [W14+8], W0
000D06  B98800     MUL.SS W1, W0, W0
000D08  410080     ADD W2, W0, W1
000D0A  90002E     MOV [W14+4], W0
000D0C  980031     MOV W1, [W0+6]
293:               				pxNewQueue->uxLength = uxQueueLength;
000D0E  90002E     MOV [W14+4], W0
000D10  9000BE     MOV [W14+6], W1
000D12  980871     MOV W1, [W0+30]
294:               				pxNewQueue->uxItemSize = uxItemSize;
000D14  90002E     MOV [W14+4], W0
000D16  9000CE     MOV [W14+8], W1
000D18  981001     MOV W1, [W0+32]
295:               				pxNewQueue->xRxLock = queueUNLOCKED;
000D1A  9000AE     MOV [W14+4], W1
000D1C  EB8000     SETM W0
000D1E  981090     MOV W0, [W1+34]
296:               				pxNewQueue->xTxLock = queueUNLOCKED;
000D20  9000AE     MOV [W14+4], W1
000D22  EB8000     SETM W0
000D24  9810A0     MOV W0, [W1+36]
297:               				#if ( configUSE_TRACE_FACILITY == 1 )
298:               				{
299:               					pxNewQueue->ucQueueType = ucQueueType;
300:               				}
301:               				#endif /* configUSE_TRACE_FACILITY */
302:               
303:               				/* Likewise ensure the event queues start with the correct state. */
304:               				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
000D26  90002E     MOV [W14+4], W0
000D28  400068     ADD W0, #0x8, W0
000D2A  0705FB     RCALL vListInitialise
305:               				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
000D2C  90002E     MOV [W14+4], W0
000D2E  400072     ADD W0, #0x12, W0
000D30  0705F8     RCALL vListInitialise
306:               
307:               				traceQUEUE_CREATE( pxNewQueue );
308:               				xReturn = pxNewQueue;
000D32  90002E     MOV [W14+4], W0
000D34  780F00     MOV W0, [W14]
000D36  370002     BRA 0xD3C
309:               			}
310:               			else
311:               			{
312:               				traceQUEUE_CREATE_FAILED( ucQueueType );
313:               				vPortFree( pxNewQueue );
000D38  90002E     MOV [W14+4], W0
000D3A  07051E     RCALL vPortFree
314:               			}
315:               		}
316:               	}
317:               
318:               	configASSERT( xReturn );
319:               
320:               	return xReturn;
000D3C  78001E     MOV [W14], W0
321:               }
000D3E  FA8000     ULNK
000D40  060000     RETURN
322:               /*-----------------------------------------------------------*/
323:               
324:               #if ( configUSE_MUTEXES == 1 )
325:               
326:               	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
327:               	{
000D42  FA0004     LNK #0x4
000D44  984720     MOV.B W0, [W14+2]
328:               	xQUEUE *pxNewQueue;
329:               
330:               		/* Prevent compiler warnings about unused parameters if
331:               		configUSE_TRACE_FACILITY does not equal 1. */
332:               		( void ) ucQueueType;
333:               	
334:               		/* Allocate the new queue structure. */
335:               		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
000D46  200260     MOV #0x26, W0
000D48  070492     RCALL pvPortMalloc
000D4A  780F00     MOV W0, [W14]
336:               		if( pxNewQueue != NULL )
000D4C  E0001E     CP0 [W14]
000D4E  320026     BRA Z, 0xD9C
337:               		{
338:               			/* Information required for priority inheritance. */
339:               			pxNewQueue->pxMutexHolder = NULL;
000D50  78009E     MOV [W14], W1
000D52  EB0000     CLR W0
000D54  980090     MOV W0, [W1+2]
340:               			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
000D56  78009E     MOV [W14], W1
000D58  EB0000     CLR W0
000D5A  780880     MOV W0, [W1]
341:               
342:               			/* Queues used as a mutex no data is actually copied into or out
343:               			of the queue. */
344:               			pxNewQueue->pcWriteTo = NULL;
000D5C  78009E     MOV [W14], W1
000D5E  EB0000     CLR W0
000D60  9800A0     MOV W0, [W1+4]
345:               			pxNewQueue->pcReadFrom = NULL;
000D62  78009E     MOV [W14], W1
000D64  EB0000     CLR W0
000D66  9800B0     MOV W0, [W1+6]
346:               
347:               			/* Each mutex has a length of 1 (like a binary semaphore) and
348:               			an item size of 0 as nothing is actually copied into or out
349:               			of the mutex. */
350:               			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
000D68  78009E     MOV [W14], W1
000D6A  EB0000     CLR W0
000D6C  9808E0     MOV W0, [W1+28]
351:               			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
000D6E  78009E     MOV [W14], W1
000D70  200010     MOV #0x1, W0
000D72  9808F0     MOV W0, [W1+30]
352:               			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
000D74  78009E     MOV [W14], W1
000D76  EB0000     CLR W0
000D78  981080     MOV W0, [W1+32]
353:               			pxNewQueue->xRxLock = queueUNLOCKED;
000D7A  78009E     MOV [W14], W1
000D7C  EB8000     SETM W0
000D7E  981090     MOV W0, [W1+34]
354:               			pxNewQueue->xTxLock = queueUNLOCKED;
000D80  78009E     MOV [W14], W1
000D82  EB8000     SETM W0
000D84  9810A0     MOV W0, [W1+36]
355:               			
356:               			#if ( configUSE_TRACE_FACILITY == 1 )
357:               			{
358:               				pxNewQueue->ucQueueType = ucQueueType;
359:               			}
360:               			#endif
361:               
362:               			/* Ensure the event queues start with the correct state. */
363:               			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
000D86  78009E     MOV [W14], W1
000D88  408068     ADD W1, #0x8, W0
000D8A  0705CB     RCALL vListInitialise
364:               			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
000D8C  78009E     MOV [W14], W1
000D8E  408072     ADD W1, #0x12, W0
000D90  0705C8     RCALL vListInitialise
365:               
366:               			traceCREATE_MUTEX( pxNewQueue );
367:               
368:               			/* Start with the semaphore in the expected state. */
369:               			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
000D92  EB0180     CLR W3
000D94  EB0100     CLR W2
000D96  EB0080     CLR W1
000D98  78001E     MOV [W14], W0
000D9A  070003     RCALL xQueueGenericSend
370:               		}
371:               		else
372:               		{
373:               			traceCREATE_MUTEX_FAILED();
374:               		}
375:               
376:               		configASSERT( pxNewQueue );
377:               		return pxNewQueue;
000D9C  78001E     MOV [W14], W0
378:               	}
000D9E  FA8000     ULNK
000DA0  060000     RETURN
379:               
380:               #endif /* configUSE_MUTEXES */
381:               /*-----------------------------------------------------------*/
382:               
383:               #if configUSE_RECURSIVE_MUTEXES == 1
384:               
385:               	portBASE_TYPE xQueueGiveMutexRecursive( xQueueHandle pxMutex )
386:               	{
387:               	portBASE_TYPE xReturn;
388:               
389:               		configASSERT( pxMutex );
390:               
391:               		/* If this is the task that holds the mutex then pxMutexHolder will not
392:               		change outside of this task.  If this task does not hold the mutex then
393:               		pxMutexHolder can never coincidentally equal the tasks handle, and as
394:               		this is the only condition we are interested in it does not matter if
395:               		pxMutexHolder is accessed simultaneously by another task.  Therefore no
396:               		mutual exclusion is required to test the pxMutexHolder variable. */
397:               		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
398:               		{
399:               			traceGIVE_MUTEX_RECURSIVE( pxMutex );
400:               
401:               			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
402:               			the task handle, therefore no underflow check is required.  Also,
403:               			uxRecursiveCallCount is only modified by the mutex holder, and as
404:               			there can only be one, no mutual exclusion is required to modify the
405:               			uxRecursiveCallCount member. */
406:               			( pxMutex->uxRecursiveCallCount )--;
407:               
408:               			/* Have we unwound the call count? */
409:               			if( pxMutex->uxRecursiveCallCount == 0 )
410:               			{
411:               				/* Return the mutex.  This will automatically unblock any other
412:               				task that might be waiting to access the mutex. */
413:               				xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
414:               			}
415:               
416:               			xReturn = pdPASS;
417:               		}
418:               		else
419:               		{
420:               			/* We cannot give the mutex because we are not the holder. */
421:               			xReturn = pdFAIL;
422:               
423:               			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
424:               		}
425:               
426:               		return xReturn;
427:               	}
428:               
429:               #endif /* configUSE_RECURSIVE_MUTEXES */
430:               /*-----------------------------------------------------------*/
431:               
432:               #if configUSE_RECURSIVE_MUTEXES == 1
433:               
434:               	portBASE_TYPE xQueueTakeMutexRecursive( xQueueHandle pxMutex, portTickType xBlockTime )
435:               	{
436:               	portBASE_TYPE xReturn;
437:               
438:               		configASSERT( pxMutex );
439:               
440:               		/* Comments regarding mutual exclusion as per those within
441:               		xQueueGiveMutexRecursive(). */
442:               
443:               		traceTAKE_MUTEX_RECURSIVE( pxMutex );
444:               
445:               		if( pxMutex->pxMutexHolder == xTaskGetCurrentTaskHandle() )
446:               		{
447:               			( pxMutex->uxRecursiveCallCount )++;
448:               			xReturn = pdPASS;
449:               		}
450:               		else
451:               		{
452:               			xReturn = xQueueGenericReceive( pxMutex, NULL, xBlockTime, pdFALSE );
453:               
454:               			/* pdPASS will only be returned if we successfully obtained the mutex,
455:               			we may have blocked to reach here. */
456:               			if( xReturn == pdPASS )
457:               			{
458:               				( pxMutex->uxRecursiveCallCount )++;
459:               			}
460:               			else
461:               			{
462:               				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
463:               			}
464:               		}
465:               
466:               		return xReturn;
467:               	}
468:               
469:               #endif /* configUSE_RECURSIVE_MUTEXES */
470:               /*-----------------------------------------------------------*/
471:               
472:               #if configUSE_COUNTING_SEMAPHORES == 1
473:               
474:               	xQueueHandle xQueueCreateCountingSemaphore( unsigned portBASE_TYPE uxCountValue, unsigned portBASE_TYPE uxInitialCount )
475:               	{
476:               	xQueueHandle pxHandle;
477:               
478:               		pxHandle = xQueueGenericCreate( ( unsigned portBASE_TYPE ) uxCountValue, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
479:               
480:               		if( pxHandle != NULL )
481:               		{
482:               			pxHandle->uxMessagesWaiting = uxInitialCount;
483:               
484:               			traceCREATE_COUNTING_SEMAPHORE();
485:               		}
486:               		else
487:               		{
488:               			traceCREATE_COUNTING_SEMAPHORE_FAILED();
489:               		}
490:               
491:               		configASSERT( pxHandle );
492:               		return pxHandle;
493:               	}
494:               
495:               #endif /* configUSE_COUNTING_SEMAPHORES */
496:               /*-----------------------------------------------------------*/
497:               
498:               signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
499:               {
000DA2  FA0010     LNK #0x10
000DA4  980730     MOV W0, [W14+6]
000DA6  980741     MOV W1, [W14+8]
000DA8  980752     MOV W2, [W14+10]
000DAA  980763     MOV W3, [W14+12]
500:               signed portBASE_TYPE xEntryTimeSet = pdFALSE;
000DAC  EB0000     CLR W0
000DAE  780F00     MOV W0, [W14]
000DB0  370000     BRA 0xDB2
501:               xTimeOutType xTimeOut;
502:               
503:               	configASSERT( pxQueue );
504:               	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
505:               
506:               	/* This function relaxes the coding standard somewhat to allow return
507:               	statements within the function itself.  This is done in the interest
508:               	of execution time efficiency. */
509:               	for( ;; )
510:               	{
511:               		taskENTER_CRITICAL();
000DB2  07058A     RCALL vPortEnterCritical
512:               		{
513:               			/* Is there room on the queue now?  To be running we must be
514:               			the highest priority task wanting to access the queue. */
515:               			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
000DB4  90003E     MOV [W14+6], W0
000DB6  9008E0     MOV [W0+28], W1
000DB8  90003E     MOV [W14+6], W0
000DBA  900870     MOV [W0+30], W0
000DBC  508F80     SUB W1, W0, [W15]
000DBE  310014     BRA C, 0xDE8
516:               			{
517:               				traceQUEUE_SEND( pxQueue );
518:               				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
000DC0  90016E     MOV [W14+12], W2
000DC2  9000CE     MOV [W14+8], W1
000DC4  90003E     MOV [W14+6], W0
000DC6  070159     RCALL prvCopyDataToQueue
519:               
520:               				/* If there was a task waiting for data to arrive on the
521:               				queue then unblock it now. */
522:               				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000DC8  90003E     MOV [W14+6], W0
000DCA  900810     MOV [W0+18], W0
000DCC  E00000     CP0 W0
000DCE  320008     BRA Z, 0xDE0
523:               				{
524:               					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
000DD0  90003E     MOV [W14+6], W0
000DD2  400072     ADD W0, #0x12, W0
000DD4  07FDF4     RCALL xTaskRemoveFromEventList
000DD6  500FE1     SUB W0, #0x1, [W15]
000DD8  3A0003     BRA NZ, 0xDE0
525:               					{
526:               						/* The unblocked task has a priority higher than
527:               						our own so yield immediately.  Yes it is ok to do
528:               						this from within the critical section - the kernel
529:               						takes care of that. */
530:               						portYIELD_WITHIN_API();
000DDA  021C5C     CALL _vPortYield
000DDC  000000     NOP
000DDE  000000     NOP
531:               					}
532:               				}
533:               
534:               				taskEXIT_CRITICAL();
000DE0  07057D     RCALL vPortExitCritical
535:               
536:               				/* Return to the original privilege level before exiting the
537:               				function. */
538:               				return pdPASS;
000DE2  200010     MOV #0x1, W0
000DE4  980770     MOV W0, [W14+14]
000DE6  37003E     BRA 0xE64
539:               			}
540:               			else
541:               			{
542:               				if( xTicksToWait == ( portTickType ) 0 )
000DE8  90005E     MOV [W14+10], W0
000DEA  E00000     CP0 W0
000DEC  3A0004     BRA NZ, 0xDF6
543:               				{
544:               					/* The queue was full and no block time is specified (or
545:               					the block time has expired) so leave now. */
546:               					taskEXIT_CRITICAL();
000DEE  070576     RCALL vPortExitCritical
547:               
548:               					/* Return to the original privilege level before exiting
549:               					the function. */
550:               					traceQUEUE_SEND_FAILED( pxQueue );
551:               					return errQUEUE_FULL;
000DF0  EB0000     CLR W0
000DF2  980770     MOV W0, [W14+14]
000DF4  370037     BRA 0xE64
552:               				}
553:               				else if( xEntryTimeSet == pdFALSE )
000DF6  E0001E     CP0 [W14]
000DF8  3A0004     BRA NZ, 0xE02
554:               				{
555:               					/* The queue was full and a block time was specified so
556:               					configure the timeout structure. */
557:               					vTaskSetTimeOutState( &xTimeOut );
000DFA  E8800E     INC2 W14, W0
000DFC  07FE14     RCALL vTaskSetTimeOutState
558:               					xEntryTimeSet = pdTRUE;
000DFE  200010     MOV #0x1, W0
000E00  780F00     MOV W0, [W14]
559:               				}
560:               			}
561:               		}
562:               		taskEXIT_CRITICAL();
000E02  07056C     RCALL vPortExitCritical
563:               
564:               		/* Interrupts and other tasks can send to and receive from the queue
565:               		now the critical section has been exited. */
566:               
567:               		vTaskSuspendAll();
000E04  07FCCD     RCALL vTaskSuspendAll
568:               		prvLockQueue( pxQueue );
000E06  070560     RCALL vPortEnterCritical
000E08  90003E     MOV [W14+6], W0
000E0A  901010     MOV [W0+34], W0
000E0C  400FE1     ADD W0, #0x1, [W15]
000E0E  3A0003     BRA NZ, 0xE16
000E10  9000BE     MOV [W14+6], W1
000E12  EB0000     CLR W0
000E14  981090     MOV W0, [W1+34]
000E16  90003E     MOV [W14+6], W0
000E18  901020     MOV [W0+36], W0
000E1A  400FE1     ADD W0, #0x1, [W15]
000E1C  3A0003     BRA NZ, 0xE24
000E1E  9000BE     MOV [W14+6], W1
000E20  EB0000     CLR W0
000E22  9810A0     MOV W0, [W1+36]
000E24  07055B     RCALL vPortExitCritical
569:               
570:               		/* Update the timeout state to see if it has expired yet. */
571:               		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
000E26  4700EA     ADD W14, #0xA, W1
000E28  E8800E     INC2 W14, W0
000E2A  07FE07     RCALL xTaskCheckForTimeOut
000E2C  E00000     CP0 W0
000E2E  3A0015     BRA NZ, 0xE5A
572:               		{
573:               			if( prvIsQueueFull( pxQueue ) != pdFALSE )
000E30  90003E     MOV [W14+6], W0
000E32  0701E4     RCALL prvIsQueueFull
000E34  E00000     CP0 W0
000E36  32000D     BRA Z, 0xE52
574:               			{
575:               				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
576:               				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
000E38  9000DE     MOV [W14+10], W1
000E3A  90003E     MOV [W14+6], W0
000E3C  400068     ADD W0, #0x8, W0
000E3E  07FDA6     RCALL vTaskPlaceOnEventList
577:               
578:               				/* Unlocking the queue means queue events can effect the
579:               				event list.  It is possible	that interrupts occurring now
580:               				remove this task from the event	list again - but as the
581:               				scheduler is suspended the task will go onto the pending
582:               				ready last instead of the actual ready list. */
583:               				prvUnlockQueue( pxQueue );
000E40  90003E     MOV [W14+6], W0
000E42  07018A     RCALL prvUnlockQueue
584:               
585:               				/* Resuming the scheduler will move tasks from the pending
586:               				ready list into the ready list - so it is feasible that this
587:               				task is already in a ready list before it yields - in which
588:               				case the yield will not cause a context switch unless there
589:               				is also a higher priority task in the pending ready list. */
590:               				if( xTaskResumeAll() == pdFALSE )
000E44  07FCB3     RCALL xTaskResumeAll
000E46  E00000     CP0 W0
000E48  3AFFB4     BRA NZ, 0xDB2
591:               				{
592:               					portYIELD_WITHIN_API();
000E4A  021C5C     CALL _vPortYield
000E4C  000000     NOP
000E4E  000000     NOP
000E50  37FFB0     BRA 0xDB2
593:               				}
594:               			}
595:               			else
596:               			{
597:               				/* Try again. */
598:               				prvUnlockQueue( pxQueue );
000E52  90003E     MOV [W14+6], W0
000E54  070181     RCALL prvUnlockQueue
599:               				( void ) xTaskResumeAll();
000E56  07FCAA     RCALL xTaskResumeAll
600:               			}
601:               		}
602:               		else
603:               		{
604:               			/* The timeout has expired. */
605:               			prvUnlockQueue( pxQueue );
000E5A  90003E     MOV [W14+6], W0
000E5C  07017D     RCALL prvUnlockQueue
606:               			( void ) xTaskResumeAll();
000E5E  07FCA6     RCALL xTaskResumeAll
607:               
608:               			/* Return to the original privilege level before exiting the
609:               			function. */
610:               			traceQUEUE_SEND_FAILED( pxQueue );
611:               			return errQUEUE_FULL;
000E60  EB0000     CLR W0
000E62  980770     MOV W0, [W14+14]
000E64  90007E     MOV [W14+14], W0
612:               		}
613:               	}
000E58  37FFAC     BRA 0xDB2
614:               }
000E66  FA8000     ULNK
000E68  060000     RETURN
615:               /*-----------------------------------------------------------*/
616:               
617:               #if configUSE_ALTERNATIVE_API == 1
618:               
619:               	signed portBASE_TYPE xQueueAltGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
620:               	{
621:               	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
622:               	xTimeOutType xTimeOut;
623:               
624:               		configASSERT( pxQueue );
625:               		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
626:               
627:               		for( ;; )
628:               		{
629:               			taskENTER_CRITICAL();
630:               			{
631:               				/* Is there room on the queue now?  To be running we must be
632:               				the highest priority task wanting to access the queue. */
633:               				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
634:               				{
635:               					traceQUEUE_SEND( pxQueue );
636:               					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
637:               
638:               					/* If there was a task waiting for data to arrive on the
639:               					queue then unblock it now. */
640:               					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
641:               					{
642:               						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
643:               						{
644:               							/* The unblocked task has a priority higher than
645:               							our own so yield immediately. */
646:               							portYIELD_WITHIN_API();
647:               						}
648:               					}
649:               
650:               					taskEXIT_CRITICAL();
651:               					return pdPASS;
652:               				}
653:               				else
654:               				{
655:               					if( xTicksToWait == ( portTickType ) 0 )
656:               					{
657:               						taskEXIT_CRITICAL();
658:               						return errQUEUE_FULL;
659:               					}
660:               					else if( xEntryTimeSet == pdFALSE )
661:               					{
662:               						vTaskSetTimeOutState( &xTimeOut );
663:               						xEntryTimeSet = pdTRUE;
664:               					}
665:               				}
666:               			}
667:               			taskEXIT_CRITICAL();
668:               
669:               			taskENTER_CRITICAL();
670:               			{
671:               				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
672:               				{
673:               					if( prvIsQueueFull( pxQueue ) != pdFALSE )
674:               					{
675:               						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
676:               						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
677:               						portYIELD_WITHIN_API();
678:               					}
679:               				}
680:               				else
681:               				{
682:               					taskEXIT_CRITICAL();
683:               					traceQUEUE_SEND_FAILED( pxQueue );
684:               					return errQUEUE_FULL;
685:               				}
686:               			}
687:               			taskEXIT_CRITICAL();
688:               		}
689:               	}
690:               
691:               #endif /* configUSE_ALTERNATIVE_API */
692:               /*-----------------------------------------------------------*/
693:               
694:               #if configUSE_ALTERNATIVE_API == 1
695:               
696:               	signed portBASE_TYPE xQueueAltGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
697:               	{
698:               	signed portBASE_TYPE xEntryTimeSet = pdFALSE;
699:               	xTimeOutType xTimeOut;
700:               	signed char *pcOriginalReadPosition;
701:               
702:               		configASSERT( pxQueue );
703:               		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
704:               
705:               		for( ;; )
706:               		{
707:               			taskENTER_CRITICAL();
708:               			{
709:               				if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
710:               				{
711:               					/* Remember our read position in case we are just peeking. */
712:               					pcOriginalReadPosition = pxQueue->pcReadFrom;
713:               
714:               					prvCopyDataFromQueue( pxQueue, pvBuffer );
715:               
716:               					if( xJustPeeking == pdFALSE )
717:               					{
718:               						traceQUEUE_RECEIVE( pxQueue );
719:               
720:               						/* We are actually removing data. */
721:               						--( pxQueue->uxMessagesWaiting );
722:               
723:               						#if ( configUSE_MUTEXES == 1 )
724:               						{
725:               							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
726:               							{
727:               								/* Record the information required to implement
728:               								priority inheritance should it become necessary. */
729:               								pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
730:               							}
731:               						}
732:               						#endif
733:               
734:               						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
735:               						{
736:               							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
737:               							{
738:               								portYIELD_WITHIN_API();
739:               							}
740:               						}
741:               					}
742:               					else
743:               					{
744:               						traceQUEUE_PEEK( pxQueue );
745:               
746:               						/* We are not removing the data, so reset our read
747:               						pointer. */
748:               						pxQueue->pcReadFrom = pcOriginalReadPosition;
749:               
750:               						/* The data is being left in the queue, so see if there are
751:               						any other tasks waiting for the data. */
752:               						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
753:               						{
754:               							/* Tasks that are removed from the event list will get added to
755:               							the pending ready list as the scheduler is still suspended. */
756:               							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
757:               							{
758:               								/* The task waiting has a higher priority than this task. */
759:               								portYIELD_WITHIN_API();
760:               							}
761:               						}
762:               
763:               					}
764:               
765:               					taskEXIT_CRITICAL();
766:               					return pdPASS;
767:               				}
768:               				else
769:               				{
770:               					if( xTicksToWait == ( portTickType ) 0 )
771:               					{
772:               						taskEXIT_CRITICAL();
773:               						traceQUEUE_RECEIVE_FAILED( pxQueue );
774:               						return errQUEUE_EMPTY;
775:               					}
776:               					else if( xEntryTimeSet == pdFALSE )
777:               					{
778:               						vTaskSetTimeOutState( &xTimeOut );
779:               						xEntryTimeSet = pdTRUE;
780:               					}
781:               				}
782:               			}
783:               			taskEXIT_CRITICAL();
784:               
785:               			taskENTER_CRITICAL();
786:               			{
787:               				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
788:               				{
789:               					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
790:               					{
791:               						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
792:               
793:               						#if ( configUSE_MUTEXES == 1 )
794:               						{
795:               							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
796:               							{
797:               								portENTER_CRITICAL();
798:               									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
799:               								portEXIT_CRITICAL();
800:               							}
801:               						}
802:               						#endif
803:               
804:               						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
805:               						portYIELD_WITHIN_API();
806:               					}
807:               				}
808:               				else
809:               				{
810:               					taskEXIT_CRITICAL();
811:               					traceQUEUE_RECEIVE_FAILED( pxQueue );
812:               					return errQUEUE_EMPTY;
813:               				}
814:               			}
815:               			taskEXIT_CRITICAL();
816:               		}
817:               	}
818:               
819:               
820:               #endif /* configUSE_ALTERNATIVE_API */
821:               /*-----------------------------------------------------------*/
822:               
823:               signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
824:               {
000E6A  FA000C     LNK #0xC
000E6C  980720     MOV W0, [W14+4]
000E6E  980731     MOV W1, [W14+6]
000E70  980742     MOV W2, [W14+8]
000E72  980753     MOV W3, [W14+10]
825:               signed portBASE_TYPE xReturn;
826:               unsigned portBASE_TYPE uxSavedInterruptStatus;
827:               
828:               	configASSERT( pxQueue );
829:               	configASSERT( pxHigherPriorityTaskWoken );
830:               	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
831:               
832:               	/* Similar to xQueueGenericSend, except we don't block if there is no room
833:               	in the queue.  Also we don't directly wake a task that was blocked on a
834:               	queue read, instead we return a flag to say whether a context switch is
835:               	required or not (i.e. has a task with a higher priority than us been woken
836:               	by this	post). */
837:               	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000E74  EB0000     CLR W0
000E76  780F00     MOV W0, [W14]
838:               	{
839:               		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
000E78  90002E     MOV [W14+4], W0
000E7A  9008E0     MOV [W0+28], W1
000E7C  90002E     MOV [W14+4], W0
000E7E  900870     MOV [W0+30], W0
000E80  508F80     SUB W1, W0, [W15]
000E82  31001D     BRA C, 0xEBE
840:               		{
841:               			traceQUEUE_SEND_FROM_ISR( pxQueue );
842:               
843:               			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
000E84  90015E     MOV [W14+10], W2
000E86  9000BE     MOV [W14+6], W1
000E88  90002E     MOV [W14+4], W0
000E8A  0700F7     RCALL prvCopyDataToQueue
844:               
845:               			/* If the queue is locked we do not alter the event list.  This will
846:               			be done when the queue is unlocked later. */
847:               			if( pxQueue->xTxLock == queueUNLOCKED )
000E8C  90002E     MOV [W14+4], W0
000E8E  901020     MOV [W0+36], W0
000E90  400FE1     ADD W0, #0x1, [W15]
000E92  3A000D     BRA NZ, 0xEAE
848:               			{
849:               				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000E94  90002E     MOV [W14+4], W0
000E96  900810     MOV [W0+18], W0
000E98  E00000     CP0 W0
000E9A  32000E     BRA Z, 0xEB8
850:               				{
851:               					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000E9C  90002E     MOV [W14+4], W0
000E9E  400072     ADD W0, #0x12, W0
000EA0  07FD8E     RCALL xTaskRemoveFromEventList
000EA2  E00000     CP0 W0
000EA4  320009     BRA Z, 0xEB8
852:               					{
853:               						/* The task waiting has a higher priority so record that a
854:               						context	switch is required. */
855:               						*pxHigherPriorityTaskWoken = pdTRUE;
000EA6  9000CE     MOV [W14+8], W1
000EA8  200010     MOV #0x1, W0
000EAA  780880     MOV W0, [W1]
000EAC  370005     BRA 0xEB8
856:               					}
857:               				}
858:               			}
859:               			else
860:               			{
861:               				/* Increment the lock count so the task that unlocks the queue
862:               				knows that data was posted while it was locked. */
863:               				++( pxQueue->xTxLock );
000EAE  90002E     MOV [W14+4], W0
000EB0  901020     MOV [W0+36], W0
000EB2  E80080     INC W0, W1
000EB4  90002E     MOV [W14+4], W0
000EB6  981021     MOV W1, [W0+36]
864:               			}
865:               
866:               			xReturn = pdPASS;
000EB8  200010     MOV #0x1, W0
000EBA  980710     MOV W0, [W14+2]
000EBC  370002     BRA 0xEC2
867:               		}
868:               		else
869:               		{
870:               			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
871:               			xReturn = errQUEUE_FULL;
000EBE  EB0000     CLR W0
000EC0  980710     MOV W0, [W14+2]
872:               		}
873:               	}
874:               	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
875:               
876:               	return xReturn;
000EC2  90001E     MOV [W14+2], W0
877:               }
000EC4  FA8000     ULNK
000EC6  060000     RETURN
878:               /*-----------------------------------------------------------*/
879:               
880:               signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
881:               {
000EC8  FA0012     LNK #0x12
000ECA  980740     MOV W0, [W14+8]
000ECC  980751     MOV W1, [W14+10]
000ECE  980762     MOV W2, [W14+12]
000ED0  980773     MOV W3, [W14+14]
882:               signed portBASE_TYPE xEntryTimeSet = pdFALSE;
000ED2  EB0000     CLR W0
000ED4  980710     MOV W0, [W14+2]
000ED6  370000     BRA 0xED8
883:               xTimeOutType xTimeOut;
884:               signed char *pcOriginalReadPosition;
885:               
886:               	configASSERT( pxQueue );
887:               	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
888:               
889:               	/* This function relaxes the coding standard somewhat to allow return
890:               	statements within the function itself.  This is done in the interest
891:               	of execution time efficiency. */
892:               
893:               	for( ;; )
894:               	{
895:               		taskENTER_CRITICAL();
000ED8  0704F7     RCALL vPortEnterCritical
896:               		{
897:               			/* Is there data in the queue now?  To be running we must be
898:               			the highest priority task wanting to access the queue. */
899:               			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
000EDA  90004E     MOV [W14+8], W0
000EDC  900860     MOV [W0+28], W0
000EDE  E00000     CP0 W0
000EE0  320036     BRA Z, 0xF4E
900:               			{
901:               				/* Remember our read position in case we are just peeking. */
902:               				pcOriginalReadPosition = pxQueue->pcReadFrom;
000EE2  90004E     MOV [W14+8], W0
000EE4  9000B0     MOV [W0+6], W1
000EE6  780F01     MOV W1, [W14]
903:               
904:               				prvCopyDataFromQueue( pxQueue, pvBuffer );
000EE8  9000DE     MOV [W14+10], W1
000EEA  90004E     MOV [W14+8], W0
000EEC  070115     RCALL prvCopyDataFromQueue
905:               
906:               				if( xJustPeeking == pdFALSE )
000EEE  90007E     MOV [W14+14], W0
000EF0  E00000     CP0 W0
000EF2  3A001A     BRA NZ, 0xF28
907:               				{
908:               					traceQUEUE_RECEIVE( pxQueue );
909:               
910:               					/* We are actually removing data. */
911:               					--( pxQueue->uxMessagesWaiting );
000EF4  90004E     MOV [W14+8], W0
000EF6  900860     MOV [W0+28], W0
000EF8  E90080     DEC W0, W1
000EFA  90004E     MOV [W14+8], W0
000EFC  980861     MOV W1, [W0+28]
912:               
913:               					#if ( configUSE_MUTEXES == 1 )
914:               					{
915:               						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
000EFE  90004E     MOV [W14+8], W0
000F00  780010     MOV [W0], W0
000F02  E00000     CP0 W0
000F04  3A0004     BRA NZ, 0xF0E
916:               						{
917:               							/* Record the information required to implement
918:               							priority inheritance should it become necessary. */
919:               							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
000F06  07FE66     RCALL xTaskGetCurrentTaskHandle
000F08  780080     MOV W0, W1
000F0A  90004E     MOV [W14+8], W0
000F0C  980011     MOV W1, [W0+2]
920:               						}
921:               					}
922:               					#endif
923:               
924:               					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000F0E  90004E     MOV [W14+8], W0
000F10  900040     MOV [W0+8], W0
000F12  E00000     CP0 W0
000F14  320018     BRA Z, 0xF46
925:               					{
926:               						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
000F16  90004E     MOV [W14+8], W0
000F18  400068     ADD W0, #0x8, W0
000F1A  07FD51     RCALL xTaskRemoveFromEventList
000F1C  500FE1     SUB W0, #0x1, [W15]
000F1E  3A0013     BRA NZ, 0xF46
927:               						{
928:               							portYIELD_WITHIN_API();
000F20  021C5C     CALL _vPortYield
000F22  000000     NOP
000F24  000000     NOP
000F26  37000F     BRA 0xF46
929:               						}
930:               					}
931:               				}
932:               				else
933:               				{
934:               					traceQUEUE_PEEK( pxQueue );
935:               
936:               					/* We are not removing the data, so reset our read
937:               					pointer. */
938:               					pxQueue->pcReadFrom = pcOriginalReadPosition;
000F28  90004E     MOV [W14+8], W0
000F2A  78009E     MOV [W14], W1
000F2C  980031     MOV W1, [W0+6]
939:               
940:               					/* The data is being left in the queue, so see if there are
941:               					any other tasks waiting for the data. */
942:               					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000F2E  90004E     MOV [W14+8], W0
000F30  900810     MOV [W0+18], W0
000F32  E00000     CP0 W0
000F34  320008     BRA Z, 0xF46
943:               					{
944:               						/* Tasks that are removed from the event list will get added to
945:               						the pending ready list as the scheduler is still suspended. */
946:               						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000F36  90004E     MOV [W14+8], W0
000F38  400072     ADD W0, #0x12, W0
000F3A  07FD41     RCALL xTaskRemoveFromEventList
000F3C  E00000     CP0 W0
000F3E  320003     BRA Z, 0xF46
947:               						{
948:               							/* The task waiting has a higher priority than this task. */
949:               							portYIELD_WITHIN_API();
000F40  021C5C     CALL _vPortYield
000F42  000000     NOP
000F44  000000     NOP
950:               						}
951:               					}
952:               
953:               				}
954:               
955:               				taskEXIT_CRITICAL();
000F46  0704CA     RCALL vPortExitCritical
956:               				return pdPASS;
000F48  200010     MOV #0x1, W0
000F4A  980F00     MOV W0, [W14+16]
000F4C  370048     BRA 0xFDE
957:               			}
958:               			else
959:               			{
960:               				if( xTicksToWait == ( portTickType ) 0 )
000F4E  90006E     MOV [W14+12], W0
000F50  E00000     CP0 W0
000F52  3A0004     BRA NZ, 0xF5C
961:               				{
962:               					/* The queue was empty and no block time is specified (or
963:               					the block time has expired) so leave now. */
964:               					taskEXIT_CRITICAL();
000F54  0704C3     RCALL vPortExitCritical
965:               					traceQUEUE_RECEIVE_FAILED( pxQueue );
966:               					return errQUEUE_EMPTY;
000F56  EB0080     CLR W1
000F58  980F01     MOV W1, [W14+16]
000F5A  370041     BRA 0xFDE
967:               				}
968:               				else if( xEntryTimeSet == pdFALSE )
000F5C  90001E     MOV [W14+2], W0
000F5E  E00000     CP0 W0
000F60  3A0004     BRA NZ, 0xF6A
969:               				{
970:               					/* The queue was empty and a block time was specified so
971:               					configure the timeout structure. */
972:               					vTaskSetTimeOutState( &xTimeOut );
000F62  470064     ADD W14, #0x4, W0
000F64  07FD60     RCALL vTaskSetTimeOutState
973:               					xEntryTimeSet = pdTRUE;
000F66  200010     MOV #0x1, W0
000F68  980710     MOV W0, [W14+2]
974:               				}
975:               			}
976:               		}
977:               		taskEXIT_CRITICAL();
000F6A  0704B8     RCALL vPortExitCritical
978:               
979:               		/* Interrupts and other tasks can send to and receive from the queue
980:               		now the critical section has been exited. */
981:               
982:               		vTaskSuspendAll();
000F6C  07FC19     RCALL vTaskSuspendAll
983:               		prvLockQueue( pxQueue );
000F6E  0704AC     RCALL vPortEnterCritical
000F70  90004E     MOV [W14+8], W0
000F72  901010     MOV [W0+34], W0
000F74  400FE1     ADD W0, #0x1, [W15]
000F76  3A0003     BRA NZ, 0xF7E
000F78  9000CE     MOV [W14+8], W1
000F7A  EB0000     CLR W0
000F7C  981090     MOV W0, [W1+34]
000F7E  90004E     MOV [W14+8], W0
000F80  901020     MOV [W0+36], W0
000F82  400FE1     ADD W0, #0x1, [W15]
000F84  3A0003     BRA NZ, 0xF8C
000F86  9000CE     MOV [W14+8], W1
000F88  EB0000     CLR W0
000F8A  9810A0     MOV W0, [W1+36]
000F8C  0704A7     RCALL vPortExitCritical
984:               
985:               		/* Update the timeout state to see if it has expired yet. */
986:               		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
000F8E  4700EC     ADD W14, #0xC, W1
000F90  470064     ADD W14, #0x4, W0
000F92  07FD53     RCALL xTaskCheckForTimeOut
000F94  E00000     CP0 W0
000F96  3A001E     BRA NZ, 0xFD4
987:               		{
988:               			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
000F98  90004E     MOV [W14+8], W0
000F9A  070114     RCALL prvIsQueueEmpty
000F9C  E00000     CP0 W0
000F9E  320016     BRA Z, 0xFCC
989:               			{
990:               				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
991:               
992:               				#if ( configUSE_MUTEXES == 1 )
993:               				{
994:               					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
000FA0  90004E     MOV [W14+8], W0
000FA2  780010     MOV [W0], W0
000FA4  E00000     CP0 W0
000FA6  3A0005     BRA NZ, 0xFB2
995:               					{
996:               						portENTER_CRITICAL();
000FA8  07048F     RCALL vPortEnterCritical
997:               						{
998:               							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
000FAA  90004E     MOV [W14+8], W0
000FAC  900010     MOV [W0+2], W0
000FAE  07FE18     RCALL vTaskPriorityInherit
999:               						}
1000:              						portEXIT_CRITICAL();
000FB0  070495     RCALL vPortExitCritical
1001:              					}
1002:              				}
1003:              				#endif
1004:              
1005:              				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
000FB2  9000EE     MOV [W14+12], W1
000FB4  90004E     MOV [W14+8], W0
000FB6  400072     ADD W0, #0x12, W0
000FB8  07FCE9     RCALL vTaskPlaceOnEventList
1006:              				prvUnlockQueue( pxQueue );
000FBA  90004E     MOV [W14+8], W0
000FBC  0700CD     RCALL prvUnlockQueue
1007:              				if( xTaskResumeAll() == pdFALSE )
000FBE  07FBF6     RCALL xTaskResumeAll
000FC0  E00000     CP0 W0
000FC2  3AFF8A     BRA NZ, 0xED8
1008:              				{
1009:              					portYIELD_WITHIN_API();
000FC4  021C5C     CALL _vPortYield
000FC6  000000     NOP
000FC8  000000     NOP
000FCA  37FF86     BRA 0xED8
1010:              				}
1011:              			}
1012:              			else
1013:              			{
1014:              				/* Try again. */
1015:              				prvUnlockQueue( pxQueue );
000FCC  90004E     MOV [W14+8], W0
000FCE  0700C4     RCALL prvUnlockQueue
1016:              				( void ) xTaskResumeAll();
000FD0  07FBED     RCALL xTaskResumeAll
1017:              			}
1018:              		}
1019:              		else
1020:              		{
1021:              			prvUnlockQueue( pxQueue );
000FD4  90004E     MOV [W14+8], W0
000FD6  0700C0     RCALL prvUnlockQueue
1022:              			( void ) xTaskResumeAll();
000FD8  07FBE9     RCALL xTaskResumeAll
1023:              			traceQUEUE_RECEIVE_FAILED( pxQueue );
1024:              			return errQUEUE_EMPTY;
000FDA  EB0000     CLR W0
000FDC  980F00     MOV W0, [W14+16]
000FDE  90080E     MOV [W14+16], W0
1025:              		}
1026:              	}
000FD2  37FF82     BRA 0xED8
1027:              }
000FE0  FA8000     ULNK
000FE2  060000     RETURN
1028:              /*-----------------------------------------------------------*/
1029:              
1030:              signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
1031:              {
000FE4  FA000A     LNK #0xA
000FE6  980720     MOV W0, [W14+4]
000FE8  980731     MOV W1, [W14+6]
000FEA  980742     MOV W2, [W14+8]
1032:              signed portBASE_TYPE xReturn;
1033:              unsigned portBASE_TYPE uxSavedInterruptStatus;
1034:              
1035:              	configASSERT( pxQueue );
1036:              	configASSERT( pxTaskWoken );
1037:              	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
1038:              
1039:              	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000FEC  EB0000     CLR W0
000FEE  780F00     MOV W0, [W14]
1040:              	{
1041:              		/* We cannot block from an ISR, so check there is data available. */
1042:              		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
000FF0  90002E     MOV [W14+4], W0
000FF2  900860     MOV [W0+28], W0
000FF4  E00000     CP0 W0
000FF6  320021     BRA Z, 0x103A
1043:              		{
1044:              			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1045:              
1046:              			prvCopyDataFromQueue( pxQueue, pvBuffer );
000FF8  9000BE     MOV [W14+6], W1
000FFA  90002E     MOV [W14+4], W0
000FFC  07008D     RCALL prvCopyDataFromQueue
1047:              			--( pxQueue->uxMessagesWaiting );
000FFE  90002E     MOV [W14+4], W0
001000  900860     MOV [W0+28], W0
001002  E90080     DEC W0, W1
001004  90002E     MOV [W14+4], W0
001006  980861     MOV W1, [W0+28]
1048:              
1049:              			/* If the queue is locked we will not modify the event list.  Instead
1050:              			we update the lock count so the task that unlocks the queue will know
1051:              			that an ISR has removed data while the queue was locked. */
1052:              			if( pxQueue->xRxLock == queueUNLOCKED )
001008  90002E     MOV [W14+4], W0
00100A  901010     MOV [W0+34], W0
00100C  400FE1     ADD W0, #0x1, [W15]
00100E  3A000D     BRA NZ, 0x102A
1053:              			{
1054:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
001010  90002E     MOV [W14+4], W0
001012  900040     MOV [W0+8], W0
001014  E00000     CP0 W0
001016  32000E     BRA Z, 0x1034
1055:              				{
1056:              					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
001018  90002E     MOV [W14+4], W0
00101A  400068     ADD W0, #0x8, W0
00101C  07FCD0     RCALL xTaskRemoveFromEventList
00101E  E00000     CP0 W0
001020  320009     BRA Z, 0x1034
1057:              					{
1058:              						/* The task waiting has a higher priority than us so
1059:              						force a context switch. */
1060:              						*pxTaskWoken = pdTRUE;
001022  9000CE     MOV [W14+8], W1
001024  200010     MOV #0x1, W0
001026  780880     MOV W0, [W1]
001028  370005     BRA 0x1034
1061:              					}
1062:              				}
1063:              			}
1064:              			else
1065:              			{
1066:              				/* Increment the lock count so the task that unlocks the queue
1067:              				knows that data was removed while it was locked. */
1068:              				++( pxQueue->xRxLock );
00102A  90002E     MOV [W14+4], W0
00102C  901010     MOV [W0+34], W0
00102E  E80080     INC W0, W1
001030  90002E     MOV [W14+4], W0
001032  981011     MOV W1, [W0+34]
1069:              			}
1070:              
1071:              			xReturn = pdPASS;
001034  200010     MOV #0x1, W0
001036  980710     MOV W0, [W14+2]
001038  370002     BRA 0x103E
1072:              		}
1073:              		else
1074:              		{
1075:              			xReturn = pdFAIL;
00103A  EB0000     CLR W0
00103C  980710     MOV W0, [W14+2]
1076:              			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1077:              		}
1078:              	}
1079:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1080:              
1081:              	return xReturn;
00103E  90001E     MOV [W14+2], W0
1082:              }
001040  FA8000     ULNK
001042  060000     RETURN
1083:              /*-----------------------------------------------------------*/
1084:              
1085:              unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
1086:              {
001044  FA0004     LNK #0x4
001046  980710     MOV W0, [W14+2]
1087:              unsigned portBASE_TYPE uxReturn;
1088:              
1089:              	configASSERT( pxQueue );
1090:              
1091:              	taskENTER_CRITICAL();
001048  07043F     RCALL vPortEnterCritical
1092:              		uxReturn = pxQueue->uxMessagesWaiting;
00104A  90001E     MOV [W14+2], W0
00104C  9008E0     MOV [W0+28], W1
00104E  780F01     MOV W1, [W14]
1093:              	taskEXIT_CRITICAL();
001050  070445     RCALL vPortExitCritical
1094:              
1095:              	return uxReturn;
001052  78001E     MOV [W14], W0
1096:              }
001054  FA8000     ULNK
001056  060000     RETURN
1097:              /*-----------------------------------------------------------*/
1098:              
1099:              unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
1100:              {
001058  FA0004     LNK #0x4
00105A  980710     MOV W0, [W14+2]
1101:              unsigned portBASE_TYPE uxReturn;
1102:              
1103:              	configASSERT( pxQueue );
1104:              
1105:              	uxReturn = pxQueue->uxMessagesWaiting;
00105C  90001E     MOV [W14+2], W0
00105E  9008E0     MOV [W0+28], W1
001060  780F01     MOV W1, [W14]
1106:              
1107:              	return uxReturn;
001062  78001E     MOV [W14], W0
1108:              }
001064  FA8000     ULNK
001066  060000     RETURN
1109:              /*-----------------------------------------------------------*/
1110:              
1111:              void vQueueDelete( xQueueHandle pxQueue )
1112:              {
001068  FA0002     LNK #0x2
00106A  780F00     MOV W0, [W14]
1113:              	configASSERT( pxQueue );
1114:              
1115:              	traceQUEUE_DELETE( pxQueue );
1116:              	vQueueUnregisterQueue( pxQueue );
1117:              	vPortFree( pxQueue->pcHead );
00106C  78001E     MOV [W14], W0
00106E  780010     MOV [W0], W0
001070  070383     RCALL vPortFree
1118:              	vPortFree( pxQueue );
001072  78001E     MOV [W14], W0
001074  070381     RCALL vPortFree
1119:              }
001076  FA8000     ULNK
001078  060000     RETURN
1120:              /*-----------------------------------------------------------*/
1121:              
1122:              #if ( configUSE_TRACE_FACILITY == 1 )
1123:              
1124:              	unsigned char ucQueueGetQueueNumber( xQueueHandle pxQueue )
1125:              	{
1126:              		return pxQueue->ucQueueNumber;
1127:              	}
1128:              
1129:              #endif
1130:              /*-----------------------------------------------------------*/
1131:              
1132:              #if ( configUSE_TRACE_FACILITY == 1 )
1133:              
1134:              	void vQueueSetQueueNumber( xQueueHandle pxQueue, unsigned char ucQueueNumber )
1135:              	{
1136:              		pxQueue->ucQueueNumber = ucQueueNumber;
1137:              	}
1138:              
1139:              #endif
1140:              /*-----------------------------------------------------------*/
1141:              
1142:              #if ( configUSE_TRACE_FACILITY == 1 )
1143:              
1144:              	unsigned char ucQueueGetQueueType( xQueueHandle pxQueue )
1145:              	{
1146:              		return pxQueue->ucQueueType;
1147:              	}
1148:              
1149:              #endif
1150:              /*-----------------------------------------------------------*/
1151:              
1152:              static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
1153:              {
00107A  FA0006     LNK #0x6
00107C  780F00     MOV W0, [W14]
00107E  980711     MOV W1, [W14+2]
001080  980722     MOV W2, [W14+4]
1154:              	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
001082  78001E     MOV [W14], W0
001084  901000     MOV [W0+32], W0
001086  E00000     CP0 W0
001088  3A000B     BRA NZ, 0x10A0
1155:              	{
1156:              		#if ( configUSE_MUTEXES == 1 )
1157:              		{
1158:              			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
00108A  78001E     MOV [W14], W0
00108C  780010     MOV [W0], W0
00108E  E00000     CP0 W0
001090  3A003C     BRA NZ, 0x110A
1159:              			{
1160:              				/* The mutex is no longer being held. */
1161:              				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
001092  78001E     MOV [W14], W0
001094  900010     MOV [W0+2], W0
001096  07FDDB     RCALL vTaskPriorityDisinherit
1162:              				pxQueue->pxMutexHolder = NULL;
001098  78009E     MOV [W14], W1
00109A  EB0000     CLR W0
00109C  980090     MOV W0, [W1+2]
00109E  370035     BRA 0x110A
1163:              			}
1164:              		}
1165:              		#endif
1166:              	}
1167:              	else if( xPosition == queueSEND_TO_BACK )
0010A0  90002E     MOV [W14+4], W0
0010A2  E00000     CP0 W0
0010A4  3A0018     BRA NZ, 0x10D6
1168:              	{
1169:              		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
0010A6  78001E     MOV [W14], W0
0010A8  901100     MOV [W0+32], W2
0010AA  78001E     MOV [W14], W0
0010AC  900020     MOV [W0+4], W0
0010AE  90009E     MOV [W14+2], W1
0010B0  07F931     RCALL _memcpy
1170:              		pxQueue->pcWriteTo += pxQueue->uxItemSize;
0010B2  78001E     MOV [W14], W0
0010B4  9000A0     MOV [W0+4], W1
0010B6  78001E     MOV [W14], W0
0010B8  901000     MOV [W0+32], W0
0010BA  408080     ADD W1, W0, W1
0010BC  78001E     MOV [W14], W0
0010BE  980021     MOV W1, [W0+4]
1171:              		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
0010C0  78001E     MOV [W14], W0
0010C2  9000A0     MOV [W0+4], W1
0010C4  78001E     MOV [W14], W0
0010C6  900010     MOV [W0+2], W0
0010C8  508F80     SUB W1, W0, [W15]
0010CA  39001F     BRA NC, 0x110A
1172:              		{
1173:              			pxQueue->pcWriteTo = pxQueue->pcHead;
0010CC  78001E     MOV [W14], W0
0010CE  780090     MOV [W0], W1
0010D0  78001E     MOV [W14], W0
0010D2  980021     MOV W1, [W0+4]
0010D4  37001A     BRA 0x110A
1174:              		}
1175:              	}
1176:              	else
1177:              	{
1178:              		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
0010D6  78001E     MOV [W14], W0
0010D8  901100     MOV [W0+32], W2
0010DA  78001E     MOV [W14], W0
0010DC  900030     MOV [W0+6], W0
0010DE  90009E     MOV [W14+2], W1
0010E0  07F919     RCALL _memcpy
1179:              		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
0010E2  78001E     MOV [W14], W0
0010E4  9000B0     MOV [W0+6], W1
0010E6  78001E     MOV [W14], W0
0010E8  901000     MOV [W0+32], W0
0010EA  508080     SUB W1, W0, W1
0010EC  78001E     MOV [W14], W0
0010EE  980031     MOV W1, [W0+6]
1180:              		if( pxQueue->pcReadFrom < pxQueue->pcHead )
0010F0  78001E     MOV [W14], W0
0010F2  9000B0     MOV [W0+6], W1
0010F4  78001E     MOV [W14], W0
0010F6  780010     MOV [W0], W0
0010F8  508F80     SUB W1, W0, [W15]
0010FA  310007     BRA C, 0x110A
1181:              		{
1182:              			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
0010FC  78001E     MOV [W14], W0
0010FE  900090     MOV [W0+2], W1
001100  78001E     MOV [W14], W0
001102  901000     MOV [W0+32], W0
001104  508080     SUB W1, W0, W1
001106  78001E     MOV [W14], W0
001108  980031     MOV W1, [W0+6]
1183:              		}
1184:              	}
1185:              
1186:              	++( pxQueue->uxMessagesWaiting );
00110A  78001E     MOV [W14], W0
00110C  900860     MOV [W0+28], W0
00110E  E80080     INC W0, W1
001110  78001E     MOV [W14], W0
001112  980861     MOV W1, [W0+28]
1187:              }
001114  FA8000     ULNK
001116  060000     RETURN
1188:              /*-----------------------------------------------------------*/
1189:              
1190:              static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
1191:              {
001118  FA0004     LNK #0x4
00111A  780F00     MOV W0, [W14]
00111C  980711     MOV W1, [W14+2]
1192:              	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
00111E  78001E     MOV [W14], W0
001120  780010     MOV [W0], W0
001122  E00000     CP0 W0
001124  320017     BRA Z, 0x1154
1193:              	{
1194:              		pxQueue->pcReadFrom += pxQueue->uxItemSize;
001126  78001E     MOV [W14], W0
001128  9000B0     MOV [W0+6], W1
00112A  78001E     MOV [W14], W0
00112C  901000     MOV [W0+32], W0
00112E  408080     ADD W1, W0, W1
001130  78001E     MOV [W14], W0
001132  980031     MOV W1, [W0+6]
1195:              		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
001134  78001E     MOV [W14], W0
001136  9000B0     MOV [W0+6], W1
001138  78001E     MOV [W14], W0
00113A  900010     MOV [W0+2], W0
00113C  508F80     SUB W1, W0, [W15]
00113E  390004     BRA NC, 0x1148
1196:              		{
1197:              			pxQueue->pcReadFrom = pxQueue->pcHead;
001140  78001E     MOV [W14], W0
001142  780090     MOV [W0], W1
001144  78001E     MOV [W14], W0
001146  980031     MOV W1, [W0+6]
1198:              		}
1199:              		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
001148  78001E     MOV [W14], W0
00114A  901100     MOV [W0+32], W2
00114C  78001E     MOV [W14], W0
00114E  9000B0     MOV [W0+6], W1
001150  90001E     MOV [W14+2], W0
001152  07F8E0     RCALL _memcpy
1200:              	}
1201:              }
001154  FA8000     ULNK
001156  060000     RETURN
1202:              /*-----------------------------------------------------------*/
1203:              
1204:              static void prvUnlockQueue( xQueueHandle pxQueue )
1205:              {
001158  FA0002     LNK #0x2
00115A  780F00     MOV W0, [W14]
1206:              	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1207:              
1208:              	/* The lock counts contains the number of extra data items placed or
1209:              	removed from the queue while the queue was locked.  When a queue is
1210:              	locked items can be added or removed, but the event lists cannot be
1211:              	updated. */
1212:              	taskENTER_CRITICAL();
00115C  0703B5     RCALL vPortEnterCritical
1213:              	{
1214:              		/* See if data was added to the queue while it was locked. */
1215:              		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
00115E  37000F     BRA 0x117E
00117E  78001E     MOV [W14], W0
001180  901020     MOV [W0+36], W0
001182  E00000     CP0 W0
001184  3CFFED     BRA GT, 0x1160
1216:              		{
1217:              			/* Data was posted while the queue was locked.  Are any tasks
1218:              			blocked waiting for data to become available? */
1219:              			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
001160  78001E     MOV [W14], W0
001162  900810     MOV [W0+18], W0
001164  E00000     CP0 W0
001166  32000F     BRA Z, 0x1186
1220:              			{
1221:              				/* Tasks that are removed from the event list will get added to
1222:              				the pending ready list as the scheduler is still suspended. */
1223:              				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
001168  78009E     MOV [W14], W1
00116A  408072     ADD W1, #0x12, W0
00116C  07FC28     RCALL xTaskRemoveFromEventList
00116E  E00000     CP0 W0
001170  320001     BRA Z, 0x1174
1224:              				{
1225:              					/* The task waiting has a higher priority so record that a
1226:              					context	switch is required. */
1227:              					vTaskMissedYield();
001172  07FC97     RCALL vTaskMissedYield
1228:              				}
1229:              
1230:              				--( pxQueue->xTxLock );
001174  78001E     MOV [W14], W0
001176  901020     MOV [W0+36], W0
001178  E90080     DEC W0, W1
00117A  78001E     MOV [W14], W0
00117C  981021     MOV W1, [W0+36]
1231:              			}
1232:              			else
1233:              			{
1234:              				break;
1235:              			}
1236:              		}
1237:              
1238:              		pxQueue->xTxLock = queueUNLOCKED;
001186  78009E     MOV [W14], W1
001188  EB8000     SETM W0
00118A  9810A0     MOV W0, [W1+36]
1239:              	}
1240:              	taskEXIT_CRITICAL();
00118C  0703A7     RCALL vPortExitCritical
1241:              
1242:              	/* Do the same for the Rx lock. */
1243:              	taskENTER_CRITICAL();
00118E  07039C     RCALL vPortEnterCritical
1244:              	{
1245:              		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
001190  37000F     BRA 0x11B0
0011B0  78001E     MOV [W14], W0
0011B2  901010     MOV [W0+34], W0
0011B4  E00000     CP0 W0
0011B6  3CFFED     BRA GT, 0x1192
1246:              		{
1247:              			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
001192  78001E     MOV [W14], W0
001194  900040     MOV [W0+8], W0
001196  E00000     CP0 W0
001198  32000F     BRA Z, 0x11B8
1248:              			{
1249:              				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
00119A  78009E     MOV [W14], W1
00119C  408068     ADD W1, #0x8, W0
00119E  07FC0F     RCALL xTaskRemoveFromEventList
0011A0  E00000     CP0 W0
0011A2  320001     BRA Z, 0x11A6
1250:              				{
1251:              					vTaskMissedYield();
0011A4  07FC7E     RCALL vTaskMissedYield
1252:              				}
1253:              
1254:              				--( pxQueue->xRxLock );
0011A6  78001E     MOV [W14], W0
0011A8  901010     MOV [W0+34], W0
0011AA  E90080     DEC W0, W1
0011AC  78001E     MOV [W14], W0
0011AE  981011     MOV W1, [W0+34]
1255:              			}
1256:              			else
1257:              			{
1258:              				break;
1259:              			}
1260:              		}
1261:              
1262:              		pxQueue->xRxLock = queueUNLOCKED;
0011B8  78009E     MOV [W14], W1
0011BA  EB8000     SETM W0
0011BC  981090     MOV W0, [W1+34]
1263:              	}
1264:              	taskEXIT_CRITICAL();
0011BE  07038E     RCALL vPortExitCritical
1265:              }
0011C0  FA8000     ULNK
0011C2  060000     RETURN
1266:              /*-----------------------------------------------------------*/
1267:              
1268:              static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
1269:              {
0011C4  FA0004     LNK #0x4
0011C6  980710     MOV W0, [W14+2]
1270:              signed portBASE_TYPE xReturn;
1271:              
1272:              	taskENTER_CRITICAL();
0011C8  07037F     RCALL vPortEnterCritical
1273:              		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
0011CA  90001E     MOV [W14+2], W0
0011CC  9008E0     MOV [W0+28], W1
0011CE  EB0000     CLR W0
0011D0  780F00     MOV W0, [W14]
0011D2  E00001     CP0 W1
0011D4  3A0002     BRA NZ, 0x11DA
0011D6  200010     MOV #0x1, W0
0011D8  780F00     MOV W0, [W14]
1274:              	taskEXIT_CRITICAL();
0011DA  070380     RCALL vPortExitCritical
1275:              
1276:              	return xReturn;
0011DC  78001E     MOV [W14], W0
1277:              }
0011DE  FA8000     ULNK
0011E0  060000     RETURN
1278:              /*-----------------------------------------------------------*/
1279:              
1280:              signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
1281:              {
0011E2  FA0004     LNK #0x4
0011E4  980710     MOV W0, [W14+2]
1282:              signed portBASE_TYPE xReturn;
1283:              
1284:              	configASSERT( pxQueue );
1285:              	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
0011E6  90001E     MOV [W14+2], W0
0011E8  9008E0     MOV [W0+28], W1
0011EA  EB0000     CLR W0
0011EC  780F00     MOV W0, [W14]
0011EE  E00001     CP0 W1
0011F0  3A0002     BRA NZ, 0x11F6
0011F2  200010     MOV #0x1, W0
0011F4  780F00     MOV W0, [W14]
1286:              
1287:              	return xReturn;
0011F6  78001E     MOV [W14], W0
1288:              }
0011F8  FA8000     ULNK
0011FA  060000     RETURN
1289:              /*-----------------------------------------------------------*/
1290:              
1291:              static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
1292:              {
0011FC  FA0004     LNK #0x4
0011FE  980710     MOV W0, [W14+2]
1293:              signed portBASE_TYPE xReturn;
1294:              
1295:              	taskENTER_CRITICAL();
001200  070363     RCALL vPortEnterCritical
1296:              		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
001202  90001E     MOV [W14+2], W0
001204  900960     MOV [W0+28], W2
001206  90001E     MOV [W14+2], W0
001208  9008F0     MOV [W0+30], W1
00120A  EB0000     CLR W0
00120C  780F00     MOV W0, [W14]
00120E  510F81     SUB W2, W1, [W15]
001210  3A0002     BRA NZ, 0x1216
001212  200010     MOV #0x1, W0
001214  780F00     MOV W0, [W14]
1297:              	taskEXIT_CRITICAL();
001216  070362     RCALL vPortExitCritical
1298:              
1299:              	return xReturn;
001218  78001E     MOV [W14], W0
1300:              }
00121A  FA8000     ULNK
00121C  060000     RETURN
1301:              /*-----------------------------------------------------------*/
1302:              
1303:              signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
1304:              {
00121E  FA0004     LNK #0x4
001220  980710     MOV W0, [W14+2]
1305:              signed portBASE_TYPE xReturn;
1306:              
1307:              	configASSERT( pxQueue );
1308:              	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
001222  90001E     MOV [W14+2], W0
001224  900960     MOV [W0+28], W2
001226  90001E     MOV [W14+2], W0
001228  9008F0     MOV [W0+30], W1
00122A  EB0000     CLR W0
00122C  780F00     MOV W0, [W14]
00122E  510F81     SUB W2, W1, [W15]
001230  3A0002     BRA NZ, 0x1236
001232  200010     MOV #0x1, W0
001234  780F00     MOV W0, [W14]
1309:              
1310:              	return xReturn;
001236  78001E     MOV [W14], W0
1311:              }
001238  FA8000     ULNK
00123A  060000     RETURN
1312:              /*-----------------------------------------------------------*/
1313:              
1314:              #if configUSE_CO_ROUTINES == 1
1315:              signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType xTicksToWait )
1316:              {
1317:              signed portBASE_TYPE xReturn;
1318:              
1319:              	/* If the queue is already full we may have to block.  A critical section
1320:              	is required to prevent an interrupt removing something from the queue
1321:              	between the check to see if the queue is full and blocking on the queue. */
1322:              	portDISABLE_INTERRUPTS();
1323:              	{
1324:              		if( prvIsQueueFull( pxQueue ) != pdFALSE )
1325:              		{
1326:              			/* The queue is full - do we want to block or just leave without
1327:              			posting? */
1328:              			if( xTicksToWait > ( portTickType ) 0 )
1329:              			{
1330:              				/* As this is called from a coroutine we cannot block directly, but
1331:              				return indicating that we need to block. */
1332:              				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
1333:              				portENABLE_INTERRUPTS();
1334:              				return errQUEUE_BLOCKED;
1335:              			}
1336:              			else
1337:              			{
1338:              				portENABLE_INTERRUPTS();
1339:              				return errQUEUE_FULL;
1340:              			}
1341:              		}
1342:              	}
1343:              	portENABLE_INTERRUPTS();
1344:              
1345:              	portNOP();
1346:              
1347:              	portDISABLE_INTERRUPTS();
1348:              	{
1349:              		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1350:              		{
1351:              			/* There is room in the queue, copy the data into the queue. */
1352:              			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1353:              			xReturn = pdPASS;
1354:              
1355:              			/* Were any co-routines waiting for data to become available? */
1356:              			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1357:              			{
1358:              				/* In this instance the co-routine could be placed directly
1359:              				into the ready list as we are within a critical section.
1360:              				Instead the same pending ready list mechanism is used as if
1361:              				the event were caused from within an interrupt. */
1362:              				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1363:              				{
1364:              					/* The co-routine waiting has a higher priority so record
1365:              					that a yield might be appropriate. */
1366:              					xReturn = errQUEUE_YIELD;
1367:              				}
1368:              			}
1369:              		}
1370:              		else
1371:              		{
1372:              			xReturn = errQUEUE_FULL;
1373:              		}
1374:              	}
1375:              	portENABLE_INTERRUPTS();
1376:              
1377:              	return xReturn;
1378:              }
1379:              #endif
1380:              /*-----------------------------------------------------------*/
1381:              
1382:              #if configUSE_CO_ROUTINES == 1
1383:              signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToWait )
1384:              {
1385:              signed portBASE_TYPE xReturn;
1386:              
1387:              	/* If the queue is already empty we may have to block.  A critical section
1388:              	is required to prevent an interrupt adding something to the queue
1389:              	between the check to see if the queue is empty and blocking on the queue. */
1390:              	portDISABLE_INTERRUPTS();
1391:              	{
1392:              		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
1393:              		{
1394:              			/* There are no messages in the queue, do we want to block or just
1395:              			leave with nothing? */
1396:              			if( xTicksToWait > ( portTickType ) 0 )
1397:              			{
1398:              				/* As this is a co-routine we cannot block directly, but return
1399:              				indicating that we need to block. */
1400:              				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
1401:              				portENABLE_INTERRUPTS();
1402:              				return errQUEUE_BLOCKED;
1403:              			}
1404:              			else
1405:              			{
1406:              				portENABLE_INTERRUPTS();
1407:              				return errQUEUE_FULL;
1408:              			}
1409:              		}
1410:              	}
1411:              	portENABLE_INTERRUPTS();
1412:              
1413:              	portNOP();
1414:              
1415:              	portDISABLE_INTERRUPTS();
1416:              	{
1417:              		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1418:              		{
1419:              			/* Data is available from the queue. */
1420:              			pxQueue->pcReadFrom += pxQueue->uxItemSize;
1421:              			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
1422:              			{
1423:              				pxQueue->pcReadFrom = pxQueue->pcHead;
1424:              			}
1425:              			--( pxQueue->uxMessagesWaiting );
1426:              			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1427:              
1428:              			xReturn = pdPASS;
1429:              
1430:              			/* Were any co-routines waiting for space to become available? */
1431:              			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1432:              			{
1433:              				/* In this instance the co-routine could be placed directly
1434:              				into the ready list as we are within a critical section.
1435:              				Instead the same pending ready list mechanism is used as if
1436:              				the event were caused from within an interrupt. */
1437:              				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1438:              				{
1439:              					xReturn = errQUEUE_YIELD;
1440:              				}
1441:              			}
1442:              		}
1443:              		else
1444:              		{
1445:              			xReturn = pdFAIL;
1446:              		}
1447:              	}
1448:              	portENABLE_INTERRUPTS();
1449:              
1450:              	return xReturn;
1451:              }
1452:              #endif
1453:              /*-----------------------------------------------------------*/
1454:              
1455:              
1456:              
1457:              #if configUSE_CO_ROUTINES == 1
1458:              signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
1459:              {
1460:              	/* Cannot block within an ISR so if there is no space on the queue then
1461:              	exit without doing anything. */
1462:              	if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1463:              	{
1464:              		prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1465:              
1466:              		/* We only want to wake one co-routine per ISR, so check that a
1467:              		co-routine has not already been woken. */
1468:              		if( xCoRoutinePreviouslyWoken == pdFALSE )
1469:              		{
1470:              			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1471:              			{
1472:              				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1473:              				{
1474:              					return pdTRUE;
1475:              				}
1476:              			}
1477:              		}
1478:              	}
1479:              
1480:              	return xCoRoutinePreviouslyWoken;
1481:              }
1482:              #endif
1483:              /*-----------------------------------------------------------*/
1484:              
1485:              #if configUSE_CO_ROUTINES == 1
1486:              signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE_TYPE *pxCoRoutineWoken )
1487:              {
1488:              signed portBASE_TYPE xReturn;
1489:              
1490:              	/* We cannot block from an ISR, so check there is data available. If
1491:              	not then just leave without doing anything. */
1492:              	if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
1493:              	{
1494:              		/* Copy the data from the queue. */
1495:              		pxQueue->pcReadFrom += pxQueue->uxItemSize;
1496:              		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
1497:              		{
1498:              			pxQueue->pcReadFrom = pxQueue->pcHead;
1499:              		}
1500:              		--( pxQueue->uxMessagesWaiting );
1501:              		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
1502:              
1503:              		if( ( *pxCoRoutineWoken ) == pdFALSE )
1504:              		{
1505:              			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
1506:              			{
1507:              				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
1508:              				{
1509:              					*pxCoRoutineWoken = pdTRUE;
1510:              				}
1511:              			}
1512:              		}
1513:              
1514:              		xReturn = pdPASS;
1515:              	}
1516:              	else
1517:              	{
1518:              		xReturn = pdFAIL;
1519:              	}
1520:              
1521:              	return xReturn;
1522:              }
1523:              #endif
1524:              /*-----------------------------------------------------------*/
1525:              
1526:              #if configQUEUE_REGISTRY_SIZE > 0
1527:              
1528:              	void vQueueAddToRegistry( xQueueHandle xQueue, signed char *pcQueueName )
1529:              	{
1530:              	unsigned portBASE_TYPE ux;
1531:              
1532:              		/* See if there is an empty space in the registry.  A NULL name denotes
1533:              		a free slot. */
1534:              		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZE; ux++ )
1535:              		{
1536:              			if( xQueueRegistry[ ux ].pcQueueName == NULL )
1537:              			{
1538:              				/* Store the information on this queue. */
1539:              				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
1540:              				xQueueRegistry[ ux ].xHandle = xQueue;
1541:              				break;
1542:              			}
1543:              		}
1544:              	}
1545:              
1546:              #endif
1547:              /*-----------------------------------------------------------*/
1548:              
1549:              #if configQUEUE_REGISTRY_SIZE > 0
1550:              
1551:              	static void vQueueUnregisterQueue( xQueueHandle xQueue )
1552:              	{
1553:              	unsigned portBASE_TYPE ux;
1554:              
1555:              		/* See if the handle of the queue being unregistered in actually in the
1556:              		registry. */
1557:              		for( ux = ( unsigned portBASE_TYPE ) 0U; ux < ( unsigned portBASE_TYPE ) configQUEUE_REGISTRY_SIZE; ux++ )
1558:              		{
1559:              			if( xQueueRegistry[ ux ].xHandle == xQueue )
1560:              			{
1561:              				/* Set the name to NULL to show that this slot if free again. */
1562:              				xQueueRegistry[ ux ].pcQueueName = NULL;
1563:              				break;
1564:              			}
1565:              		}
1566:              
1567:              	}
1568:              
1569:              #endif
1570:              /*-----------------------------------------------------------*/
1571:              
1572:              #if configUSE_TIMERS == 1
1573:              
1574:              	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
1575:              	{
1576:              		/* This function should not be called by application code hence the
1577:              		'Restricted' in its name.  It is not part of the public API.  It is
1578:              		designed for use by kernel code, and has special calling requirements.
1579:              		It can result in vListInsert() being called on a list that can only
1580:              		possibly ever have one item in it, so the list will be fast, but even
1581:              		so it should be called with the scheduler locked and not from a critical
1582:              		section. */
1583:              
1584:              		/* Only do anything if there are no messages in the queue.  This function
1585:              		will not actually cause the task to block, just place it on a blocked
1586:              		list.  It will not block until the scheduler is unlocked - at which
1587:              		time a yield will be performed.  If an item is added to the queue while
1588:              		the queue is locked, and the calling task blocks on the queue, then the
1589:              		calling task will be immediately unblocked when the queue is unlocked. */
1590:              		prvLockQueue( pxQueue );
1591:              		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
1592:              		{
1593:              			/* There is nothing in the queue, block for the specified period. */
1594:              			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1595:              		}
1596:              		prvUnlockQueue( pxQueue );
1597:              	}
1598:              
1599:              #endif
1600:              
---  /Users/jhiesey/Desktop/SensorNet/WellInterface/FreeRTOS/Source/portable/MemMang/heap_2.c  ----------
1:                 /*
2:                     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
3:                 	
4:                 
5:                     ***************************************************************************
6:                      *                                                                       *
7:                      *    FreeRTOS tutorial books are available in pdf and paperback.        *
8:                      *    Complete, revised, and edited pdf reference manuals are also       *
9:                      *    available.                                                         *
10:                     *                                                                       *
11:                     *    Purchasing FreeRTOS documentation will not only help you, by       *
12:                     *    ensuring you get running as quickly as possible and with an        *
13:                     *    in-depth knowledge of how to use FreeRTOS, it will also help       *
14:                     *    the FreeRTOS project to continue with its mission of providing     *
15:                     *    professional grade, cross platform, de facto standard solutions    *
16:                     *    for microcontrollers - completely free of charge!                  *
17:                     *                                                                       *
18:                     *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
19:                     *                                                                       *
20:                     *    Thank you for using FreeRTOS, and thank you for your support!      *
21:                     *                                                                       *
22:                    ***************************************************************************
23:                
24:                
25:                    This file is part of the FreeRTOS distribution.
26:                
27:                    FreeRTOS is free software; you can redistribute it and/or modify it under
28:                    the terms of the GNU General Public License (version 2) as published by the
29:                    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
30:                    >>>NOTE<<< The modification to the GPL is included to allow you to
31:                    distribute a combined work that includes FreeRTOS without being obliged to
32:                    provide the source code for proprietary components outside of the FreeRTOS
33:                    kernel.  FreeRTOS is distributed in the hope that it will be useful, but
34:                    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
35:                    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
36:                    more details. You should have received a copy of the GNU General Public
37:                    License and the FreeRTOS license exception along with FreeRTOS; if not it
38:                    can be viewed here: http://www.freertos.org/a00114.html and also obtained
39:                    by writing to Richard Barry, contact details for whom are available on the
40:                    FreeRTOS WEB site.
41:                
42:                    1 tab == 4 spaces!
43:                
44:                    http://www.FreeRTOS.org - Documentation, latest information, license and
45:                    contact details.
46:                
47:                    http://www.SafeRTOS.com - A version that is certified for use in safety
48:                    critical systems.
49:                
50:                    http://www.OpenRTOS.com - Commercial support, development, porting,
51:                    licensing and training services.
52:                */
53:                
54:                /*
55:                 * A sample implementation of pvPortMalloc() and vPortFree() that permits
56:                 * allocated blocks to be freed, but does not combine adjacent free blocks
57:                 * into a single larger block.
58:                 *
59:                 * See heap_1.c and heap_3.c for alternative implementations, and the memory
60:                 * management pages of http://www.FreeRTOS.org for more information.
61:                 */
62:                #include <stdlib.h>
63:                
64:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
65:                all the API functions to use the MPU wrappers.  That should only be done when
66:                task.h is included from an application file. */
67:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
68:                
69:                #include "FreeRTOS.h"
70:                #include "task.h"
71:                
72:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
73:                
74:                /* Allocate the memory for the heap.  The struct is used to force byte
75:                alignment without using any non-portable code. */
76:                static union xRTOS_HEAP
77:                {
78:                	#if portBYTE_ALIGNMENT == 8
79:                		volatile portDOUBLE dDummy;
80:                	#else
81:                		volatile unsigned long ulDummy;
82:                	#endif
83:                	unsigned char ucHeap[ configTOTAL_HEAP_SIZE ];
84:                } xHeap;
85:                
86:                /* Define the linked list structure.  This is used to link free blocks in order
87:                of their size. */
88:                typedef struct A_BLOCK_LINK
89:                {
90:                	struct A_BLOCK_LINK *pxNextFreeBlock;	/*<< The next free block in the list. */
91:                	size_t xBlockSize;						/*<< The size of the free block. */
92:                } xBlockLink;
93:                
94:                
95:                static const unsigned short  heapSTRUCT_SIZE	= ( sizeof( xBlockLink ) + portBYTE_ALIGNMENT - ( sizeof( xBlockLink ) % portBYTE_ALIGNMENT ) );
96:                #define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( heapSTRUCT_SIZE * 2 ) )
97:                
98:                /* Create a couple of list links to mark the start and end of the list. */
99:                static xBlockLink xStart, xEnd;
100:               
101:               /* Keeps track of the number of free bytes remaining, but says nothing about
102:               fragmentation. */
103:               static size_t xFreeBytesRemaining = configTOTAL_HEAP_SIZE;
104:               
105:               /* STATIC FUNCTIONS ARE DEFINED AS MACROS TO MINIMIZE THE FUNCTION CALL DEPTH. */
106:               
107:               /*
108:                * Insert a block into the list of free blocks - which is ordered by size of
109:                * the block.  Small blocks at the start of the list and large blocks at the end
110:                * of the list.
111:                */
112:               #define prvInsertBlockIntoFreeList( pxBlockToInsert )								\
113:               {																					\
114:               xBlockLink *pxIterator;																\
115:               size_t xBlockSize;																	\
116:               																					\
117:               	xBlockSize = pxBlockToInsert->xBlockSize;										\
118:               																					\
119:               	/* Iterate through the list until a block is found that has a larger size */	\
120:               	/* than the block we are inserting. */											\
121:               	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock->xBlockSize < xBlockSize; pxIterator = pxIterator->pxNextFreeBlock )	\
122:               	{																				\
123:               		/* There is nothing to do here - just iterate to the correct position. */	\
124:               	}																				\
125:               																					\
126:               	/* Update the list to include the block being inserted in the correct */		\
127:               	/* position. */																	\
128:               	pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;					\
129:               	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
130:               }
131:               /*-----------------------------------------------------------*/
132:               
133:               #define prvHeapInit()																\
134:               {																					\
135:               xBlockLink *pxFirstFreeBlock;														\
136:               																					\
137:               	/* xStart is used to hold a pointer to the first item in the list of free */	\
138:               	/* blocks.  The void cast is used to prevent compiler warnings. */				\
139:               	xStart.pxNextFreeBlock = ( void * ) xHeap.ucHeap;								\
140:               	xStart.xBlockSize = ( size_t ) 0;												\
141:               																					\
142:               	/* xEnd is used to mark the end of the list of free blocks. */					\
143:               	xEnd.xBlockSize = configTOTAL_HEAP_SIZE;										\
144:               	xEnd.pxNextFreeBlock = NULL;													\
145:               																					\
146:               	/* To start with there is a single free block that is sized to take up the		\
147:               	entire heap space. */															\
148:               	pxFirstFreeBlock = ( void * ) xHeap.ucHeap;										\
149:               	pxFirstFreeBlock->xBlockSize = configTOTAL_HEAP_SIZE;							\
150:               	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
151:               }
152:               /*-----------------------------------------------------------*/
153:               
154:               void *pvPortMalloc( size_t xWantedSize )
155:               {
00166E  FA0010     LNK #0x10
001670  980770     MOV W0, [W14+14]
156:               xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
157:               static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
158:               void *pvReturn = NULL;
001672  EB0000     CLR W0
001674  980730     MOV W0, [W14+6]
159:               
160:               	vTaskSuspendAll();
001676  07F894     RCALL vTaskSuspendAll
161:               	{
162:               		/* If this is the first call to malloc then the heap will require
163:               		initialisation to setup the list of free blocks. */
164:               		if( xHeapHasBeenInitialised == pdFALSE )
001678  804280     MOV xHeapHasBeenInitialised, W0
00167A  E00000     CP0 W0
00167C  3A0012     BRA NZ, 0x16A2
165:               		{
166:               			prvHeapInit();
00167E  208520     MOV #0x852, W0
001680  88E290     MOV W0, xStart
001682  EB0000     CLR W0
001684  88E2A0     MOV W0, 0x1C54
001686  214000     MOV #0x1400, W0
001688  88E2C0     MOV W0, 0x1C58
00168A  EB0000     CLR W0
00168C  88E2B0     MOV W0, xEnd
00168E  208520     MOV #0x852, W0
001690  980720     MOV W0, [W14+4]
001692  9000AE     MOV [W14+4], W1
001694  214000     MOV #0x1400, W0
001696  980090     MOV W0, [W1+2]
001698  9000AE     MOV [W14+4], W1
00169A  21C560     MOV #0x1C56, W0
00169C  780880     MOV W0, [W1]
167:               			xHeapHasBeenInitialised = pdTRUE;
00169E  200010     MOV #0x1, W0
0016A0  884280     MOV W0, xHeapHasBeenInitialised
168:               		}
169:               
170:               		/* The wanted size is increased so it can contain a xBlockLink
171:               		structure in addition to the requested amount of bytes. */
172:               		if( xWantedSize > 0 )
0016A2  90007E     MOV [W14+14], W0
0016A4  E00000     CP0 W0
0016A6  32000D     BRA Z, 0x16C2
173:               		{
174:               			xWantedSize += heapSTRUCT_SIZE;
0016A8  841C51     MOV 0x838A, W1
0016AA  90007E     MOV [W14+14], W0
0016AC  400001     ADD W0, W1, W0
0016AE  980770     MOV W0, [W14+14]
175:               
176:               			/* Ensure that blocks are always aligned to the required number of bytes. */
177:               			if( xWantedSize & portBYTE_ALIGNMENT_MASK )
0016B0  90007E     MOV [W14+14], W0
0016B2  600061     AND W0, #0x1, W0
0016B4  E00400     CP0.B W0
0016B6  320005     BRA Z, 0x16C2
178:               			{
179:               				/* Byte alignment required. */
180:               				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
0016B8  9000FE     MOV [W14+14], W1
0016BA  2FFFE0     MOV #0xFFFE, W0
0016BC  608000     AND W1, W0, W0
0016BE  E88000     INC2 W0, W0
0016C0  980770     MOV W0, [W14+14]
181:               			}
182:               		}
183:               
184:               		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
0016C2  90007E     MOV [W14+14], W0
0016C4  E00000     CP0 W0
0016C6  320054     BRA Z, 0x1770
0016C8  9000FE     MOV [W14+14], W1
0016CA  213FF0     MOV #0x13FF, W0
0016CC  508F80     SUB W1, W0, [W15]
0016CE  3E0050     BRA GTU, 0x1770
185:               		{
186:               			/* Blocks are stored in byte order - traverse the list from the start
187:               			(smallest) block until one of adequate size is found. */
188:               			pxPreviousBlock = &xStart;
0016D0  21C520     MOV #0x1C52, W0
0016D2  980750     MOV W0, [W14+10]
189:               			pxBlock = xStart.pxNextFreeBlock;
0016D4  80E290     MOV xStart, W0
0016D6  980760     MOV W0, [W14+12]
190:               			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
0016D8  370005     BRA 0x16E4
0016E4  90006E     MOV [W14+12], W0
0016E6  900090     MOV [W0+2], W1
0016E8  90007E     MOV [W14+14], W0
0016EA  508F80     SUB W1, W0, [W15]
0016EC  310004     BRA C, 0x16F6
0016EE  90006E     MOV [W14+12], W0
0016F0  780010     MOV [W0], W0
0016F2  E00000     CP0 W0
0016F4  3AFFF2     BRA NZ, 0x16DA
191:               			{
192:               				pxPreviousBlock = pxBlock;
0016DA  9000EE     MOV [W14+12], W1
0016DC  980751     MOV W1, [W14+10]
193:               				pxBlock = pxBlock->pxNextFreeBlock;
0016DE  90006E     MOV [W14+12], W0
0016E0  780090     MOV [W0], W1
0016E2  980761     MOV W1, [W14+12]
194:               			}
195:               
196:               			/* If we found the end marker then a block of adequate size was not found. */
197:               			if( pxBlock != &xEnd )
0016F6  9000EE     MOV [W14+12], W1
0016F8  21C560     MOV #0x1C56, W0
0016FA  508F80     SUB W1, W0, [W15]
0016FC  320039     BRA Z, 0x1770
198:               			{
199:               				/* Return the memory space - jumping over the xBlockLink structure
200:               				at its start. */
201:               				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
0016FE  90005E     MOV [W14+10], W0
001700  780010     MOV [W0], W0
001702  780080     MOV W0, W1
001704  841C50     MOV 0x838A, W0
001706  408000     ADD W1, W0, W0
001708  980730     MOV W0, [W14+6]
202:               
203:               				/* This block is being returned for use so must be taken our of the
204:               				list of free blocks. */
205:               				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
00170A  90006E     MOV [W14+12], W0
00170C  780090     MOV [W0], W1
00170E  90005E     MOV [W14+10], W0
001710  780801     MOV W1, [W0]
206:               
207:               				/* If the block is larger than required it can be split into two. */
208:               				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
001712  90006E     MOV [W14+12], W0
001714  900090     MOV [W0+2], W1
001716  90007E     MOV [W14+14], W0
001718  508080     SUB W1, W0, W1
00171A  841C50     MOV 0x838A, W0
00171C  400000     ADD W0, W0, W0
00171E  508F80     SUB W1, W0, [W15]
001720  360022     BRA LEU, 0x1766
209:               				{
210:               					/* This block is to be split into two.  Create a new block
211:               					following the number of bytes requested. The void cast is
212:               					used to prevent byte alignment warnings from the compiler. */
213:               					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
001722  9000EE     MOV [W14+12], W1
001724  90007E     MOV [W14+14], W0
001726  408000     ADD W1, W0, W0
001728  980740     MOV W0, [W14+8]
214:               
215:               					/* Calculate the sizes of two blocks split from the single
216:               					block. */
217:               					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
00172A  90006E     MOV [W14+12], W0
00172C  900090     MOV [W0+2], W1
00172E  90007E     MOV [W14+14], W0
001730  508080     SUB W1, W0, W1
001732  90004E     MOV [W14+8], W0
001734  980011     MOV W1, [W0+2]
218:               					pxBlock->xBlockSize = xWantedSize;
001736  90006E     MOV [W14+12], W0
001738  9000FE     MOV [W14+14], W1
00173A  980011     MOV W1, [W0+2]
219:               
220:               					/* Insert the new block into the list of free blocks. */
221:               					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
00173C  90004E     MOV [W14+8], W0
00173E  900090     MOV [W0+2], W1
001740  780F01     MOV W1, [W14]
001742  21C520     MOV #0x1C52, W0
001744  980710     MOV W0, [W14+2]
001746  370003     BRA 0x174E
001748  90001E     MOV [W14+2], W0
00174A  780090     MOV [W0], W1
00174C  980711     MOV W1, [W14+2]
00174E  90001E     MOV [W14+2], W0
001750  780010     MOV [W0], W0
001752  900010     MOV [W0+2], W0
001754  500F9E     SUB W0, [W14], [W15]
001756  39FFF8     BRA NC, 0x1748
001758  90001E     MOV [W14+2], W0
00175A  780090     MOV [W0], W1
00175C  90004E     MOV [W14+8], W0
00175E  780801     MOV W1, [W0]
001760  90001E     MOV [W14+2], W0
001762  9000CE     MOV [W14+8], W1
001764  780801     MOV W1, [W0]
222:               				}
223:               				
224:               				xFreeBytesRemaining -= pxBlock->xBlockSize;
001766  80E891     MOV 0x1D12, W1
001768  90006E     MOV [W14+12], W0
00176A  900010     MOV [W0+2], W0
00176C  508000     SUB W1, W0, W0
00176E  88E890     MOV W0, 0x1D12
225:               			}
226:               		}
227:               	}
228:               	xTaskResumeAll();
001770  07F81D     RCALL xTaskResumeAll
229:               
230:               	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
231:               	{
232:               		if( pvReturn == NULL )
233:               		{
234:               			extern void vApplicationMallocFailedHook( void );
235:               			vApplicationMallocFailedHook();
236:               		}
237:               	}
238:               	#endif
239:               
240:               	return pvReturn;
001772  90003E     MOV [W14+6], W0
241:               }
001774  FA8000     ULNK
001776  060000     RETURN
242:               /*-----------------------------------------------------------*/
243:               
244:               void vPortFree( void *pv )
245:               {
001778  FA000A     LNK #0xA
00177A  980740     MOV W0, [W14+8]
246:               unsigned char *puc = ( unsigned char * ) pv;
00177C  90004E     MOV [W14+8], W0
00177E  980730     MOV W0, [W14+6]
247:               xBlockLink *pxLink;
248:               
249:               	if( pv )
001780  90004E     MOV [W14+8], W0
001782  E00000     CP0 W0
001784  320023     BRA Z, 0x17CC
250:               	{
251:               		/* The memory being freed will have an xBlockLink structure immediately
252:               		before it. */
253:               		puc -= heapSTRUCT_SIZE;
001786  841C50     MOV 0x838A, W0
001788  780080     MOV W0, W1
00178A  90003E     MOV [W14+6], W0
00178C  500001     SUB W0, W1, W0
00178E  980730     MOV W0, [W14+6]
254:               
255:               		/* This casting is to keep the compiler from issuing warnings. */
256:               		pxLink = ( void * ) puc;
001790  9000BE     MOV [W14+6], W1
001792  980721     MOV W1, [W14+4]
257:               
258:               		vTaskSuspendAll();
001794  07F805     RCALL vTaskSuspendAll
259:               		{
260:               			/* Add this block to the list of free blocks. */
261:               			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
001796  90002E     MOV [W14+4], W0
001798  900090     MOV [W0+2], W1
00179A  780F01     MOV W1, [W14]
00179C  21C520     MOV #0x1C52, W0
00179E  980710     MOV W0, [W14+2]
0017A0  370003     BRA 0x17A8
0017A2  90001E     MOV [W14+2], W0
0017A4  780090     MOV [W0], W1
0017A6  980711     MOV W1, [W14+2]
0017A8  90001E     MOV [W14+2], W0
0017AA  780010     MOV [W0], W0
0017AC  900010     MOV [W0+2], W0
0017AE  500F9E     SUB W0, [W14], [W15]
0017B0  39FFF8     BRA NC, 0x17A2
0017B2  90001E     MOV [W14+2], W0
0017B4  780090     MOV [W0], W1
0017B6  90002E     MOV [W14+4], W0
0017B8  780801     MOV W1, [W0]
0017BA  90001E     MOV [W14+2], W0
0017BC  9000AE     MOV [W14+4], W1
0017BE  780801     MOV W1, [W0]
262:               			xFreeBytesRemaining += pxLink->xBlockSize;
0017C0  90002E     MOV [W14+4], W0
0017C2  900090     MOV [W0+2], W1
0017C4  80E890     MOV 0x1D12, W0
0017C6  408000     ADD W1, W0, W0
0017C8  88E890     MOV W0, 0x1D12
263:               		}
264:               		xTaskResumeAll();
0017CA  07F7F0     RCALL xTaskResumeAll
265:               	}
266:               }
0017CC  FA8000     ULNK
0017CE  060000     RETURN
267:               /*-----------------------------------------------------------*/
268:               
269:               size_t xPortGetFreeHeapSize( void )
270:               {
0017D0  FA0000     LNK #0x0
271:               	return xFreeBytesRemaining;
0017D2  80E890     MOV 0x1D12, W0
272:               }
0017D4  FA8000     ULNK
0017D6  060000     RETURN
273:               /*-----------------------------------------------------------*/
274:               
275:               void vPortInitialiseBlocks( void )
276:               {
0017D8  FA0000     LNK #0x0
277:               	/* This just exists to keep the linker quiet. */
278:               }
0017DA  FA8000     ULNK
0017DC  060000     RETURN
---  /Users/jhiesey/Desktop/SensorNet/WellInterface/FreeRTOS/Source/portable/MPLAB/PIC24_dsPIC/portasm_PIC24.S
                                                  1:     /*
                                                  2:         FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
                                                  3:     	
                                                  4:     
                                                  5:         ***************************************************************************
                                                  6:          *                                                                       *
                                                  7:          *    FreeRTOS tutorial books are available in pdf and paperback.        *
                                                  8:          *    Complete, revised, and edited pdf reference manuals are also       *
                                                  9:          *    available.                                                         *
                                                  10:         *                                                                       *
                                                  11:         *    Purchasing FreeRTOS documentation will not only help you, by       *
                                                  12:         *    ensuring you get running as quickly as possible and with an        *
                                                  13:         *    in-depth knowledge of how to use FreeRTOS, it will also help       *
                                                  14:         *    the FreeRTOS project to continue with its mission of providing     *
                                                  15:         *    professional grade, cross platform, de facto standard solutions    *
                                                  16:         *    for microcontrollers - completely free of charge!                  *
                                                  17:         *                                                                       *
                                                  18:         *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
                                                  19:         *                                                                       *
                                                  20:         *    Thank you for using FreeRTOS, and thank you for your support!      *
                                                  21:         *                                                                       *
                                                  22:        ***************************************************************************
                                                  23:    
                                                  24:    
                                                  25:        This file is part of the FreeRTOS distribution.
                                                  26:    
                                                  27:        FreeRTOS is free software; you can redistribute it and/or modify it under
                                                  28:        the terms of the GNU General Public License (version 2) as published by the
                                                  29:        Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
                                                  30:        >>>NOTE<<< The modification to the GPL is included to allow you to
                                                  31:        distribute a combined work that includes FreeRTOS without being obliged to
                                                  32:        provide the source code for proprietary components outside of the FreeRTOS
                                                  33:        kernel.  FreeRTOS is distributed in the hope that it will be useful, but
                                                  34:        WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
                                                  35:        or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
                                                  36:        more details. You should have received a copy of the GNU General Public
                                                  37:        License and the FreeRTOS license exception along with FreeRTOS; if not it
                                                  38:        can be viewed here: http://www.freertos.org/a00114.html and also obtained
                                                  39:        by writing to Richard Barry, contact details for whom are available on the
                                                  40:        FreeRTOS WEB site.
                                                  41:    
                                                  42:        1 tab == 4 spaces!
                                                  43:    
                                                  44:        http://www.FreeRTOS.org - Documentation, latest information, license and
                                                  45:        contact details.
                                                  46:    
                                                  47:        http://www.SafeRTOS.com - A version that is certified for use in safety
                                                  48:        critical systems.
                                                  49:    
                                                  50:        http://www.OpenRTOS.com - Commercial support, development, porting,
                                                  51:        licensing and training services.
                                                  52:    */
                                                  53:    
                                                  54:            .global _vPortYield
                                                  55:    		.extern _vTaskSwitchContext
                                                  56:    		.extern uxCriticalNesting
                                                  57:    
                                                  58:    _vPortYield:
                                                  59:    
001C5C  F80042     PUSH SR                        60:    		PUSH	SR						/* Save the SR used by the task.... */
001C5E  781F80     MOV W0, [W15++]                61:    		PUSH	W0						/* ....then disable interrupts. */
001C60  200200     MOV #0x20, W0                  62:    		MOV		#32, W0
001C62  880210     MOV W0, SR                     63:    		MOV		W0, SR
001C64  781F81     MOV W1, [W15++]                64:    		PUSH	W1						/* Save registers to the stack. */
001C66  BE9F82     MOV.D W2, [W15++]              65:    		PUSH.D	W2
001C68  BE9F84     MOV.D W4, [W15++]              66:    		PUSH.D	W4
001C6A  BE9F86     MOV.D W6, [W15++]              67:    		PUSH.D	W6
001C6C  BE9F88     MOV.D W8, [W15++]              68:    		PUSH.D 	W8
001C6E  BE9F8A     MOV.D W10, [W15++]             69:    		PUSH.D 	W10
001C70  BE9F8C     MOV.D W12, [W15++]             70:    		PUSH.D	W12
001C72  781F8E     MOV W14, [W15++]               71:    		PUSH	W14
001C74  F80036     PUSH RCOUNT                    72:    		PUSH	RCOUNT
001C76  F80032     PUSH TBLPAG                    73:    		PUSH	TBLPAG
                                                  74:    																						
001C78  F80044     PUSH CORCON                    75:    		PUSH	CORCON
001C7A  F80034     PUSH PSVPAG                    76:    		PUSH	PSVPAG
001C7C  80E880     MOV 0x1D10, W0                 77:    		MOV		_uxCriticalNesting, W0		/* Save the critical nesting counter for the task. */
001C7E  781F80     MOV W0, [W15++]                78:    		PUSH	W0
001C80  80E720     MOV 0x1CE4, W0                 79:    		MOV		_pxCurrentTCB, W0			/* Save the new top of stack into the TCB. */
001C82  78080F     MOV W15, [W0]                  80:    		MOV		W15, [W0]
                                                  81:    
001C84  020932     CALL 0x932                     82:    		call 	_vTaskSwitchContext
                                                  83:    
001C88  80E720     MOV 0x1CE4, W0                 84:    		MOV		_pxCurrentTCB, W0			/* Restore the stack pointer for the task. */
001C8A  780790     MOV [W0], W15                  85:    		MOV		[W0], W15
001C8C  78004F     MOV [--W15], W0                86:    		POP		W0							/* Restore the critical nesting counter for the task. */
001C8E  88E880     MOV W0, 0x1D10                 87:    		MOV		W0, _uxCriticalNesting
001C90  F90034     POP PSVPAG                     88:    		POP		PSVPAG
001C92  F90044     POP CORCON                     89:    		POP		CORCON
001C94  F90032     POP TBLPAG                     90:    		POP		TBLPAG
001C96  F90036     POP RCOUNT                     91:    		POP		RCOUNT						/* Restore the registers from the stack. */
001C98  78074F     MOV [--W15], W14               92:    		POP		W14
001C9A  BE064F     MOV.D [--W15], W12             93:    		POP.D	W12
001C9C  BE054F     MOV.D [--W15], W10             94:    		POP.D	W10
001C9E  BE044F     MOV.D [--W15], W8              95:    		POP.D	W8
001CA0  BE034F     MOV.D [--W15], W6              96:    		POP.D	W6
001CA2  BE024F     MOV.D [--W15], W4              97:    		POP.D	W4
001CA4  BE014F     MOV.D [--W15], W2              98:    		POP.D	W2
001CA6  BE004F     MOV.D [--W15], W0              99:    		POP.D	W0
001CA8  F90042     POP SR                         100:   		POP		SR
                                                  101:   
001CAA  060000     RETURN                         102:           return
                                                  103:   
                                                  104:           .end
---  /Users/jhiesey/Desktop/SensorNet/WellInterface/FreeRTOS/Source/portable/MPLAB/PIC24_dsPIC/port.c  --
1:                 /*
2:                     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
3:                 	
4:                 
5:                     ***************************************************************************
6:                      *                                                                       *
7:                      *    FreeRTOS tutorial books are available in pdf and paperback.        *
8:                      *    Complete, revised, and edited pdf reference manuals are also       *
9:                      *    available.                                                         *
10:                     *                                                                       *
11:                     *    Purchasing FreeRTOS documentation will not only help you, by       *
12:                     *    ensuring you get running as quickly as possible and with an        *
13:                     *    in-depth knowledge of how to use FreeRTOS, it will also help       *
14:                     *    the FreeRTOS project to continue with its mission of providing     *
15:                     *    professional grade, cross platform, de facto standard solutions    *
16:                     *    for microcontrollers - completely free of charge!                  *
17:                     *                                                                       *
18:                     *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
19:                     *                                                                       *
20:                     *    Thank you for using FreeRTOS, and thank you for your support!      *
21:                     *                                                                       *
22:                    ***************************************************************************
23:                
24:                
25:                    This file is part of the FreeRTOS distribution.
26:                
27:                    FreeRTOS is free software; you can redistribute it and/or modify it under
28:                    the terms of the GNU General Public License (version 2) as published by the
29:                    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
30:                    >>>NOTE<<< The modification to the GPL is included to allow you to
31:                    distribute a combined work that includes FreeRTOS without being obliged to
32:                    provide the source code for proprietary components outside of the FreeRTOS
33:                    kernel.  FreeRTOS is distributed in the hope that it will be useful, but
34:                    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
35:                    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
36:                    more details. You should have received a copy of the GNU General Public
37:                    License and the FreeRTOS license exception along with FreeRTOS; if not it
38:                    can be viewed here: http://www.freertos.org/a00114.html and also obtained
39:                    by writing to Richard Barry, contact details for whom are available on the
40:                    FreeRTOS WEB site.
41:                
42:                    1 tab == 4 spaces!
43:                
44:                    http://www.FreeRTOS.org - Documentation, latest information, license and
45:                    contact details.
46:                
47:                    http://www.SafeRTOS.com - A version that is certified for use in safety
48:                    critical systems.
49:                
50:                    http://www.OpenRTOS.com - Commercial support, development, porting,
51:                    licensing and training services.
52:                */
53:                
54:                /*
55:                	Changes from V4.2.1
56:                
57:                	+ Introduced the configKERNEL_INTERRUPT_PRIORITY definition.
58:                */
59:                
60:                /*-----------------------------------------------------------
61:                 * Implementation of functions defined in portable.h for the PIC24 port.
62:                 *----------------------------------------------------------*/
63:                
64:                /* Scheduler include files. */
65:                #include "FreeRTOS.h"
66:                #include "task.h"
67:                
68:                /* Hardware specifics. */
69:                #define portBIT_SET 1
70:                #define portTIMER_PRESCALE 8
71:                #define portINITIAL_SR	0
72:                
73:                /* Defined for backward compatability with project created prior to 
74:                FreeRTOS.org V4.3.0. */
75:                #ifndef configKERNEL_INTERRUPT_PRIORITY
76:                	#define configKERNEL_INTERRUPT_PRIORITY 1
77:                #endif
78:                
79:                /* The program counter is only 23 bits. */
80:                #define portUNUSED_PR_BITS	0x7f
81:                
82:                /* Records the nesting depth of calls to portENTER_CRITICAL(). */
83:                unsigned portBASE_TYPE uxCriticalNesting = 0xef;
84:                
85:                //#if configKERNEL_INTERRUPT_PRIORITY != 1
86:                //	#error If configKERNEL_INTERRUPT_PRIORITY is not 1 then the #32 in the following macros needs changing to equal the portINTERRUPT_BITS value, which is ( configKERNEL_INTERRUPT_PRIORITY << 5 )
87:                //#endif
88:                
89:                #ifdef MPLAB_PIC24_PORT
90:                
91:                	#define portRESTORE_CONTEXT()																						\
92:                		asm volatile(	"MOV	_pxCurrentTCB, W0		\n"	/* Restore the stack pointer for the task. */				\
93:                						"MOV	[W0], W15				\n"																\
94:                						"POP	W0						\n"	/* Restore the critical nesting counter for the task. */	\
95:                						"MOV	W0, _uxCriticalNesting	\n"																\
96:                						"POP	PSVPAG					\n"																\
97:                						"POP	CORCON					\n"																\
98:                						"POP	TBLPAG					\n"																\
99:                						"POP	RCOUNT					\n"	/* Restore the registers from the stack. */					\
100:               						"POP	W14						\n"																\
101:               						"POP.D	W12						\n"																\
102:               						"POP.D	W10						\n"																\
103:               						"POP.D	W8						\n"																\
104:               						"POP.D	W6						\n"																\
105:               						"POP.D	W4						\n"																\
106:               						"POP.D	W2						\n"																\
107:               						"POP.D	W0						\n"																\
108:               						"POP	SR						  " );
109:               
110:               #endif /* MPLAB_PIC24_PORT */
111:               
112:               #ifdef MPLAB_DSPIC_PORT
113:               
114:               	#define portRESTORE_CONTEXT()																						\
115:               		asm volatile(	"MOV	_pxCurrentTCB, W0		\n"	/* Restore the stack pointer for the task. */				\
116:               						"MOV	[W0], W15				\n"																\
117:               						"POP	W0						\n"	/* Restore the critical nesting counter for the task. */	\
118:               						"MOV	W0, _uxCriticalNesting	\n"																\
119:               						"POP	PSVPAG					\n"																\
120:               						"POP	CORCON					\n"																\
121:               						"POP	DOENDH					\n"																\
122:               						"POP	DOENDL					\n"																\
123:               						"POP	DOSTARTH				\n"																\
124:               						"POP	DOSTARTL				\n"																\
125:               						"POP	DCOUNT					\n"																\
126:               						"POP	ACCBU					\n"																\
127:               						"POP	ACCBH					\n"																\
128:               						"POP	ACCBL					\n"																\
129:               						"POP	ACCAU					\n"																\
130:               						"POP	ACCAH					\n"																\
131:               						"POP	ACCAL					\n"																\
132:               						"POP	TBLPAG					\n"																\
133:               						"POP	RCOUNT					\n"	/* Restore the registers from the stack. */					\
134:               						"POP	W14						\n"																\
135:               						"POP.D	W12						\n"																\
136:               						"POP.D	W10						\n"																\
137:               						"POP.D	W8						\n"																\
138:               						"POP.D	W6						\n"																\
139:               						"POP.D	W4						\n"																\
140:               						"POP.D	W2						\n"																\
141:               						"POP.D	W0						\n"																\
142:               						"POP	SR						  " );
143:               
144:               #endif /* MPLAB_DSPIC_PORT */
145:               
146:               /*
147:                * Setup the timer used to generate the tick interrupt.
148:                */
149:               static void prvSetupTimerInterrupt( void );
150:               
151:               /* 
152:                * See header file for description. 
153:                */
154:               portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
155:               {
0017DE  FA000A     LNK #0xA
0017E0  980720     MOV W0, [W14+4]
0017E2  980731     MOV W1, [W14+6]
0017E4  980742     MOV W2, [W14+8]
156:               unsigned short usCode;
157:               portBASE_TYPE i;
158:               
159:               const portSTACK_TYPE xInitialStack[] = 
160:               {
161:               	0x1111,	/* W1 */
162:               	0x2222, /* W2 */
163:               	0x3333, /* W3 */
164:               	0x4444, /* W4 */
165:               	0x5555, /* W5 */
166:               	0x6666, /* W6 */
167:               	0x7777, /* W7 */
168:               	0x8888, /* W8 */
169:               	0x9999, /* W9 */
170:               	0xaaaa, /* W10 */
171:               	0xbbbb, /* W11 */
172:               	0xcccc, /* W12 */
173:               	0xdddd, /* W13 */
174:               	0xeeee, /* W14 */
175:               	0xcdce, /* RCOUNT */
176:               	0xabac, /* TBLPAG */
177:               
178:               	/* dsPIC specific registers. */
179:               	#ifdef MPLAB_DSPIC_PORT
180:               		0x0202, /* ACCAL */
181:               		0x0303, /* ACCAH */
182:               		0x0404, /* ACCAU */
183:               		0x0505, /* ACCBL */
184:               		0x0606, /* ACCBH */
185:               		0x0707, /* ACCBU */
186:               		0x0808, /* DCOUNT */
187:               		0x090a, /* DOSTARTL */
188:               		0x1010, /* DOSTARTH */
189:               		0x1110, /* DOENDL */
190:               		0x1212, /* DOENDH */
191:               	#endif
192:               };
193:               
194:               	/* Setup the stack as if a yield had occurred.
195:               
196:               	Save the low bytes of the program counter. */
197:               	usCode = ( unsigned short ) pxCode;
0017E6  90003E     MOV [W14+6], W0
0017E8  980710     MOV W0, [W14+2]
198:               	*pxTopOfStack = ( portSTACK_TYPE ) usCode;
0017EA  90002E     MOV [W14+4], W0
0017EC  90009E     MOV [W14+2], W1
0017EE  780801     MOV W1, [W0]
199:               	pxTopOfStack++;
0017F0  90002E     MOV [W14+4], W0
0017F2  E88000     INC2 W0, W0
0017F4  980720     MOV W0, [W14+4]
200:               
201:               	/* Save the high byte of the program counter.  This will always be zero
202:               	here as it is passed in a 16bit pointer.  If the address is greater than
203:               	16 bits then the pointer will point to a jump table. */
204:               	*pxTopOfStack = ( portSTACK_TYPE ) 0;
0017F6  9000AE     MOV [W14+4], W1
0017F8  EB0000     CLR W0
0017FA  780880     MOV W0, [W1]
205:               	pxTopOfStack++;
0017FC  90002E     MOV [W14+4], W0
0017FE  E88000     INC2 W0, W0
001800  980720     MOV W0, [W14+4]
206:               
207:               	/* Status register with interrupts enabled. */
208:               	*pxTopOfStack = portINITIAL_SR;
001802  9000AE     MOV [W14+4], W1
001804  EB0000     CLR W0
001806  780880     MOV W0, [W1]
209:               	pxTopOfStack++;
001808  90002E     MOV [W14+4], W0
00180A  E88000     INC2 W0, W0
00180C  980720     MOV W0, [W14+4]
210:               
211:               	/* Parameters are passed in W0. */
212:               	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;
00180E  90004E     MOV [W14+8], W0
001810  780080     MOV W0, W1
001812  90002E     MOV [W14+4], W0
001814  780801     MOV W1, [W0]
213:               	pxTopOfStack++;
001816  90002E     MOV [W14+4], W0
001818  E88000     INC2 W0, W0
00181A  980720     MOV W0, [W14+4]
214:               
215:               	for( i = 0; i < ( sizeof( xInitialStack ) / sizeof( portSTACK_TYPE ) ); i++ )
00181C  EB0000     CLR W0
00181E  780F00     MOV W0, [W14]
001820  37000B     BRA 0x1838
001836  E80F1E     INC [W14], [W14]
001838  78001E     MOV [W14], W0
00183A  500FEF     SUB W0, #0xF, [W15]
00183C  36FFF2     BRA LEU, 0x1822
216:               	{
217:               		*pxTopOfStack = xInitialStack[ i ];
001822  78001E     MOV [W14], W0
001824  400080     ADD W0, W0, W1
001826  2835E0     MOV #0x835E, W0
001828  408000     ADD W1, W0, W0
00182A  780090     MOV [W0], W1
00182C  90002E     MOV [W14+4], W0
00182E  780801     MOV W1, [W0]
218:               		pxTopOfStack++;
001830  90002E     MOV [W14+4], W0
001832  E88000     INC2 W0, W0
001834  980720     MOV W0, [W14+4]
219:               	}
220:               
221:               	*pxTopOfStack = CORCON;
00183E  800221     MOV CORCON, W1
001840  90002E     MOV [W14+4], W0
001842  780801     MOV W1, [W0]
222:               	pxTopOfStack++;
001844  90002E     MOV [W14+4], W0
001846  E88000     INC2 W0, W0
001848  980720     MOV W0, [W14+4]
223:               	*pxTopOfStack = PSVPAG;
00184A  8001A1     MOV PSVPAG, W1
00184C  90002E     MOV [W14+4], W0
00184E  780801     MOV W1, [W0]
224:               	pxTopOfStack++;
001850  90002E     MOV [W14+4], W0
001852  E88000     INC2 W0, W0
001854  980720     MOV W0, [W14+4]
225:               
226:               	/* Finally the critical nesting depth. */
227:               	*pxTopOfStack = 0x00;
001856  9000AE     MOV [W14+4], W1
001858  EB0000     CLR W0
00185A  780880     MOV W0, [W1]
228:               	pxTopOfStack++;
00185C  90002E     MOV [W14+4], W0
00185E  E88000     INC2 W0, W0
001860  980720     MOV W0, [W14+4]
229:               
230:               	return pxTopOfStack;
001862  90002E     MOV [W14+4], W0
231:               }
001864  FA8000     ULNK
001866  060000     RETURN
232:               /*-----------------------------------------------------------*/
233:               
234:               portBASE_TYPE xPortStartScheduler( void )
235:               {
001868  FA0000     LNK #0x0
236:               	/* Setup a timer for the tick ISR. */
237:               	prvSetupTimerInterrupt(); 
00186A  070018     RCALL prvSetupTimerInterrupt
238:               
239:               	/* Restore the context of the first task to run. */
240:               	portRESTORE_CONTEXT();
00186C  80E720     MOV 0x1CE4, W0
00186E  780790     MOV [W0], W15
001870  78004F     MOV [--W15], W0
001872  88E880     MOV W0, 0x1D10
001874  F90034     POP PSVPAG
001876  F90044     POP CORCON
001878  F90032     POP TBLPAG
00187A  F90036     POP RCOUNT
00187C  78074F     MOV [--W15], W14
00187E  BE064F     MOV.D [--W15], W12
001880  BE054F     MOV.D [--W15], W10
001882  BE044F     MOV.D [--W15], W8
001884  BE034F     MOV.D [--W15], W6
001886  BE024F     MOV.D [--W15], W4
001888  BE014F     MOV.D [--W15], W2
00188A  BE004F     MOV.D [--W15], W0
00188C  F90042     POP SR
241:               
242:               	/* Simulate the end of the yield function. */
243:               	asm volatile ( "return" );
00188E  060000     RETURN
244:               
245:               	/* Should not reach here. */
246:               	return pdTRUE;
001890  200010     MOV #0x1, W0
247:               }
001892  FA8000     ULNK
001894  060000     RETURN
248:               /*-----------------------------------------------------------*/
249:               
250:               void vPortEndScheduler( void )
251:               {
001896  FA0000     LNK #0x0
252:               	/* It is unlikely that the scheduler for the PIC port will get stopped
253:               	once running.  If required disable the tick interrupt here, then return 
254:               	to xPortStartScheduler(). */
255:               }
001898  FA8000     ULNK
00189A  060000     RETURN
256:               /*-----------------------------------------------------------*/
257:               
258:               /*
259:                * Setup a timer for a regular tick.
260:                */
261:               static void prvSetupTimerInterrupt( void )
262:               {
00189C  FA0004     LNK #0x4
263:               const unsigned long ulCompareMatch = ( ( configCPU_CLOCK_HZ / portTIMER_PRESCALE ) / configTICK_RATE_HZ ) - 1;
00189E  201F30     MOV #0x1F3, W0
0018A0  200001     MOV #0x0, W1
0018A2  BE8F00     MOV.D W0, [W14]
264:               
265:               	/* Prescale of 8. */
266:               	T1CON = 0;
0018A4  EB0000     CLR W0
0018A6  880820     MOV W0, T1CON
267:               	TMR1 = 0;
0018A8  EB0000     CLR W0
0018AA  880800     MOV W0, TMR1
268:               
269:               	PR1 = ( unsigned short ) ulCompareMatch;
0018AC  78001E     MOV [W14], W0
0018AE  880810     MOV W0, PR1
270:               
271:               	/* Setup timer 1 interrupt priority. */
272:               	IPC0bits.T1IP = configKERNEL_INTERRUPT_PRIORITY;
0018B0  200A51     MOV #0xA5, W1
0018B2  784091     MOV.B [W1], W1
0018B4  B3C700     MOV #0x70, W0
0018B6  70C000     IOR.B W1, W0, W0
0018B8  B7E0A5     MOVWF.B WREG, 0xA5
273:               
274:               	/* Clear the interrupt as a starting condition. */
275:               	IFS0bits.T1IF = 0;
0018BA  A96084     BCLR IFS0, #3
276:               
277:               	/* Enable the interrupt. */
278:               	IEC0bits.T1IE = 1;
0018BC  A86094     BSET IEC0, #3
279:               
280:               	/* Setup the prescale value. */
281:               	T1CONbits.TCKPS0 = 1;
0018BE  A88104     BSET T1CON, #4
282:               	T1CONbits.TCKPS1 = 0;
0018C0  A9A104     BCLR T1CON, #5
283:               
284:               	/* Start the timer. */
285:               	T1CONbits.TON = 1;
0018C2  A8E105     BSET 0x105, #7
286:               }
0018C4  FA8000     ULNK
0018C6  060000     RETURN
287:               /*-----------------------------------------------------------*/
288:               
289:               void vPortEnterCritical( void )
290:               {
0018C8  FA0000     LNK #0x0
291:               	portDISABLE_INTERRUPTS();
0018CA  800211     MOV SR, W1
0018CC  200E00     MOV #0xE0, W0
0018CE  708000     IOR W1, W0, W0
0018D0  880210     MOV W0, SR
292:               	uxCriticalNesting++;
0018D2  80E880     MOV 0x1D10, W0
0018D4  E80000     INC W0, W0
0018D6  88E880     MOV W0, 0x1D10
293:               }
0018D8  FA8000     ULNK
0018DA  060000     RETURN
294:               /*-----------------------------------------------------------*/
295:               
296:               void vPortExitCritical( void )
297:               {
0018DC  FA0000     LNK #0x0
298:               	uxCriticalNesting--;
0018DE  80E880     MOV 0x1D10, W0
0018E0  E90000     DEC W0, W0
0018E2  88E880     MOV W0, 0x1D10
299:               	if( uxCriticalNesting == 0 )
0018E4  80E880     MOV 0x1D10, W0
0018E6  E00000     CP0 W0
0018E8  3A0004     BRA NZ, 0x18F2
300:               	{
301:               		portENABLE_INTERRUPTS();
0018EA  800210     MOV SR, W0
0018EC  2FF1F1     MOV #0xFF1F, W1
0018EE  600001     AND W0, W1, W0
0018F0  880210     MOV W0, SR
302:               	}
303:               }
0018F2  FA8000     ULNK
0018F4  060000     RETURN
304:               /*-----------------------------------------------------------*/
305:               
306:               void __attribute__((__interrupt__, auto_psv)) _T1Interrupt( void )
307:               {
0018F6  F80036     PUSH RCOUNT
0018F8  BE9F80     MOV.D W0, [W15++]
0018FA  BE9F82     MOV.D W2, [W15++]
0018FC  BE9F84     MOV.D W4, [W15++]
0018FE  BE9F86     MOV.D W6, [W15++]
001900  F80034     PUSH PSVPAG
001902  200000     MOV #0x0, W0
001904  8801A0     MOV W0, PSVPAG
001906  FA0000     LNK #0x0
308:               	/* Clear the timer interrupt. */
309:               	IFS0bits.T1IF = 0;
001908  A96084     BCLR IFS0, #3
310:               
311:               	vTaskIncrementTick();
00190A  07F7B8     RCALL vTaskIncrementTick
312:               
313:               	#if configUSE_PREEMPTION == 1
314:               		portYIELD();
00190C  021C5C     CALL _vPortYield
00190E  000000     NOP
001910  000000     NOP
315:               	#endif
316:               }
001912  FA8000     ULNK
001914  F90034     POP PSVPAG
001916  BE034F     MOV.D [--W15], W6
001918  BE024F     MOV.D [--W15], W4
00191A  BE014F     MOV.D [--W15], W2
00191C  BE004F     MOV.D [--W15], W0
00191E  F90036     POP RCOUNT
001920  064000     RETFIE
---  /Users/jhiesey/Desktop/SensorNet/WellInterface/FreeRTOS/Source/list.c  -----------------------------
1:                 /*
2:                     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
3:                 
4:                 
5:                     ***************************************************************************
6:                      *                                                                       *
7:                      *    FreeRTOS tutorial books are available in pdf and paperback.        *
8:                      *    Complete, revised, and edited pdf reference manuals are also       *
9:                      *    available.                                                         *
10:                     *                                                                       *
11:                     *    Purchasing FreeRTOS documentation will not only help you, by       *
12:                     *    ensuring you get running as quickly as possible and with an        *
13:                     *    in-depth knowledge of how to use FreeRTOS, it will also help       *
14:                     *    the FreeRTOS project to continue with its mission of providing     *
15:                     *    professional grade, cross platform, de facto standard solutions    *
16:                     *    for microcontrollers - completely free of charge!                  *
17:                     *                                                                       *
18:                     *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
19:                     *                                                                       *
20:                     *    Thank you for using FreeRTOS, and thank you for your support!      *
21:                     *                                                                       *
22:                    ***************************************************************************
23:                
24:                
25:                    This file is part of the FreeRTOS distribution.
26:                
27:                    FreeRTOS is free software; you can redistribute it and/or modify it under
28:                    the terms of the GNU General Public License (version 2) as published by the
29:                    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
30:                    >>>NOTE<<< The modification to the GPL is included to allow you to
31:                    distribute a combined work that includes FreeRTOS without being obliged to
32:                    provide the source code for proprietary components outside of the FreeRTOS
33:                    kernel.  FreeRTOS is distributed in the hope that it will be useful, but
34:                    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
35:                    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
36:                    more details. You should have received a copy of the GNU General Public
37:                    License and the FreeRTOS license exception along with FreeRTOS; if not it
38:                    can be viewed here: http://www.freertos.org/a00114.html and also obtained
39:                    by writing to Richard Barry, contact details for whom are available on the
40:                    FreeRTOS WEB site.
41:                
42:                    1 tab == 4 spaces!
43:                
44:                    http://www.FreeRTOS.org - Documentation, latest information, license and
45:                    contact details.
46:                
47:                    http://www.SafeRTOS.com - A version that is certified for use in safety
48:                    critical systems.
49:                
50:                    http://www.OpenRTOS.com - Commercial support, development, porting,
51:                    licensing and training services.
52:                */
53:                
54:                
55:                #include <stdlib.h>
56:                #include "FreeRTOS.h"
57:                #include "list.h"
58:                
59:                /*-----------------------------------------------------------
60:                 * PUBLIC LIST API documented in list.h
61:                 *----------------------------------------------------------*/
62:                
63:                void vListInitialise( xList *pxList )
64:                {
001922  FA0002     LNK #0x2
001924  780F00     MOV W0, [W14]
65:                	/* The list structure contains a list item which is used to mark the
66:                	end of the list.  To initialise the list the list end is inserted
67:                	as the only list entry. */
68:                	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
001926  78009E     MOV [W14], W1
001928  408064     ADD W1, #0x4, W0
00192A  780080     MOV W0, W1
00192C  78001E     MOV [W14], W0
00192E  980011     MOV W1, [W0+2]
69:                
70:                	/* The list end value is the highest possible value in the list to
71:                	ensure it remains at the end of the list. */
72:                	pxList->xListEnd.xItemValue = portMAX_DELAY;
001930  78009E     MOV [W14], W1
001932  EB8000     SETM W0
001934  9800A0     MOV W0, [W1+4]
73:                
74:                	/* The list end next and previous pointers point to itself so we know
75:                	when the list is empty. */
76:                	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
001936  78009E     MOV [W14], W1
001938  408064     ADD W1, #0x4, W0
00193A  780080     MOV W0, W1
00193C  78001E     MOV [W14], W0
00193E  980031     MOV W1, [W0+6]
77:                	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
001940  78009E     MOV [W14], W1
001942  408064     ADD W1, #0x4, W0
001944  780080     MOV W0, W1
001946  78001E     MOV [W14], W0
001948  980041     MOV W1, [W0+8]
78:                
79:                	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
00194A  78009E     MOV [W14], W1
00194C  EB0000     CLR W0
00194E  780880     MOV W0, [W1]
80:                }
001950  FA8000     ULNK
001952  060000     RETURN
81:                /*-----------------------------------------------------------*/
82:                
83:                void vListInitialiseItem( xListItem *pxItem )
84:                {
001954  FA0002     LNK #0x2
001956  780F00     MOV W0, [W14]
85:                	/* Make sure the list item is not recorded as being on a list. */
86:                	pxItem->pvContainer = NULL;
001958  78009E     MOV [W14], W1
00195A  EB0000     CLR W0
00195C  9800C0     MOV W0, [W1+8]
87:                }
00195E  FA8000     ULNK
001960  060000     RETURN
88:                /*-----------------------------------------------------------*/
89:                
90:                void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
91:                {
001962  FA0006     LNK #0x6
001964  980710     MOV W0, [W14+2]
001966  980721     MOV W1, [W14+4]
92:                volatile xListItem * pxIndex;
93:                
94:                	/* Insert a new list item into pxList, but rather than sort the list,
95:                	makes the new list item the last item to be removed by a call to
96:                	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
97:                	the pxIndex member. */
98:                	pxIndex = pxList->pxIndex;
001968  90001E     MOV [W14+2], W0
00196A  900090     MOV [W0+2], W1
00196C  780F01     MOV W1, [W14]
99:                
100:               	pxNewListItem->pxNext = pxIndex->pxNext;
00196E  78001E     MOV [W14], W0
001970  900090     MOV [W0+2], W1
001972  90002E     MOV [W14+4], W0
001974  980011     MOV W1, [W0+2]
101:               	pxNewListItem->pxPrevious = pxList->pxIndex;
001976  90001E     MOV [W14+2], W0
001978  900090     MOV [W0+2], W1
00197A  90002E     MOV [W14+4], W0
00197C  980021     MOV W1, [W0+4]
102:               	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
00197E  78001E     MOV [W14], W0
001980  900090     MOV [W0+2], W1
001982  90002E     MOV [W14+4], W0
001984  9800A0     MOV W0, [W1+4]
103:               	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
001986  9000AE     MOV [W14+4], W1
001988  78001E     MOV [W14], W0
00198A  980011     MOV W1, [W0+2]
104:               	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
00198C  9000AE     MOV [W14+4], W1
00198E  90001E     MOV [W14+2], W0
001990  980011     MOV W1, [W0+2]
105:               
106:               	/* Remember which list the item is in. */
107:               	pxNewListItem->pvContainer = ( void * ) pxList;
001992  90002E     MOV [W14+4], W0
001994  90009E     MOV [W14+2], W1
001996  980041     MOV W1, [W0+8]
108:               
109:               	( pxList->uxNumberOfItems )++;
001998  90001E     MOV [W14+2], W0
00199A  780010     MOV [W0], W0
00199C  E80080     INC W0, W1
00199E  90001E     MOV [W14+2], W0
0019A0  780801     MOV W1, [W0]
110:               }
0019A2  FA8000     ULNK
0019A4  060000     RETURN
111:               /*-----------------------------------------------------------*/
112:               
113:               void vListInsert( xList *pxList, xListItem *pxNewListItem )
114:               {
0019A6  FA0008     LNK #0x8
0019A8  980720     MOV W0, [W14+4]
0019AA  980731     MOV W1, [W14+6]
115:               volatile xListItem *pxIterator;
116:               portTickType xValueOfInsertion;
117:               
118:               	/* Insert the new list item into the list, sorted in ulListItem order. */
119:               	xValueOfInsertion = pxNewListItem->xItemValue;
0019AC  90003E     MOV [W14+6], W0
0019AE  780F10     MOV [W0], [W14]
120:               
121:               	/* If the list already contains a list item with the same item value then
122:               	the new list item should be placed after it.  This ensures that TCB's which
123:               	are stored in ready lists (all of which have the same ulListItem value)
124:               	get an equal share of the CPU.  However, if the xItemValue is the same as
125:               	the back marker the iteration loop below will not end.  This means we need
126:               	to guard against this by checking the value first and modifying the
127:               	algorithm slightly if necessary. */
128:               	if( xValueOfInsertion == portMAX_DELAY )
0019B0  EB8000     SETM W0
0019B2  100F9E     SUBR W0, [W14], [W15]
0019B4  3A0004     BRA NZ, 0x19BE
129:               	{
130:               		pxIterator = pxList->xListEnd.pxPrevious;
0019B6  90002E     MOV [W14+4], W0
0019B8  9000C0     MOV [W0+8], W1
0019BA  980711     MOV W1, [W14+2]
0019BC  37000C     BRA 0x19D6
131:               	}
132:               	else
133:               	{
134:               		/* *** NOTE ***********************************************************
135:               		If you find your application is crashing here then likely causes are:
136:               			1) Stack overflow -
137:               			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
138:               			2) Incorrect interrupt priority assignment, especially on Cortex-M3
139:               			   parts where numerically high priority values denote low actual
140:               			   interrupt priories, which can seem counter intuitive.  See
141:               			   configMAX_SYSCALL_INTERRUPT_PRIORITY on http://www.freertos.org/a00110.html
142:               			3) Calling an API function from within a critical section or when
143:               			   the scheduler is suspended.
144:               			4) Using a queue or semaphore before it has been initialised or
145:               			   before the scheduler has been started (are interrupts firing
146:               			   before vTaskStartScheduler() has been called?).
147:               		See http://www.freertos.org/FAQHelp.html for more tips.
148:               		**********************************************************************/
149:               		
150:               		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
0019BE  90002E     MOV [W14+4], W0
0019C0  400064     ADD W0, #0x4, W0
0019C2  980710     MOV W0, [W14+2]
0019C4  370003     BRA 0x19CC
0019C6  90001E     MOV [W14+2], W0
0019C8  900090     MOV [W0+2], W1
0019CA  980711     MOV W1, [W14+2]
0019CC  90001E     MOV [W14+2], W0
0019CE  900010     MOV [W0+2], W0
0019D0  780010     MOV [W0], W0
0019D2  500F9E     SUB W0, [W14], [W15]
0019D4  36FFF8     BRA LEU, 0x19C6
151:               		{
152:               			/* There is nothing to do here, we are just iterating to the
153:               			wanted insertion position. */
154:               		}
155:               	}
156:               
157:               	pxNewListItem->pxNext = pxIterator->pxNext;
0019D6  90001E     MOV [W14+2], W0
0019D8  900090     MOV [W0+2], W1
0019DA  90003E     MOV [W14+6], W0
0019DC  980011     MOV W1, [W0+2]
158:               	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
0019DE  90003E     MOV [W14+6], W0
0019E0  900090     MOV [W0+2], W1
0019E2  90003E     MOV [W14+6], W0
0019E4  9800A0     MOV W0, [W1+4]
159:               	pxNewListItem->pxPrevious = pxIterator;
0019E6  90003E     MOV [W14+6], W0
0019E8  90009E     MOV [W14+2], W1
0019EA  980021     MOV W1, [W0+4]
160:               	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
0019EC  9000BE     MOV [W14+6], W1
0019EE  90001E     MOV [W14+2], W0
0019F0  980011     MOV W1, [W0+2]
161:               
162:               	/* Remember which list the item is in.  This allows fast removal of the
163:               	item later. */
164:               	pxNewListItem->pvContainer = ( void * ) pxList;
0019F2  90003E     MOV [W14+6], W0
0019F4  9000AE     MOV [W14+4], W1
0019F6  980041     MOV W1, [W0+8]
165:               
166:               	( pxList->uxNumberOfItems )++;
0019F8  90002E     MOV [W14+4], W0
0019FA  780010     MOV [W0], W0
0019FC  E80080     INC W0, W1
0019FE  90002E     MOV [W14+4], W0
001A00  780801     MOV W1, [W0]
167:               }
001A02  FA8000     ULNK
001A04  060000     RETURN
168:               /*-----------------------------------------------------------*/
169:               
170:               void vListRemove( xListItem *pxItemToRemove )
171:               {
001A06  FA0004     LNK #0x4
001A08  980710     MOV W0, [W14+2]
172:               xList * pxList;
173:               
174:               	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
001A0A  90001E     MOV [W14+2], W0
001A0C  900090     MOV [W0+2], W1
001A0E  90001E     MOV [W14+2], W0
001A10  900020     MOV [W0+4], W0
001A12  9800A0     MOV W0, [W1+4]
175:               	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
001A14  90001E     MOV [W14+2], W0
001A16  9000A0     MOV [W0+4], W1
001A18  90001E     MOV [W14+2], W0
001A1A  900010     MOV [W0+2], W0
001A1C  980090     MOV W0, [W1+2]
176:               	
177:               	/* The list item knows which list it is in.  Obtain the list from the list
178:               	item. */
179:               	pxList = ( xList * ) pxItemToRemove->pvContainer;
001A1E  90001E     MOV [W14+2], W0
001A20  900040     MOV [W0+8], W0
001A22  780F00     MOV W0, [W14]
180:               
181:               	/* Make sure the index is left pointing to a valid item. */
182:               	if( pxList->pxIndex == pxItemToRemove )
001A24  78001E     MOV [W14], W0
001A26  900090     MOV [W0+2], W1
001A28  90001E     MOV [W14+2], W0
001A2A  508F80     SUB W1, W0, [W15]
001A2C  3A0004     BRA NZ, 0x1A36
183:               	{
184:               		pxList->pxIndex = pxItemToRemove->pxPrevious;
001A2E  90001E     MOV [W14+2], W0
001A30  9000A0     MOV [W0+4], W1
001A32  78001E     MOV [W14], W0
001A34  980011     MOV W1, [W0+2]
185:               	}
186:               
187:               	pxItemToRemove->pvContainer = NULL;
001A36  90009E     MOV [W14+2], W1
001A38  EB0000     CLR W0
001A3A  9800C0     MOV W0, [W1+8]
188:               	( pxList->uxNumberOfItems )--;
001A3C  78001E     MOV [W14], W0
001A3E  780010     MOV [W0], W0
001A40  E90080     DEC W0, W1
001A42  78001E     MOV [W14], W0
001A44  780801     MOV W1, [W0]
189:               }
001A46  FA8000     ULNK
001A48  060000     RETURN
190:               /*-----------------------------------------------------------*/
191:               
---  /Users/jhiesey/Desktop/SensorNet/WellInterface/FreeRTOS/Source/croutine.c  -------------------------
1:                 /*
2:                     FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
3:                 
4:                 
5:                     ***************************************************************************
6:                      *                                                                       *
7:                      *    FreeRTOS tutorial books are available in pdf and paperback.        *
8:                      *    Complete, revised, and edited pdf reference manuals are also       *
9:                      *    available.                                                         *
10:                     *                                                                       *
11:                     *    Purchasing FreeRTOS documentation will not only help you, by       *
12:                     *    ensuring you get running as quickly as possible and with an        *
13:                     *    in-depth knowledge of how to use FreeRTOS, it will also help       *
14:                     *    the FreeRTOS project to continue with its mission of providing     *
15:                     *    professional grade, cross platform, de facto standard solutions    *
16:                     *    for microcontrollers - completely free of charge!                  *
17:                     *                                                                       *
18:                     *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
19:                     *                                                                       *
20:                     *    Thank you for using FreeRTOS, and thank you for your support!      *
21:                     *                                                                       *
22:                    ***************************************************************************
23:                
24:                
25:                    This file is part of the FreeRTOS distribution.
26:                
27:                    FreeRTOS is free software; you can redistribute it and/or modify it under
28:                    the terms of the GNU General Public License (version 2) as published by the
29:                    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
30:                    >>>NOTE<<< The modification to the GPL is included to allow you to
31:                    distribute a combined work that includes FreeRTOS without being obliged to
32:                    provide the source code for proprietary components outside of the FreeRTOS
33:                    kernel.  FreeRTOS is distributed in the hope that it will be useful, but
34:                    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
35:                    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
36:                    more details. You should have received a copy of the GNU General Public
37:                    License and the FreeRTOS license exception along with FreeRTOS; if not it
38:                    can be viewed here: http://www.freertos.org/a00114.html and also obtained
39:                    by writing to Richard Barry, contact details for whom are available on the
40:                    FreeRTOS WEB site.
41:                
42:                    1 tab == 4 spaces!
43:                
44:                    http://www.FreeRTOS.org - Documentation, latest information, license and
45:                    contact details.
46:                
47:                    http://www.SafeRTOS.com - A version that is certified for use in safety
48:                    critical systems.
49:                
50:                    http://www.OpenRTOS.com - Commercial support, development, porting,
51:                    licensing and training services.
52:                */
53:                
54:                #include "FreeRTOS.h"
55:                #include "task.h"
56:                #include "croutine.h"
57:                
58:                /*
59:                 * Some kernel aware debuggers require data to be viewed to be global, rather
60:                 * than file scope.
61:                 */
62:                #ifdef portREMOVE_STATIC_QUALIFIER
63:                	#define static
64:                #endif
65:                
66:                
67:                /* Lists for ready and blocked co-routines. --------------------*/
68:                static xList pxReadyCoRoutineLists[ configMAX_CO_ROUTINE_PRIORITIES ];	/*< Prioritised ready co-routines. */
69:                static xList xDelayedCoRoutineList1;									/*< Delayed co-routines. */
70:                static xList xDelayedCoRoutineList2;									/*< Delayed co-routines (two lists are used - one for delays that have overflowed the current tick count. */
71:                static xList * pxDelayedCoRoutineList;									/*< Points to the delayed co-routine list currently being used. */
72:                static xList * pxOverflowDelayedCoRoutineList;							/*< Points to the delayed co-routine list currently being used to hold co-routines that have overflowed the current tick count. */
73:                static xList xPendingReadyCoRoutineList;											/*< Holds co-routines that have been readied by an external event.  They cannot be added directly to the ready lists as the ready lists cannot be accessed by interrupts. */
74:                
75:                /* Other file private variables. --------------------------------*/
76:                corCRCB * pxCurrentCoRoutine = NULL;
77:                static unsigned portBASE_TYPE uxTopCoRoutineReadyPriority = 0;
78:                static portTickType xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;
79:                
80:                /* The initial state of the co-routine when it is created. */
81:                #define corINITIAL_STATE	( 0 )
82:                
83:                /*
84:                 * Place the co-routine represented by pxCRCB into the appropriate ready queue
85:                 * for the priority.  It is inserted at the end of the list.
86:                 *
87:                 * This macro accesses the co-routine ready lists and therefore must not be
88:                 * used from within an ISR.
89:                 */
90:                #define prvAddCoRoutineToReadyQueue( pxCRCB )																		\
91:                {																													\
92:                	if( pxCRCB->uxPriority > uxTopCoRoutineReadyPriority )															\
93:                	{																												\
94:                		uxTopCoRoutineReadyPriority = pxCRCB->uxPriority;															\
95:                	}																												\
96:                	vListInsertEnd( ( xList * ) &( pxReadyCoRoutineLists[ pxCRCB->uxPriority ] ), &( pxCRCB->xGenericListItem ) );	\
97:                }	
98:                
99:                /*
100:                * Utility to ready all the lists used by the scheduler.  This is called
101:                * automatically upon the creation of the first co-routine.
102:                */
103:               static void prvInitialiseCoRoutineLists( void );
104:               
105:               /*
106:                * Co-routines that are readied by an interrupt cannot be placed directly into
107:                * the ready lists (there is no mutual exclusion).  Instead they are placed in
108:                * in the pending ready list in order that they can later be moved to the ready
109:                * list by the co-routine scheduler.
110:                */
111:               static void prvCheckPendingReadyList( void );
112:               
113:               /*
114:                * Macro that looks at the list of co-routines that are currently delayed to
115:                * see if any require waking.
116:                *
117:                * Co-routines are stored in the queue in the order of their wake time -
118:                * meaning once one co-routine has been found whose timer has not expired
119:                * we need not look any further down the list.
120:                */
121:               static void prvCheckDelayedList( void );
122:               
123:               /*-----------------------------------------------------------*/
124:               
125:               signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
126:               {
00123C  FA000A     LNK #0xA
00123E  980720     MOV W0, [W14+4]
001240  980731     MOV W1, [W14+6]
001242  980742     MOV W2, [W14+8]
127:               signed portBASE_TYPE xReturn;
128:               corCRCB *pxCoRoutine;
129:               
130:               	/* Allocate the memory that will store the co-routine control block. */
131:               	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
001244  2001C0     MOV #0x1C, W0
001246  070213     RCALL pvPortMalloc
001248  780F00     MOV W0, [W14]
132:               	if( pxCoRoutine )
00124A  E0001E     CP0 [W14]
00124C  32003A     BRA Z, 0x12C2
133:               	{
134:               		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
135:               		be created and the co-routine data structures need initialising. */
136:               		if( pxCurrentCoRoutine == NULL )
00124E  80E7E0     MOV 0x1CFC, W0
001250  E00000     CP0 W0
001252  3A0003     BRA NZ, 0x125A
137:               		{
138:               			pxCurrentCoRoutine = pxCoRoutine;
001254  78001E     MOV [W14], W0
001256  88E7E0     MOV W0, 0x1CFC
139:               			prvInitialiseCoRoutineLists();
001258  070103     RCALL prvInitialiseCoRoutineLists
140:               		}
141:               
142:               		/* Check the priority is within limits. */
143:               		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
00125A  90003E     MOV [W14+6], W0
00125C  500FE1     SUB W0, #0x1, [W15]
00125E  360002     BRA LEU, 0x1264
144:               		{
145:               			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
001260  200010     MOV #0x1, W0
001262  980730     MOV W0, [W14+6]
146:               		}
147:               
148:               		/* Fill out the co-routine control block from the function parameters. */
149:               		pxCoRoutine->uxState = corINITIAL_STATE;
001264  78009E     MOV [W14], W1
001266  EB0000     CLR W0
001268  9808D0     MOV W0, [W1+26]
150:               		pxCoRoutine->uxPriority = uxPriority;
00126A  78001E     MOV [W14], W0
00126C  9000BE     MOV [W14+6], W1
00126E  980831     MOV W1, [W0+22]
151:               		pxCoRoutine->uxIndex = uxIndex;
001270  78001E     MOV [W14], W0
001272  9000CE     MOV [W14+8], W1
001274  980841     MOV W1, [W0+24]
152:               		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
001276  78001E     MOV [W14], W0
001278  9000AE     MOV [W14+4], W1
00127A  780801     MOV W1, [W0]
153:               
154:               		/* Initialise all the other co-routine control block parameters. */
155:               		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
00127C  E8801E     INC2 [W14], W0
00127E  07036A     RCALL vListInitialiseItem
156:               		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
001280  78009E     MOV [W14], W1
001282  40806C     ADD W1, #0xC, W0
001284  070367     RCALL vListInitialiseItem
157:               
158:               		/* Set the co-routine control block as a link back from the xListItem.
159:               		This is so we can get back to the containing CRCB from a generic item
160:               		in a list. */
161:               		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
001286  78001E     MOV [W14], W0
001288  78009E     MOV [W14], W1
00128A  980041     MOV W1, [W0+8]
162:               		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
00128C  78001E     MOV [W14], W0
00128E  78009E     MOV [W14], W1
001290  980811     MOV W1, [W0+18]
163:               	
164:               		/* Event lists are always in priority order. */
165:               		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
001292  90003E     MOV [W14+6], W0
001294  1000E4     SUBR W0, #0x4, W1
001296  78001E     MOV [W14], W0
001298  980061     MOV W1, [W0+12]
166:               		
167:               		/* Now the co-routine has been initialised it can be added to the ready
168:               		list at the correct priority. */
169:               		prvAddCoRoutineToReadyQueue( pxCoRoutine );
00129A  78001E     MOV [W14], W0
00129C  9008B0     MOV [W0+22], W1
00129E  80E7F0     MOV 0x1CFE, W0
0012A0  508F80     SUB W1, W0, [W15]
0012A2  360003     BRA LEU, 0x12AA
0012A4  78001E     MOV [W14], W0
0012A6  900830     MOV [W0+22], W0
0012A8  88E7F0     MOV W0, 0x1CFE
0012AA  E8811E     INC2 [W14], W2
0012AC  78001E     MOV [W14], W0
0012AE  900830     MOV [W0+22], W0
0012B0  B9006A     MUL.SU W0, #10, W0
0012B2  780080     MOV W0, W1
0012B4  21CAE0     MOV #0x1CAE, W0
0012B6  408000     ADD W1, W0, W0
0012B8  780082     MOV W2, W1
0012BA  070353     RCALL vListInsertEnd
170:               
171:               		xReturn = pdPASS;
0012BC  200010     MOV #0x1, W0
0012BE  980710     MOV W0, [W14+2]
0012C0  370002     BRA 0x12C6
172:               	}
173:               	else
174:               	{		
175:               		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
0012C2  EB8000     SETM W0
0012C4  980710     MOV W0, [W14+2]
176:               	}
177:               	
178:               	return xReturn;	
0012C6  90001E     MOV [W14+2], W0
179:               }
0012C8  FA8000     ULNK
0012CA  060000     RETURN
180:               /*-----------------------------------------------------------*/
181:               
182:               void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
183:               {
0012CC  FA0006     LNK #0x6
0012CE  980710     MOV W0, [W14+2]
0012D0  980721     MOV W1, [W14+4]
184:               portTickType xTimeToWake;
185:               
186:               	/* Calculate the time to wake - this may overflow but this is
187:               	not a problem. */
188:               	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
0012D2  80E801     MOV 0x1D00, W1
0012D4  90001E     MOV [W14+2], W0
0012D6  408F00     ADD W1, W0, [W14]
189:               
190:               	/* We must remove ourselves from the ready list before adding
191:               	ourselves to the blocked list as the same list item is used for
192:               	both lists. */
193:               	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
0012D8  80E7E0     MOV 0x1CFC, W0
0012DA  E88000     INC2 W0, W0
0012DC  070394     RCALL vListRemove
194:               
195:               	/* The list item will be inserted in wake time order. */
196:               	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
0012DE  80E7E0     MOV 0x1CFC, W0
0012E0  78009E     MOV [W14], W1
0012E2  980011     MOV W1, [W0+2]
197:               
198:               	if( xTimeToWake < xCoRoutineTickCount )
0012E4  80E800     MOV 0x1D00, W0
0012E6  100F9E     SUBR W0, [W14], [W15]
0012E8  310005     BRA C, 0x12F4
199:               	{
200:               		/* Wake time has overflowed.  Place this item in the
201:               		overflow list. */
202:               		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
0012EA  80E7E0     MOV 0x1CFC, W0
0012EC  E88080     INC2 W0, W1
0012EE  80E6C0     MOV pxOverflowDelayedCoRoutineList, W0
0012F0  07035A     RCALL vListInsert
0012F2  370004     BRA 0x12FC
203:               	}
204:               	else
205:               	{
206:               		/* The wake time has not overflowed, so we can use the
207:               		current block list. */
208:               		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
0012F4  80E7E0     MOV 0x1CFC, W0
0012F6  E88080     INC2 W0, W1
0012F8  80E6B0     MOV pxDelayedCoRoutineList, W0
0012FA  070355     RCALL vListInsert
209:               	}
210:               
211:               	if( pxEventList )
0012FC  90002E     MOV [W14+4], W0
0012FE  E00000     CP0 W0
001300  320004     BRA Z, 0x130A
212:               	{
213:               		/* Also add the co-routine to an event list.  If this is done then the
214:               		function must be called with interrupts disabled. */
215:               		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
001302  80E7E0     MOV 0x1CFC, W0
001304  4000EC     ADD W0, #0xC, W1
001306  90002E     MOV [W14+4], W0
001308  07034E     RCALL vListInsert
216:               	}
217:               }
00130A  FA8000     ULNK
00130C  060000     RETURN
218:               /*-----------------------------------------------------------*/
219:               
220:               static void prvCheckPendingReadyList( void )
221:               {
00130E  FA0002     LNK #0x2
222:               	/* Are there any co-routines waiting to get moved to the ready list?  These
223:               	are co-routines that have been readied by an ISR.  The ISR cannot access
224:               	the	ready lists itself. */
225:               	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
001310  370021     BRA 0x1354
001354  80E6D0     MOV xPendingReadyCoRoutineList, W0
001356  E00000     CP0 W0
001358  3AFFDC     BRA NZ, 0x1312
226:               	{
227:               		corCRCB *pxUnblockedCRCB;
228:               
229:               		/* The pending ready list can be accessed by an ISR. */
230:               		portDISABLE_INTERRUPTS();
001312  800211     MOV SR, W1
001314  200E00     MOV #0xE0, W0
001316  708000     IOR W1, W0, W0
001318  880210     MOV W0, SR
231:               		{	
232:               			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
00131A  80E700     MOV 0x1CE0, W0
00131C  900030     MOV [W0+6], W0
00131E  780F00     MOV W0, [W14]
233:               			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
001320  78009E     MOV [W14], W1
001322  40806C     ADD W1, #0xC, W0
001324  070370     RCALL vListRemove
234:               		}
235:               		portENABLE_INTERRUPTS();
001326  800211     MOV SR, W1
001328  2FF1F0     MOV #0xFF1F, W0
00132A  608000     AND W1, W0, W0
00132C  880210     MOV W0, SR
236:               
237:               		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
00132E  E8801E     INC2 [W14], W0
001330  07036A     RCALL vListRemove
238:               		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
001332  78001E     MOV [W14], W0
001334  9008B0     MOV [W0+22], W1
001336  80E7F0     MOV 0x1CFE, W0
001338  508F80     SUB W1, W0, [W15]
00133A  360003     BRA LEU, 0x1342
00133C  78001E     MOV [W14], W0
00133E  900830     MOV [W0+22], W0
001340  88E7F0     MOV W0, 0x1CFE
001342  E8811E     INC2 [W14], W2
001344  78001E     MOV [W14], W0
001346  900830     MOV [W0+22], W0
001348  B9006A     MUL.SU W0, #10, W0
00134A  780080     MOV W0, W1
00134C  21CAE0     MOV #0x1CAE, W0
00134E  408000     ADD W1, W0, W0
001350  780082     MOV W2, W1
001352  070307     RCALL vListInsertEnd
239:               	}
240:               }
00135A  FA8000     ULNK
00135C  060000     RETURN
241:               /*-----------------------------------------------------------*/
242:               
243:               static void prvCheckDelayedList( void )
244:               {
00135E  FA0004     LNK #0x4
245:               corCRCB *pxCRCB;
246:               
247:               	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
001360  07FA79     RCALL xTaskGetTickCount
001362  80E811     MOV 0x1D02, W1
001364  500001     SUB W0, W1, W0
001366  88E820     MOV W0, 0x1D04
248:               	while( xPassedTicks )
001368  370041     BRA 0x13EC
0013EC  80E820     MOV 0x1D04, W0
0013EE  E00000     CP0 W0
0013F0  3AFFBC     BRA NZ, 0x136A
249:               	{
250:               		xCoRoutineTickCount++;
00136A  80E800     MOV 0x1D00, W0
00136C  E80000     INC W0, W0
00136E  88E800     MOV W0, 0x1D00
251:               		xPassedTicks--;
001370  80E820     MOV 0x1D04, W0
001372  E90000     DEC W0, W0
001374  88E820     MOV W0, 0x1D04
252:               
253:               		/* If the tick count has overflowed we need to swap the ready lists. */
254:               		if( xCoRoutineTickCount == 0 )
001376  80E800     MOV 0x1D00, W0
001378  E00000     CP0 W0
00137A  3A0034     BRA NZ, 0x13E4
255:               		{
256:               			xList * pxTemp;
257:               
258:               			/* Tick count has overflowed so we need to swap the delay lists.  If there are
259:               			any items in pxDelayedCoRoutineList here then there is an error! */
260:               			pxTemp = pxDelayedCoRoutineList;
00137C  80E6B0     MOV pxDelayedCoRoutineList, W0
00137E  780F00     MOV W0, [W14]
261:               			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
001380  80E6C0     MOV pxOverflowDelayedCoRoutineList, W0
001382  88E6B0     MOV W0, pxDelayedCoRoutineList
262:               			pxOverflowDelayedCoRoutineList = pxTemp;
001384  78001E     MOV [W14], W0
001386  88E6C0     MOV W0, pxOverflowDelayedCoRoutineList
263:               		}
264:               
265:               		/* See if this tick has made a timeout expire. */
266:               		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
001388  37002D     BRA 0x13E4
0013E4  80E6B0     MOV pxDelayedCoRoutineList, W0
0013E6  780010     MOV [W0], W0
0013E8  E00000     CP0 W0
0013EA  3AFFCF     BRA NZ, 0x138A
267:               		{
268:               			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
00138A  80E6B0     MOV pxDelayedCoRoutineList, W0
00138C  900030     MOV [W0+6], W0
00138E  900030     MOV [W0+6], W0
001390  980710     MOV W0, [W14+2]
269:               
270:               			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
001392  90001E     MOV [W14+2], W0
001394  900090     MOV [W0+2], W1
001396  80E800     MOV 0x1D00, W0
001398  508F80     SUB W1, W0, [W15]
00139A  3E0028     BRA GTU, 0x13EC
271:               			{			
272:               				/* Timeout not yet expired. */																			
273:               				break;																				
274:               			}																						
275:               
276:               			portDISABLE_INTERRUPTS();
00139C  800211     MOV SR, W1
00139E  200E00     MOV #0xE0, W0
0013A0  708000     IOR W1, W0, W0
0013A2  880210     MOV W0, SR
277:               			{
278:               				/* The event could have occurred just before this critical
279:               				section.  If this is the case then the generic list item will
280:               				have been moved to the pending ready list and the following
281:               				line is still valid.  Also the pvContainer parameter will have
282:               				been set to NULL so the following lines are also valid. */
283:               				vListRemove( &( pxCRCB->xGenericListItem ) );											
0013A4  90001E     MOV [W14+2], W0
0013A6  E88000     INC2 W0, W0
0013A8  07032E     RCALL vListRemove
284:               
285:               				/* Is the co-routine waiting on an event also? */												
286:               				if( pxCRCB->xEventListItem.pvContainer )													
0013AA  90001E     MOV [W14+2], W0
0013AC  900820     MOV [W0+20], W0
0013AE  E00000     CP0 W0
0013B0  320003     BRA Z, 0x13B8
287:               				{															
288:               					vListRemove( &( pxCRCB->xEventListItem ) );											
0013B2  90001E     MOV [W14+2], W0
0013B4  40006C     ADD W0, #0xC, W0
0013B6  070327     RCALL vListRemove
289:               				}
290:               			}
291:               			portENABLE_INTERRUPTS();
0013B8  800211     MOV SR, W1
0013BA  2FF1F0     MOV #0xFF1F, W0
0013BC  608000     AND W1, W0, W0
0013BE  880210     MOV W0, SR
292:               
293:               			prvAddCoRoutineToReadyQueue( pxCRCB );													
0013C0  90001E     MOV [W14+2], W0
0013C2  9008B0     MOV [W0+22], W1
0013C4  80E7F0     MOV 0x1CFE, W0
0013C6  508F80     SUB W1, W0, [W15]
0013C8  360003     BRA LEU, 0x13D0
0013CA  90001E     MOV [W14+2], W0
0013CC  900830     MOV [W0+22], W0
0013CE  88E7F0     MOV W0, 0x1CFE
0013D0  90001E     MOV [W14+2], W0
0013D2  E88100     INC2 W0, W2
0013D4  90001E     MOV [W14+2], W0
0013D6  900830     MOV [W0+22], W0
0013D8  B9006A     MUL.SU W0, #10, W0
0013DA  780080     MOV W0, W1
0013DC  21CAE0     MOV #0x1CAE, W0
0013DE  408000     ADD W1, W0, W0
0013E0  780082     MOV W2, W1
0013E2  0702BF     RCALL vListInsertEnd
294:               		}																									
295:               	}
296:               
297:               	xLastTickCount = xCoRoutineTickCount;
0013F2  80E800     MOV 0x1D00, W0
0013F4  88E810     MOV W0, 0x1D02
298:               }
0013F6  FA8000     ULNK
0013F8  060000     RETURN
299:               /*-----------------------------------------------------------*/
300:               
301:               void vCoRoutineSchedule( void )
302:               {
0013FA  FA0002     LNK #0x2
303:               	/* See if any co-routines readied by events need moving to the ready lists. */
304:               	prvCheckPendingReadyList();
0013FC  07FF88     RCALL prvCheckPendingReadyList
305:               
306:               	/* See if any delayed co-routines have timed out. */
307:               	prvCheckDelayedList();
0013FE  07FFAF     RCALL prvCheckDelayedList
308:               
309:               	/* Find the highest priority queue that contains ready co-routines. */
310:               	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
001400  370006     BRA 0x140E
00140E  80E7F0     MOV 0x1CFE, W0
001410  B9006A     MUL.SU W0, #10, W0
001412  780080     MOV W0, W1
001414  21CAE0     MOV #0x1CAE, W0
001416  408000     ADD W1, W0, W0
001418  780010     MOV [W0], W0
00141A  E00000     CP0 W0
00141C  32FFF2     BRA Z, 0x1402
311:               	{
312:               		if( uxTopCoRoutineReadyPriority == 0 )
001402  80E7F0     MOV 0x1CFE, W0
001404  E00000     CP0 W0
001406  32002A     BRA Z, 0x145C
313:               		{
314:               			/* No more co-routines to check. */
315:               			return;
316:               		}
317:               		--uxTopCoRoutineReadyPriority;
001408  80E7F0     MOV 0x1CFE, W0
00140A  E90000     DEC W0, W0
00140C  88E7F0     MOV W0, 0x1CFE
318:               	}
319:               
320:               	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
321:               	 of the	same priority get an equal share of the processor time. */
322:               	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
00141E  80E7F0     MOV 0x1CFE, W0
001420  B9006A     MUL.SU W0, #10, W0
001422  780080     MOV W0, W1
001424  21CAE0     MOV #0x1CAE, W0
001426  408F00     ADD W1, W0, [W14]
001428  78001E     MOV [W14], W0
00142A  900010     MOV [W0+2], W0
00142C  900090     MOV [W0+2], W1
00142E  78001E     MOV [W14], W0
001430  980011     MOV W1, [W0+2]
001432  78001E     MOV [W14], W0
001434  900090     MOV [W0+2], W1
001436  78011E     MOV [W14], W2
001438  410064     ADD W2, #0x4, W0
00143A  508F80     SUB W1, W0, [W15]
00143C  3A0005     BRA NZ, 0x1448
00143E  78001E     MOV [W14], W0
001440  900010     MOV [W0+2], W0
001442  900090     MOV [W0+2], W1
001444  78001E     MOV [W14], W0
001446  980011     MOV W1, [W0+2]
001448  78001E     MOV [W14], W0
00144A  900010     MOV [W0+2], W0
00144C  900030     MOV [W0+6], W0
00144E  88E7E0     MOV W0, 0x1CFC
323:               
324:               	/* Call the co-routine. */
325:               	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
001450  80E7E0     MOV 0x1CFC, W0
001452  780110     MOV [W0], W2
001454  80E7E0     MOV 0x1CFC, W0
001456  9008C0     MOV [W0+24], W1
001458  80E7E0     MOV 0x1CFC, W0
00145A  010002     CALL W2
326:               
327:               	return;
328:               }
00145C  FA8000     ULNK
00145E  060000     RETURN
329:               /*-----------------------------------------------------------*/
330:               
331:               static void prvInitialiseCoRoutineLists( void )
332:               {
001460  FA0002     LNK #0x2
333:               unsigned portBASE_TYPE uxPriority;
334:               
335:               	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
001462  EB0000     CLR W0
001464  780F00     MOV W0, [W14]
001466  370007     BRA 0x1476
001474  E80F1E     INC [W14], [W14]
001476  200010     MOV #0x1, W0
001478  100F9E     SUBR W0, [W14], [W15]
00147A  36FFF6     BRA LEU, 0x1468
336:               	{
337:               		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
001468  78001E     MOV [W14], W0
00146A  B9006A     MUL.SU W0, #10, W0
00146C  780080     MOV W0, W1
00146E  21CAE0     MOV #0x1CAE, W0
001470  408000     ADD W1, W0, W0
001472  070257     RCALL vListInitialise
338:               	}
339:               
340:               	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
00147C  21CC20     MOV #0x1CC2, W0
00147E  070251     RCALL vListInitialise
341:               	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
001480  21CCC0     MOV #0x1CCC, W0
001482  07024F     RCALL vListInitialise
342:               	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
001484  21CDA0     MOV #0x1CDA, W0
001486  07024D     RCALL vListInitialise
343:               
344:               	/* Start with pxDelayedCoRoutineList using list1 and the
345:               	pxOverflowDelayedCoRoutineList using list2. */
346:               	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
001488  21CC20     MOV #0x1CC2, W0
00148A  88E6B0     MOV W0, pxDelayedCoRoutineList
347:               	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
00148C  21CCC0     MOV #0x1CCC, W0
00148E  88E6C0     MOV W0, pxOverflowDelayedCoRoutineList
348:               }
001490  FA8000     ULNK
001492  060000     RETURN
349:               /*-----------------------------------------------------------*/
350:               
351:               signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
352:               {
001494  FA0006     LNK #0x6
001496  980720     MOV W0, [W14+4]
353:               corCRCB *pxUnblockedCRCB;
354:               signed portBASE_TYPE xReturn;
355:               
356:               	/* This function is called from within an interrupt.  It can only access
357:               	event lists and the pending ready list.  This function assumes that a
358:               	check has already been made to ensure pxEventList is not empty. */
359:               	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
001498  90002E     MOV [W14+4], W0
00149A  900030     MOV [W0+6], W0
00149C  900030     MOV [W0+6], W0
00149E  980710     MOV W0, [W14+2]
360:               	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
0014A0  90001E     MOV [W14+2], W0
0014A2  40006C     ADD W0, #0xC, W0
0014A4  0702B0     RCALL vListRemove
361:               	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
0014A6  90001E     MOV [W14+2], W0
0014A8  4000EC     ADD W0, #0xC, W1
0014AA  21CDA0     MOV #0x1CDA, W0
0014AC  07025A     RCALL vListInsertEnd
362:               
363:               	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
0014AE  90001E     MOV [W14+2], W0
0014B0  9008B0     MOV [W0+22], W1
0014B2  80E7E0     MOV 0x1CFC, W0
0014B4  900830     MOV [W0+22], W0
0014B6  508F80     SUB W1, W0, [W15]
0014B8  390003     BRA NC, 0x14C0
364:               	{
365:               		xReturn = pdTRUE;
0014BA  200010     MOV #0x1, W0
0014BC  780F00     MOV W0, [W14]
0014BE  370002     BRA 0x14C4
366:               	}
367:               	else
368:               	{
369:               		xReturn = pdFALSE;
0014C0  EB0000     CLR W0
0014C2  780F00     MOV W0, [W14]
370:               	}
371:               
372:               	return xReturn;
0014C4  78001E     MOV [W14], W0
373:               }
0014C6  FA8000     ULNK
0014C8  060000     RETURN
374:               
